from type_class.ordered_ring import Ring, Ordered_Ring
from nat import ℕ
from int import ℤ
from int.int_base import pos_from_int_pred
from order import Linear_Order

// reuse for F, ℝ, ℂ

/// A field is a commutative ring with multiplicative inverses for all non-zero elements.
typeclass F: Field extends Ring {
    /// The multiplicative inverse function.
    reciprocal: F -> F

    /// We define the field inverse so that the inverse of zero is zero.
    /// It would be nice to instead express that an inverse is "not valid" or yields "no value"
    /// but it is not convenient to do so in the current type system.
    field_reciprocal_zero {
        F.0.reciprocal = F.0
    }

    /// The definition of "multiplicative inverse" in a field.
    field_reciprocal(f: F) {
        f != F.0 implies f ⋅ f.reciprocal = F.1
    }

    /// Zero and one are distinct elements.
    zero_and_one_are_distinct {
        F.0 != F.1
    }
}

theorem field_reciprocal_left[F: Field](f: F) {
    f != F.0 implies f.reciprocal ⋅ f = F.1
}

attributes F: Field {
    /// Extends Mul.pow to raise a field element to an integer.
    /// Similar to how we define Field.reciprocal this defines `F.0`.zpow(x) for negative x to be `0`.
    define zpow(self, exp: ℤ) -> F {
        match exp {
            ℤ.0 {
                F.1
            }
            ℤ.pos_suc(n) {
                self.pow(n.suc)
            }
            ℤ.neg_suc(k) {
                self.pow(k.suc).reciprocal
            }
        }
    }
}

theorem zero_pow_nonnegative[F: Field](n: ℤ) {
    n > ℤ.0 implies F.0.zpow(n) = F.0
} by {
    match n {
        ℤ.pos_suc(k) {
            F.0.zpow(n) = F.0.pow(k.suc)
            F.0.zpow(n) = F.0
        }
        ℤ.0 {
            not n > ℤ.0
            false
        }
        ℤ.neg_suc(k) {
            not n > ℤ.0
            false
        }
    }
}

// inverses are unique
theorem unique_inverse[F: Field](a: F, b: F) {
    a ⋅ b = F.1 implies b = a.reciprocal
} by {
    if F.0 = F.1 {
        false
    } else {
        a != F.0
        a.reciprocal ⋅ a ⋅ b = a.reciprocal ⋅ F.1
        a ⋅ a.reciprocal ⋅ b = a.reciprocal
        F.1 ⋅ b = a.reciprocal
    }
    
}

theorem inverse_inverse[F: Field](a: F) {
    a.reciprocal.reciprocal = a
}

// (a ⋅ b).reciprocal = a.reciprocal ⋅ b.reciprocal
theorem inverse_dist[F: Field](a: F, b: F) {
    (a ⋅ b).reciprocal = a.reciprocal ⋅ b.reciprocal
} by {
    if a = F.0 {
        (a ⋅ b).reciprocal = F.0.reciprocal
        (a ⋅ b).reciprocal = F.0
        a.reciprocal ⋅ b.reciprocal = F.0 ⋅ b.reciprocal
        a.reciprocal ⋅ b.reciprocal = F.0
        (a ⋅ b).reciprocal = a.reciprocal ⋅ b.reciprocal
    } else {
        if b = F.0 {
            (a ⋅ b).reciprocal = F.0.reciprocal
            (a ⋅ b).reciprocal = F.0
            a.reciprocal ⋅ b.reciprocal = a.reciprocal ⋅ F.0
            a.reciprocal ⋅ b.reciprocal = F.0
        } else {
            a ⋅ b ⋅ a.reciprocal ⋅ b.reciprocal = a ⋅ a.reciprocal ⋅ b ⋅ b.reciprocal
            a ⋅ b ⋅ a.reciprocal ⋅ b.reciprocal = F.1 ⋅ b ⋅ b.reciprocal
            (a ⋅ b) ⋅ (a.reciprocal ⋅ b.reciprocal) = F.1 ⋅ F.1
            (a ⋅ b) ⋅ (a.reciprocal ⋅ b.reciprocal) = F.1
            a.reciprocal ⋅ b.reciprocal = (a ⋅ b).reciprocal
        }
    }   
}

// a^(-n) = (a^(-1))^n for n: ℕ and >=1
// prove they both are the inverse of a^n
theorem pow_inverse_nat[F: Field](a: F, k: ℕ) {
    // n = k + 1
    a.zpow(ℤ.neg_suc(k)) = a.reciprocal.zpow(ℤ.pos_suc(k))
} by {
    let f: ℕ -> Bool = function(x: ℕ) {
        a.zpow(ℤ.neg_suc(x)) = a.reciprocal.zpow(ℤ.pos_suc(x))
    }
    // base case
    f(ℕ.0)

    // Inductive step
    forall(l: ℕ) {
        if f(l) {
            a.pow(l.suc.suc) = a.pow(l.suc) ⋅ a
            (a.pow(l.suc) ⋅ a).reciprocal = a.pow(l.suc).reciprocal ⋅ a.reciprocal
            // f(l)
            a.zpow(ℤ.neg_suc(l)).reciprocal = a.reciprocal.zpow(ℤ.neg_suc(l))
            // define of zpow
            a.pow(l.suc).reciprocal = a.reciprocal.pow(l.suc)
            a.pow(l.suc.suc).reciprocal = a.reciprocal.pow(l.suc.suc)
            a.zpow(ℤ.neg_suc(l.suc)).reciprocal = a.reciprocal.zpow(ℤ.neg_suc(l.suc))
            f(l.suc)
        }
    }
}

// a^(-n) = (a^(-1))^n
theorem pow_inverse[F: Field](a: F, n: ℤ) {
    a.zpow(-n) = a.reciprocal.zpow(n)
} by {
    match n {
        ℤ.0 {
            -n = ℤ.0
            a.zpow(-n) = F.1
            a.reciprocal.zpow(n) = F.1
            a.zpow(-n) = a.reciprocal.zpow(n)
        }
        ℤ.pos_suc(k) {
            -n = ℤ.neg_suc(k)
            a.zpow(-n) = a.reciprocal.zpow(ℤ.pos_suc(k))
            a.zpow(-n) = a.reciprocal.zpow(n)
        }
        ℤ.neg_suc(k) {
            -n = ℤ.pos_suc(k)
            a.reciprocal.zpow(n) = a.reciprocal.reciprocal.zpow(ℤ.pos_suc(k))
            a.reciprocal.zpow(n) = a.zpow(ℤ.pos_suc(k))
            a.zpow(-n) = a.reciprocal.zpow(n)
        }
    }
}

theorem pow_nat_times_inverse[F: Field](a: F, n: ℕ) {
   a != F.0 implies a.pow(n.suc) ⋅ a.reciprocal = a.pow(n)
} by {
    let f: ℕ -> Bool = function(x: ℕ) {
        a.pow(x.suc) ⋅ a.reciprocal = a.pow(x)
    }

    // base case
    f(ℕ.0)

    // Induction step
    forall(l: ℕ) {
        if f(l) {
            a.pow(l.suc) ⋅ a.reciprocal = a.pow(l)
            a.pow(l.suc.suc) ⋅ a.reciprocal = a.pow(l.suc)
            f(l.suc)
        }
    }
}

theorem pow_nat_sub_inverse[F: Field](a: F, n: ℕ, m: ℕ) {
    a != F.0 and m <= n implies a.pow(n) ⋅ a.reciprocal.pow(m) = a.pow(n - m)
} by {
    let f: ℕ -> Bool = function(x: ℕ) {
        x > n or a.pow(n) ⋅ a.reciprocal.pow(x) = a.pow(n - x)
    }

    // base case
    f(ℕ.0)

    // Inductive step
    forall(l: ℕ) {
        if f(l) {
            if l >= n {
                l.suc > n
                f(l.suc)
            } else {
                l.suc <= n
                a.reciprocal.pow(l.suc) = a.reciprocal.pow(l) ⋅ a.reciprocal
                a.pow(n) ⋅ a.reciprocal.pow(l.suc) = a.pow(n) ⋅ a.reciprocal.pow(l) ⋅ a.reciprocal
                a.pow(n) ⋅ a.reciprocal.pow(l.suc) = a.pow(n - l) ⋅ a.reciprocal
                n - l = (n - l.suc).suc
                a.pow(n) ⋅ a.reciprocal.pow(l.suc) = a.pow(n - l.suc)
                f(l.suc)
            }
        }
    }
    f(m)
}

theorem use_from_nat_pow_exists[F: Field](a: F, k: ℤ) {
    k >= ℤ.0 implies exists(n: ℕ) { 
        k = ℤ.from_nat(n) and a.zpow(k) = a.pow(n) 
    } 
} by {
    if k = ℤ.0 {
        let n = ℕ.0
        k = ℤ.from_nat(n)
        a.zpow(k) = a.pow(n)
        use_from_nat_pow_exists(a, k)
    } else {
        k > ℤ.0
        let pred: ℕ satisfy { k = ℤ.pos_suc(pred) }
        let n = pred.suc
        pos_from_int_pred(k, pred)
        k = ℤ.from_nat(n)
        a.zpow(k) = a.pow(n)
        use_from_nat_pow_exists(a, k)
    }
}

theorem use_from_nat_pow[F: Field](a: F, k: ℤ, n: ℕ) {
    k >= ℤ.0 and k = ℤ.from_nat(n) implies a.zpow(k) = a.pow(n)
} 

theorem pow_sub_inverse[F: Field](a: F, n: ℤ, m: ℤ) {
    a != F.0 and n >= ℤ.0 and m >= ℤ.0 implies a.zpow(n) ⋅ a.reciprocal.zpow(m) = a.zpow(n - m)
} by {
    let l: ℕ satisfy {
        n = ℤ.from_nat(l)
    }
    let k: ℕ satisfy {
        m = ℤ.from_nat(k)
    }
    if m <= n {
        a.zpow(n) ⋅ a.reciprocal.zpow(m) = a.pow(l) ⋅ a.reciprocal.pow(k)
        k <= l
        a.zpow(n) ⋅ a.reciprocal.zpow(m) = a.pow(l - k)
        ℤ.from_nat(l - k) = n - m
        a.zpow(n) ⋅ a.reciprocal.zpow(m) = a.zpow(n - m)
    } else {
        a.zpow(n) ⋅ a.reciprocal.zpow(m) = a.reciprocal.zpow(m) ⋅ a.reciprocal.reciprocal.zpow(n)
        a.zpow(n) ⋅ a.reciprocal.zpow(m) = a.reciprocal.pow(k) ⋅ a.reciprocal.reciprocal.pow(l)
        l <= k
        a.reciprocal != F.0
        a.zpow(n) ⋅ a.reciprocal.zpow(m) = a.reciprocal.pow(k - l)
        a.zpow(n) ⋅ a.reciprocal.zpow(m) = a.reciprocal.zpow(m - n)
        a.zpow(n) ⋅ a.reciprocal.zpow(m) = a.zpow(n - m)
    }
}

theorem pow_add_nonnegative[F: Field](a: F, n: ℤ, m: ℤ) {
    n >= ℤ.0 and m >= ℤ.0 implies a.zpow(n) ⋅ a.zpow(m) = a.zpow(n + m)
} by {
    let l: ℕ satisfy {
        n = ℤ.from_nat(l)
    }
    let k: ℕ satisfy {
        m = ℤ.from_nat(k)
    }
    a.zpow(n) ⋅ a.zpow(m) = a.pow(l) ⋅ a.pow(k)
}

theorem pow_add[F: Field](a: F, n: ℤ, m: ℤ) {
    a != F.0 implies a.zpow(n) ⋅ a.zpow(m) = a.zpow(n + m)
} by {
    if n >= ℤ.0 {
        if m >= ℤ.0 {
            a.zpow(n) ⋅ a.zpow(m) = a.zpow(n + m)
        } else {
            a.zpow(n) ⋅ a.zpow(m) = a.zpow(n) ⋅ a.reciprocal.zpow(-m)
            pow_sub_inverse(a, n, -m)
            a.zpow(n) ⋅ a.zpow(m) = a.zpow(n - (-m))
            a.zpow(n) ⋅ a.zpow(m) = a.zpow(n + m)
        }
    } else {
        -n >= ℤ.0
        if m >= ℤ.0 {
            a.zpow(n) ⋅ a.zpow(m) = a.reciprocal.zpow(-n) ⋅ a.zpow(m)
            a.zpow(n) ⋅ a.zpow(m) = a.zpow(m) ⋅ a.reciprocal.zpow(-n)
            a.zpow(n) ⋅ a.zpow(m) = a.zpow(m - (-n))
            a.zpow(n) ⋅ a.zpow(m) = a.zpow(n + m)
        } else {
            -m >= ℤ.0
            a.zpow(n) ⋅ a.zpow(m) = a.reciprocal.zpow(-n) ⋅ a.reciprocal.zpow(-m)
            a.zpow(n) ⋅ a.zpow(m) = a.reciprocal.zpow(-n + (-m))
            a.zpow(n) ⋅ a.zpow(m) = a.zpow(n + m)
        }
    }
}

theorem zero_pow[F: Field](n: ℤ) {
    n != ℤ.0 implies F.0.zpow(n) = F.0
} by {
    if n > ℤ.0 {
        F.0.zpow(n) = F.0
    } else {
        n < ℤ.0
        -n > ℤ.0
        F.0.zpow(-n) = F.0
        F.0.zpow(-n).reciprocal = F.0.zpow(n)
        F.0.zpow(n) = F.0
    }
}

theorem pow_inverse_2[F: Field](a: F, n: ℤ) {
    a.zpow(-n) = a.zpow(n).reciprocal
} by {
    if a = F.0 {
        if n = ℤ.0 {
            a.zpow(-n) = F.1
            a.zpow(n) = F.1
            a.zpow(-n) = a.zpow(n).reciprocal
        } else {
            a.zpow(-n) = F.0
            a.zpow(n) = F.0
            a.zpow(-n) = a.zpow(n).reciprocal
        }
    } else {
        a.zpow(n) ⋅ a.zpow(-n) = a.zpow(n + -n)
    }
}

theorem one_pow[F: Field](n: ℤ) {
    F.1.zpow(n) = F.1
} by {
    F.1.reciprocal = F.1
}

theorem pow_pow_nonnegative[F: Field](a: F, n: ℤ, m: ℤ) {
    n >= ℤ.0 and m >= ℤ.0 implies a.zpow(n).zpow(m) = a.zpow(n ⋅ m)
} by {
     let l: ℕ satisfy {
        n = ℤ.from_nat(l)
    }
    let k: ℕ satisfy {
        m = ℤ.from_nat(k)
    }
    a.zpow(n).zpow(m) = a.pow(l).pow(k)
    a.zpow(n ⋅ m) = a.pow(l ⋅ k)
}

// Proof that (a^n)^m = a^(n ⋅ m)
theorem pow_pow[F: Field](a: F, n: ℤ, m: ℤ) {
    a != F.0 implies a.zpow(n).zpow(m) = a.zpow(n ⋅ m)
} by {
    if n >= ℤ.0 {
        if m >= ℤ.0 {
            a.zpow(n).zpow(m) = a.zpow(n ⋅ m)
        } else {
            a != F.0
            a.zpow(n).zpow(m) = a.zpow(n).zpow(-m).reciprocal
            -m >= ℤ.0
            a.zpow(n).zpow(m) = a.zpow(n ⋅ (-m)).reciprocal
            a.zpow(n).zpow(m) = a.zpow(n ⋅ m)
        }
    } else {
        a != F.0
        -n >= ℤ.0
        if m >= ℤ.0 {
            a.zpow(n).zpow(m) = a.reciprocal.zpow(-n).zpow(m)
            a.zpow(n).zpow(m) = a.reciprocal.zpow(-n ⋅ m)
            a.zpow(n).zpow(m) = a.zpow(n ⋅ m)
        } else {
            m.is_negative
            -m >= ℤ.0
            a.zpow(n).zpow(m) = a.reciprocal.zpow(-n).zpow(-m).reciprocal
            a.zpow(n).zpow(m) = a.reciprocal.zpow(-n ⋅ -m).reciprocal
            a.zpow(n).zpow(m) = a.zpow(n ⋅ m)
        }
    }
}

theorem inverse_not_zero[F: Field](a: F) {
    a != F.0 implies a.reciprocal != F.0
}

theorem mul_not_zero[F: Field](a: F, b: F) {
    a != F.0 and b != F.0 implies a ⋅ b != F.0
} by {
    if a ⋅ b = F.0 {
        a ⋅ b ⋅ b.reciprocal = F.0
        false
    }
}

theorem pow_not_zero[F: Field](a: F, n: ℕ) {
    a != F.0 implies a.pow(n) != F.0
} by {
    // Define a helper function for induction
    define f(x: ℕ) -> Bool { a.pow(x) != F.0 }

    // Base case
    f(ℕ.0)

    // Inductive step
    forall(x: ℕ) {
        if f(x) {
            a.pow(x.suc) = a.pow(x) ⋅ a
            f(x.suc)
        }
    }
}

attributes F: Field {
    /// The quotient of two numbers.
    /// Division by zero is defined to yield zero.
    define div(self, other: F) -> F {
        self ⋅ other.reciprocal
    }
}

theorem reciprocal_by_div[F: Field](a: F) {
    a.reciprocal = F.1 / a
} 

theorem div_by_reciprocal[F: Field](p: F, q: F) {
    p/q = p ⋅ F.1 / q
}

theorem neg_by_div[F: Field](a: F) {
    F.1 / (-a) = - (F.1 / a)
}

theorem mul_inv_cancels_right[F: Field](a: F) {
    a != F.0 implies a ⋅ F.1/a = F.1
} 

theorem mul_inv_cancels_left[F: Field](a: F) {
    a != F.0 implies F.1/a ⋅ a = F.1
}

theorem reciprocal_inverts[F: Field](a: F) {
    a != F.0 implies F.1/(F.1/a) = a
} 

theorem mul_cancels_div[F: Field](a: F, b: F) {
    b != F.0 implies (a / b) ⋅ b = a
} by {
    (a / b) ⋅ b = a ⋅ b.reciprocal ⋅ b
    (a / b) ⋅ b = a ⋅ (b.reciprocal ⋅ b)
    (a / b) ⋅ b = a ⋅ F.1
    (a / b) ⋅ b = a
}

theorem mul_cancels_right[F: Field](a: F, b: F, c: F) {
    c != F.0 and a ⋅ c = b ⋅ c implies a = b
} by {
    a ⋅ c ⋅ c.reciprocal = b ⋅ c ⋅ c.reciprocal
    a ⋅ (c ⋅ c.reciprocal) = b ⋅ (c ⋅ c.reciprocal)
    a ⋅ F.1 = b ⋅ F.1
    a = b
}

theorem mul_div_cancels[F: Field](a: F, b: F)  {
    b != F.0 implies (a ⋅ b) / b = a
} by {
    (a ⋅ b) / b = a ⋅ (b / b)
    (a ⋅ b) / b = a ⋅ F.1
}

theorem reciprocal_eq[F: Field](p: F, q: F) {
    p != F.0 and q != F.0 and F.1/p = F.1/q implies p = q
} by {
    F.1/(F.1/q) = q
    F.1/(F.1/p) = p
}

theorem inverses_eq[F: Field](p: F, q: F, r: F) {
    p != F.0 and q != F.0 and r != F.0
    and r/p = r/q
    implies
    p = q
} by {
    r/p = r ⋅ F.1/p
    r/q = r ⋅ F.1/q
    r ⋅ F.1/p = r ⋅ F.1/q
    F.1/p = F.1/q
}

theorem add_div_distrib[F: Field](a: F, b: F, c: F) {
    (a + b)/c = a/c + b/c
}

theorem sub_div_distrib[F: Field](a: F, b: F, c: F) {
    (a - b)/c = a/c - b/c
}

theorem recip_mul[F: Field](a: F, b: F) {
    F.1/(a ⋅ b) = F.1/a ⋅ F.1/b
} by {
    if a = F.0 {
        // Degenerate but it works
        a ⋅ b = F.0
        F.1/(a ⋅ b) = F.0
        F.1/(a ⋅ b) = F.1/a ⋅ F.1/b
    } else {
        if b = F.0 {
            a ⋅ b = F.0
            F.1/(a ⋅ b) = F.0
            F.1/(a ⋅ b) = F.1/a ⋅ F.1/b
        } else {
            F.1/(a ⋅ b) ⋅ (a ⋅ b) = F.1
            F.1/(a ⋅ b) = F.1/a ⋅ F.1/b
        }
    }
}

theorem mul_fractions[F: Field](a: F, b: F, c: F, d: F) {
    (a / b) ⋅ (c / d) = (a ⋅ c) / (b ⋅ d)
} by {
    (a / b) ⋅ (c / d) = (a ⋅ F.1/b) ⋅ (c ⋅ F.1/d)
    (a / b) ⋅ (c / d) = (a ⋅ c) ⋅ (F.1/b ⋅ F.1/d)
    (F.1/b ⋅ F.1/d) = F.1/(b ⋅ d)
    (a / b) ⋅ (c / d) = (a ⋅ c) ⋅ F.1/(b ⋅ d)
}

theorem cancel_left_num_denom[F: Field](a: F, b: F, c: F) {
    a != F.0 implies
    (a ⋅ b) / (a ⋅ c) = b / c
} by {
    (a / a) ⋅ (b / c) = (a ⋅ b) / (a ⋅ c)
}

theorem cancel_to_reciprocal[F: Field](a: F, b: F) {
    a != F.0 and b != F.0 implies
    a/(a ⋅ b) = F.1/b
}

theorem recip_diff[F: Field](a: F, b: F) {
    a != F.0 and b != F.0 implies
    F.1/a - F.1/b = (b - a) / (a ⋅ b)
} by {
    b / (a ⋅ b) = F.1/a
    a / (a ⋅ b) = F.1/b
    (b - a) / (a ⋅ b) = (b / (a ⋅ b)) - (a / (a ⋅ b))
}

theorem recip_recip_raw[F: Field](a: F) {
    a.reciprocal.reciprocal = a
} 

theorem recip_recip[F: Field](a: F) {
    F.1/(F.1/a) = a
}

theorem mul_div_swap[F: Field](a: F, b: F, c: F) {
    a ⋅ b/c = a/c ⋅ b
}

theorem zero_recip[F: Field](a: F) {
    F.1/F.0 = F.0
}

theorem div_reciprocal[F: Field](a: F, b: F) {
    a ⋅ b != F.0 implies a/b ⋅ b/a = F.1
} by {
    a/b ⋅ b/a = (a ⋅ b)/(b ⋅ a)
    a/b ⋅ b/a = (a ⋅ b)/(a ⋅ b)
    a/b ⋅ b/a = (a ⋅ b) ⋅ F.1/(a ⋅ b)
    (a ⋅ b) ⋅ F.1/(a ⋅ b) = F.1
}