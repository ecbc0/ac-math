from type_class.ring import Ring, Add
from type_class.ordered_add import Ordered_Add, abs
from type_class.add_times import Ordered_P_Add
from order import Linear_Order
from nat.nat_base import ℕ, true_below
from list import sum, List

theorem nonnegtive_times_preserve_positive[A: Ordered_P_Add](a: A, n: ℕ) {
    a > A.0 and n != ℕ.0 implies a.times(n) > A.0
} by {
    define p(m: ℕ) -> Bool {
        a > A.0 and m != ℕ.0 implies a.times(m) > A.0
    }
    p(ℕ.0)
    forall(m: ℕ) {
        if p(m) {
            a.times(m.suc) = a.times(m) + a
            if m = ℕ.0 {
                a.times(m) = A.0
                a.times(m.suc) > A.0
            } else {
                a.times(m) > A.0
                a.times(m.suc) > A.0
            }
            a.times(m.suc) > A.0
            p(m.suc)
        }
    }
}

theorem nonnegtive_times[A: Ordered_P_Add](a: A, n: ℕ, m: ℕ) {
    a > A.0 and n < m implies a.times(n) < a.times(m)
} by {
    let d: ℕ satisfy {
        m = n + d and d != ℕ.0
    }
    a.times(m) = a.times(n) + a.times(d)
    a.times(d) > A.0
    a.times(m) > a.times(n)
}

theorem nonnegtive_times_weak[A: Ordered_P_Add](a: A, n: ℕ, m: ℕ) {
    a >= A.0 and n < m implies a.times(n) <= a.times(m)
} by {
    if a = A.0 {
        a.times(n) = a.times(m)
        a.times(n) <= a.times(m)
    } else {
        a > A.0
        a.times(n) < a.times(m)
    }
}

// reuse for ℤ, ℚ, ℝ

define is_nonnegative_list[A: Ordered_P_Add](l: List[A]) -> Bool {
    forall(a: A) {
        a ∈ l implies a >= A.0
    }
}

theorem remove_preserve_nonnegative_list[A: Ordered_P_Add](l: List[A], x: A) {
    is_nonnegative_list(l) implies is_nonnegative_list(l ∖ x)
} by {
    forall(a: A) {
        if a ∈ l ∖ x {
            a ∈ l
            a >= A.0
        }
    }
}

theorem subset_imp_sum_lte[A: Ordered_P_Add](list_1: List[A], list_2: List[A]) {
    is_nonnegative_list(list_1) and is_nonnegative_list(list_2) and list_1 ⊆ list_2 implies sum(list_1) <= sum(list_2)
} by {
    define p(n: ℕ) -> Bool {
        forall(l1: List[A], l2: List[A]) {
            l2.length = n and is_nonnegative_list(l1) and is_nonnegative_list(l2) and l1 ⊆ l2 implies sum(l1) <= sum(l2)
        }

    }
    p(ℕ.0)
    forall(k: ℕ) {
        if true_below(p, k) {
            if k = ℕ.0 {
                p(k)
            } else {
                k != ℕ.0
                forall(l1: List[A], l2: List[A]) {
                    if l2.length = k and is_nonnegative_list(l1) and is_nonnegative_list(l2) and l1 ⊆ l2 {
                        let x: A satisfy { x ∈ l2 }
                        x >= A.0

                        l1.count(x) <= l2.count(x)

                        x.times(l1.count(x)) + sum(l1 ∖ x) = sum(l1)

                        x.times(l2.count(x)) + sum(l2 ∖ x) = sum(l2)

                        (l2 ∖ x).length < k

                        (l1 ∖ x) ⊆ (l2 ∖ x)
                        is_nonnegative_list(l1 ∖ x)
                        is_nonnegative_list(l2 ∖ x)

                        sum(l1 ∖ x) <= sum(l2 ∖ x)

                        x.times(l1.count(x)) <= x.times(l2.count(x))

                        x.times(l1.count(x)) + sum(l1 ∖ x) <= x.times(l2.count(x)) + sum(l2 ∖ x)

                        sum(l1) <= sum(l2)
                    }
                }
                p(k)
            }
            p(k)
        }
    }
    p(list_1.length)
}

// reuse theorem to ℤ, ℚ, ℝ
typeclass R: Ordered_Ring extends Ring, Ordered_Add {
    /// product of positive elements is positive
    mul_preserves_pos(a: R, b: R) {
        a > R.0 and b > R.0 implies a * b > R.0
    } 
}

theorem neg_change_sign[R: Ordered_Ring](a: R) {
    a > R.0 iff -a < R.0
} by {
    if a > R.0 {
        a + -a > -a
        R.0 > -a
    }
    if -a < R.0 {
        a + -a < a + R.0
        R.0 < a
    }
}

theorem neg_change_sign_weak[R: Ordered_Ring](a: R) {
    a >= R.0 iff -a <= R.0
} by {
    a >= R.0 implies -a <= R.0
}

theorem mul_nonneg_nonneg_nonneg[R: Ordered_Ring](a: R, b: R) {
    a >= R.0 and b >= R.0 implies (a * b) >= R.0
} by {
    if a = R.0 or b = R.0 {
        a * b = R.0
        (a * b) >= R.0
    } else {
        a > R.0
        b > R.0
        a * b > R.0
        (a * b) >= R.0
    }
}

theorem mul_nonneg_nonpos_nonpos[R: Ordered_Ring](a: R, b: R) {
    a >= R.0 and b <= R.0 implies (a * b) <= R.0
}

theorem mul_pos_neg_neg[R: Ordered_Ring](a: R, b: R) {
    a > R.0 and b < R.0 implies (a * b) < R.0
}

theorem mul_nonpos_nonneg_nonpos[R: Ordered_Ring](a: R, b: R) {
    a <= R.0 and b >= R.0 implies (a * b) <= R.0
}

theorem mul_nonpos_nonpos_nonneg[R: Ordered_Ring](a: R, b: R) {
    a <= R.0 and b <= R.0 implies (a * b) >= R.0
}

theorem mul_neg_neg_pos[R: Ordered_Ring](a: R, b: R) {
    a < R.0 and b < R.0 implies (a * b) > R.0
}


theorem mul_neg_pos_neg[R: Ordered_Ring](a: R, b: R) {
    a < R.0 and b > R.0 implies (a * b) < R.0
}

theorem square_gte_zero[R: Ordered_Ring](a: R) {
    a * a >= R.0
} by {
    if a > R.0 {
    } else {
        a <= R.0
    }
}

theorem one_gte_zero[R: Ordered_Ring] {
    R.1 >= R.0
} by {
    R.1 * R.1 = R.1
    R.1 * R.1 >= R.0
    R.1 >= R.0
}

theorem one_gt_zero[R: Ordered_Ring] {
    R.1 != R.0 implies R.1 > R.0
}

theorem lt_mul_pos[R: Ordered_Ring](a: R, b: R, c: R) {
    a < b and c > R.0 implies a * c < b * c
} by {
    b - a > R.0
    c > R.0
    (b - a) * c > R.0
    b * c - a * c > R.0
}

theorem lt_mul_pos_neg[R: Ordered_Ring](a: R, b: R, c: R) {
    a < b and c < R.0 implies a * c > b * c
} 

theorem lte_mul_pos[R: Ordered_Ring](a: R, b: R, c: R) {
    a <= b and c > R.0 implies a * c <= b * c
} 

theorem mul_lt_lt[R: Ordered_Ring](a: R, b: R, c: R, d: R) {
    a > R.0 and c > R.0 and a < b and c < d implies a * c < b * d
} by {
    a * c < b * c
    b > R.0
    b * c < b * d
}

theorem mul_lt_lte[R: Ordered_Ring](a: R, b: R, c: R, d: R) {
    a > R.0 and c > R.0 and a < b and c <= d implies a * c < b * d
} by {
    a * c < b * c
    b > R.0
    b * c <= b * d
}

theorem mul_lte_lt[R: Ordered_Ring](a: R, b: R, c: R, d: R) {
    a > R.0 and c > R.0 and a <= b and c < d implies a * c < b * d
} by {
    a * c <= b * c
    b > R.0
    b * c < b * d
}

theorem lt_pos_mul_lt_pos[R: Ordered_Ring](a: R, b: R, c: R, d: R) {
    a >= R.0 and c >= R.0 and a < b and c < d
    implies
    a * c < b * d
} by {
    a * c <= b * c
    b > R.0
    b * c < b * d
}

theorem lte_mul_lte[R: Ordered_Ring](a: R, b: R, c: R, d: R) {
    a >= R.0 and c >= R.0 and a <= b and c <= d
    implies
    a * c <= b * d
} by {
    not b < R.0
    not d < R.0
    if a = b {
        c * b <= d * b
        a * c <= b * d
    } else {
        a < b
        if c = d {
            a * c <= b * d
        } else {
            c < d
            a * c < b * d
            a * c <= b * d
        }
    }
}

theorem lte_mul_nonneg[R: Ordered_Ring](a: R, b: R, c: R) {
    a <= b and c >= R.0 implies a * c <= b * c
} by {
    if c = R.0 {
        a * c = R.0
        b * c = R.0
        a * c <= b * c
    } else {
        c > R.0
        a * c <= b * c
    }
}

theorem lt_neg[R: Ordered_Ring](p: R, q: R) {
    p < q implies -p > -q
} by {
    (q - p) > R.0
    (q - p) + -q > -q
    (q - p) + -q = (q + -q) - p
    -p > -q
}

theorem lte_neg[R: Ordered_Ring](p: R, q: R) {
    p <= q implies -p >= -q
} 

theorem lt_cancel_pos_mul_right[R: Ordered_Ring](a: R, b: R, c: R) {
    c > R.0 and a * c < b * c implies a < b
} by {
    if a >= b {
        a * c >= b * c
        not (a * c < b * c)
        false
    }
}

theorem lt_cancel_pos_mul_left[R: Ordered_Ring](a: R, b: R, c: R) {
    c > R.0 and c * a < c * b implies a < b
}

theorem gt_cancel_pos_mul_right[R: Ordered_Ring](a: R, b: R, c: R) {
    c > R.0 and a * c > b * c implies a > b
} 

theorem gt_cancel_pos_mul_left[R: Ordered_Ring](a: R, b: R, c: R) {
    c > R.0 and c * a > c * b implies a > b
} 

theorem cancel_positivity_left[R: Ordered_Ring](a: R, b: R) {
    a > R.0 and (a * b) > R.0 implies b > R.0
} 

theorem cancel_positivity_right[R: Ordered_Ring](a: R, b: R) {
    b > R.0 and (a * b) > R.0 implies a > R.0
}

theorem abs_distrib_mul[R: Ordered_Ring](a: R, b: R) {
    (a * b).abs = (a).abs * (b).abs
} by {
    if a > R.0 {
        if b > R.0 {
            a * b > R.0
            abs(a * b) = abs(a) * abs(b)
        } else {
            a * b <= R.0
            abs(a * b) = abs(a) * abs(b)
        }
    } else {
        if b > R.0 {
            a * b <= R.0
            abs(a * b) = abs(a) * abs(b)
        } else {
            a * b >= R.0
            abs(a * b) = abs(a) * abs(b)
        }
    }
}

theorem pow_abs_eq_abs_pow[R: Ordered_Ring](a: R, n: ℕ) {
    abs(a^n) = abs(a)^n
} by {
    let f = function(x: ℕ) {
        abs(a^x) = abs(a)^x
    }
    a^(ℕ.0) = R.1
    R.1 >= R.0
    abs(R.1) = R.1
    abs(a)^(ℕ.0) = R.1
    f(ℕ.0)
    forall(x: ℕ) {
        if f(x) {
            abs(a^x) = abs(a)^x
            abs(a^(x.suc)) = abs(a)^(x.suc)
            f(x.suc)
        }
    }
    f(n)
}