from type_class.field import Field
from type_class.ordered_ring import Ordered_Ring

// reuse for F, ℝ

typeclass F: Ordered_Field extends Field, Ordered_Ring

theorem pos_reciprocal_raw[F: Ordered_Field](a: F) {
    a > F.0 implies a.reciprocal > F.0
} by {
    if not a.reciprocal > F.0 {
        a.reciprocal <= F.0
        a ⋅ a.reciprocal <= F.0
        a ⋅ a.reciprocal = F.1
        F.1 >= F.0
        F.1 != F.0
        F.1 > F.0
        a ⋅ a.reciprocal > F.0
        false
    }
}

theorem pos_reciprocal[F: Ordered_Field](a: F) {
    a > F.0 implies F.1/a > F.0
}

theorem pos_reciprocal_iff[F: Ordered_Field](a: F) {
    a > F.0 iff F.1/a > F.0
} by {
    if F.1/a > F.0 {
        F.1/(F.1/a) > F.0
        a != F.0
        F.1/(F.1/a) = a
        a > F.0
    }
}

theorem lt_div_pos[F: Ordered_Field](a: F, b: F, c: F) {
    c > F.0 and a < b implies a/c < b/c
} by {
    F.1/c > F.0
    a ⋅ F.1/c < b ⋅ F.1/c
}

theorem lte_div_pos[F: Ordered_Field](a: F, b: F, c: F) {
    c > F.0 and a <= b implies a/c <= b/c
} 

theorem lt_pos_reciprocal[F: Ordered_Field](a: F, b: F) {
    a > F.0 and a < b implies F.1/b < F.1/a
} by {
    F.1/a > F.0
    F.1/b > F.0
    a ⋅ F.1/a ⋅ F.1/b < b ⋅ F.1/a ⋅ F.1/b
    a ⋅ F.1/a ⋅ F.1/b = F.1/b
    (b ⋅ F.1/a) ⋅ F.1/b = b ⋅ (F.1/a ⋅ F.1/b)
    b ⋅ F.1/a ⋅ F.1/b = F.1/a
    F.1/b < F.1/a
}

theorem pos_inverses_lt[F: Ordered_Field](p: F, q: F, r: F) {
    p > F.0 and q > F.0 and r > F.0
    and r/p < r/q
    implies
    p > q
} by {
    r ⋅ F.1/p < r ⋅ F.1/q
    F.1/p < F.1/q
    F.1/(F.1/q) < F.1/(F.1/p)
    F.1/(F.1/q) = q
    F.1/(F.1/p) = p
}

theorem pos_inverses_lte[F: Ordered_Field](p: F, q: F, r: F) {
    p > F.0 and q > F.0 and r > F.0
    and r/p <= r/q
    implies
    p >= q
} by {
    p != F.0 
    q != F.0 
    r != F.0
    if r/p = r/q { 
        p = q 
    } else {
        r/p < r/q
        p > q
    }
}

theorem pos_inverses_gt[F: Ordered_Field](p: F, q: F, r: F) {
    p > F.0 and q > F.0 and r > F.0
    and r/p > r/q
    implies
    p < q
}

theorem pos_inverses_gte[F: Ordered_Field](p: F, q: F, r: F) {
    p > F.0 and q > F.0 and r > F.0
    and r/p >= r/q
    implies
    p <= q
} by {
    if r/p = r/q { p = q } else {
        r/p > r/q
        p < q
    }
}

theorem lt_cancel_add_right[F: Ordered_Field](p: F, q: F, r: F) {
    p + r < q + r implies p < q
} by {
    if p >= q {
        p + r >= q + r
        false
    }
}

theorem square_lt_imp_lt[F: Ordered_Field](a: F, b: F) {
    a > F.0 and b > F.0 and a ⋅ a < b ⋅ b
    implies
    a < b
} by {
    if a >= b {
        a ⋅ a >= b ⋅ a
        b ⋅ a >= b ⋅ b
        a ⋅ a >= b ⋅ b
        false
    }
}

theorem lt_rhs_div_pos[F: Ordered_Field](a: F, b: F, c: F) {
    c > F.0 and a < b/c implies a ⋅ c < b
} by {
    a ⋅ c < b/c ⋅ c
    b/c ⋅ c = b
}

theorem lte_cancel_mul_pos[F: Ordered_Field](p: F, q: F, r: F) {
    r > F.0 and p ⋅ r <= q ⋅ r
    implies
    p <= q
} by {
    if p ⋅ r = q ⋅ r {
        p = q
        p <= q
    } else {
        p ⋅ r < q ⋅ r
        p < q
        p <= q
    }
}

theorem div_neg_neg[F: Ordered_Field](a: F, b: F) {
    a < F.0 and b < F.0
    implies
    a/b > F.0
} by {
    a/b = a ⋅ F.1/b
    F.1/b < F.0
}

theorem div_negs_cancel[F: Ordered_Field](a: F, b: F) {
    a / b = (-a) / (-b)
} by {
    -F.1 != F.0
    (-F.1 ⋅ a) / (-F.1 ⋅ b) = a / b
    (-F.1 ⋅ a) / -b = a / b
}

theorem abs_reciprocal[F: Ordered_Field](a: F) {
    (F.1/a).abs = F.1/a.abs
} by {
    if a >= F.0 { 
        a.abs = a
        (F.1/a).abs = F.1/a.abs 
    } else {
        a < F.0
        F.1/a < F.0
        a.abs = -a
        (F.1/a).abs = F.1/a.abs 
    }
}

theorem abs_div[F: Ordered_Field](a: F, b: F) {
    b != F.0 implies
    (a / b).abs = a.abs / b.abs
} 

theorem abs_of_div[F: Ordered_Field](a: F, b: F) {
    (a / b).abs = a.abs / b.abs
} 

theorem lt_make_left_denom[F: Ordered_Field](a: F, b: F, c: F) {
    c > F.0 and a < b ⋅ c implies a/c < b
}

theorem lt_make_right_denom[F: Ordered_Field](a: F, b: F, c: F) {
    b > F.0 and a ⋅ b < c implies a < c/b
} by {
    F.1/b > F.0
    a ⋅ b ⋅ F.1/b < c ⋅ F.1/b
    a ⋅ b ⋅ F.1/b = a
    a < c ⋅ F.1/b
}

theorem lt_elim_left_denom[F: Ordered_Field](a: F, b: F, c: F) {
    b > F.0 and a/b < c implies a < c ⋅ b
}