from set import Set, empty, union, intersection, elem_in_union_general
from order import Partial_Order

/// Two elements are comparable if one is less than or equal to the other.
define comparable[P: Partial_Order](a: P, b: P) -> Bool {
    a <= b or b <= a
}

/// Comparability is symmetric: a is comparable to b iff b is comparable to a.
theorem comparable_comm[P: Partial_Order](a: P, b: P) {
    comparable(a, b) iff comparable(b, a)
} by {
    comparable(a, b) implies comparable(b, a)
}

/// A chain is a set where any two elements are comparable.
define is_chain[P: Partial_Order](c: Set[P]) -> Bool {
    forall(a: P, b: P) {
        a ∈ c and b ∈ c implies comparable(a, b)
    }
} 

/// A chain extension exists when s can be added to chain c to form a larger chain.
define is_chain_extention[P: Partial_Order](c: Set[P], s: P) -> Bool {
    is_chain(c) and s ∉ c and forall(t: P) {
        t ∈ c implies comparable(t, s)
    }
}

/// Extend chain c by adding s if possible, otherwise return c unchanged.
define chain_extension[P: Partial_Order](c: Set[P], s: P) -> Set[P] {
    if is_chain_extention(c, s) {
        c ∪ Set[P].singleton(s)
    } else {
        c
    }
}

/// Valid chain extensions produce larger chains.
theorem chain_extension_is_chain_extension[P: Partial_Order](c: Set[P], s: P) {
    is_chain_extention(c, s) implies is_chain(chain_extension(c, s)) and c ⊂ chain_extension(c, s)
} by {
    is_chain(c)
    s ∉ c
    forall(s1: P, s2: P) {
        if s1 ∈ chain_extension(c, s) and s2 ∈ chain_extension(c, s) {
            if s1 ∈ c {
                if s2 ∈ c { 
                    comparable(s1, s2) 
                } else {
                    s2 ∈ Set[P].singleton(s)
                    s2 = s
                    comparable(s1, s2)
                }
            } else {
                s1 ∈ Set[P].singleton(s)
                s1 = s
                if s2 ∈ c {
                    comparable(s1, s2)
                } else {
                    s2 ∈ Set[P].singleton(s)
                    s2 = s
                    comparable(s1, s2)
                }
            }
            comparable(s1, s2)
        }
    }
    is_chain(chain_extension(c, s)) 
    s ∈ Set[P].singleton(s)
    s ∈ chain_extension(c, s)
    s ∉ c
    c ⊆ chain_extension(c, s)
    c ⊂ chain_extension(c, s)
}

/// A maximal chain is a chain that cannot be extended by any element.
define is_maximal_chain[P: Partial_Order](c: Set[P]) -> Bool {
    is_chain(c) and forall(s: P) {
        not is_chain_extention(c, s)
    }
}

/// Non-maximal chains can be extended.
theorem not_maximal_chain_imp[P: Partial_Order](c: Set[P]) {
    is_chain(c) implies (
        not is_maximal_chain(c) implies exists(s: P) {
            is_chain_extention(c, s)
        }
    )
} 

/// If a chain can be extended, it is not maximal.
theorem not_maximal_chain_imp_rev[P: Partial_Order](c: Set[P]) {
    is_chain(c) implies (
        exists(s: P) {
            is_chain_extention(c, s)
        } implies not is_maximal_chain(c)
    )
} 

/// A non-maximal chain is a chain that can be extended.
define is_non_maximal_chain[P: Partial_Order](c: Set[P]) -> Bool {
    is_chain(c) and not is_maximal_chain(c)
}

/// Placeholder element used when chain is maximal.
let void[P]: P satisfy { true }

/// Choice function extending non-maximal chains, using axiom of choice.
let chain_extend_fn[P: Partial_Order](c: Set[P]) -> s: P satisfy {
    if is_non_maximal_chain(c) {
        is_chain_extention(c, s)
    } else {
        s = void
    }
}

/// Successor chain: extend c if possible, otherwise return c.
define suc[P: Partial_Order](c: Set[P]) -> Set[P] {
    chain_extension(c, chain_extend_fn(c))
}

/// A set of chains: collection of subsets of P that are all chains.
define are_chains[P: Partial_Order](cs: Set[Set[P]]) -> Bool {
    forall(c: Set[P]) {
        c ∈ cs implies is_chain(c)
    }
}

/// Subsets of a set of chains are also sets of chains.
theorem subchains[P: Partial_Order](cs: Set[Set[P]]) {
    are_chains(cs) implies forall(ds: Set[Set[P]]) {
        ds ⊆ cs implies are_chains(ds)
    }
}

/// Two chains are comparable if one is subset of the other.
define is_chain_comparable[P: Partial_Order](c1: Set[P], c2: Set[P]) -> Bool {
    c1 ⊆ c2 or c2 ⊆ c1
}

/// Chain comparability is symmetric.
theorem chain_comparable_comm[P: Partial_Order](c1: Set[P], c2: Set[P]) {
    is_chain_comparable(c1, c2) iff is_chain_comparable(c2, c1)
} by {
    is_chain_comparable(c1, c2) implies is_chain_comparable(c2, c1)
}

/// Linear chains: all chains in the collection are pairwise comparable by subset relation.
define is_linear_chains[P: Partial_Order](cs: Set[Set[P]]) -> Bool {
    forall(c1: Set[P], c2: Set[P]) {
        c1 ∈ cs and c2 ∈ cs implies is_chain_comparable(c1, c2)
    }
}

/// Subsets of linear chains are linear.
theorem sub_chains_of_linear_chains_is_linear[P: Partial_Order](cs: Set[Set[P]], ds: Set[Set[P]]) {
    is_linear_chains(cs) and ds ⊆ cs implies is_linear_chains(ds)
}

/// Union of linear chains is a chain.
theorem union_linear_chains_is_chain[P: Partial_Order](cs: Set[Set[P]]) {
    are_chains(cs) and is_linear_chains(cs) implies is_chain(union(cs))
} by {
    forall(s1: P, s2: P) {
        if s1 ∈ union(cs) and s2 ∈ union(cs) {
            let c1: Set[P] satisfy { c1 ∈ cs and s1 ∈ c1 }
            let c2: Set[P] satisfy { c2 ∈ cs and s2 ∈ c2 }
            is_chain(c1)
            is_chain(c2)
            c1 ⊆ c2 or c2 ⊆ c1
            if c1 ⊆ c2 {
                s1 ∈ c2
                comparable(s1, s2)
            } else {
                c2 ⊆ c1
                s2 ∈ c1
                comparable(s1, s2)
            }
            comparable(s1, s2)
        }
    }
}

/// Direct induction: closed under successor operation.
define contains_suc[P: Partial_Order](cs: Set[Set[P]]) -> Bool {
    forall(c: Set[P]) {
        c ∈ cs implies suc(c) ∈ cs
    }
}

/// Strong induction: closed under union of linear subchains.
define contains_extension_of_linear_subchains[P: Partial_Order](cs: Set[Set[P]]) -> Bool {
    forall(ds: Set[Set[P]]) {
        ds ⊆ cs and is_linear_chains(ds) implies union(ds) ∈ cs
    }
}

// from Halmos's Naive Set Theory
/// Inductive chains: contain empty set, closed under successor and union of linear subchains.
define are_inductive_chains[P: Partial_Order](cs: Set[Set[P]]) -> Bool {
    are_chains(cs) and
    // the starting element "0"
    Set[P].empty_set ∈ cs and
    contains_suc(cs) and
    contains_extension_of_linear_subchains(cs)
}

/// Set of all chains in the partial order.
let all_chains[P: Partial_Order] = Set[Set[P]].new(is_chain)

/// The set of all chains is a set of chains.
theorem all_chains_are_chains[P: Partial_Order] {
    are_chains(all_chains[P])
} by {
    forall(c: Set[P]) {
        c ∈ all_chains[P] implies is_chain(c)
    }
}

/// The set of all chains is inductive.
theorem all_chains_are_inductive_chain[P: Partial_Order] {
    are_inductive_chains(all_chains[P])
} by {
    are_chains(all_chains[P])
    Set[P].empty_set ∈ all_chains[P]

    forall(c: Set[P]) {
        if c ∈ all_chains[P] {
            is_chain(c) 
            is_chain(suc(c))
            suc(c) ∈ all_chains[P]
        }
    }
    contains_suc(all_chains[P])

    forall(ds: Set[Set[P]]) {
        if ds ⊆ all_chains[P] and is_linear_chains(ds) {
            are_chains(all_chains[P])
            are_chains(ds)
            is_chain(union(ds))
            union(ds) ∈ all_chains[P]
        } 
    }
    contains_extension_of_linear_subchains(all_chains[P])
}

/// There exists an inductive set of chains.
theorem exists_inductive_chain[P: Partial_Order] {
    exists(cs: Set[Set[P]]) {
        are_inductive_chains(cs)
    }
} by {
    let cs = all_chains[P]
}

// Or use intersection
/// Smallest inductive chains: chains that belong to every inductive collection.
define elem_in_smallest_inductive_chains[P: Partial_Order](c: Set[P]) -> Bool {
    forall(cs: Set[Set[P]]) {
        are_inductive_chains(cs) implies c ∈ cs
    }
}

/// The smallest inductive set of chains.
let smallest_inductive_chains[P: Partial_Order] = Set[Set[P]].new(elem_in_smallest_inductive_chains)

/// The smallest inductive chains are subset of every inductive collection.
theorem smallest_inductive_chains_is_smallest [P: Partial_Order](cs: Set[Set[P]]) {
    are_inductive_chains(cs) implies smallest_inductive_chains[P] ⊆ cs
}

/// Empty chain is in the smallest inductive chains.
theorem smallest_inductive_chains_contains_empty[P: Partial_Order] {
    Set[P].empty_set ∈ smallest_inductive_chains[P]
} by {
    forall(cs: Set[Set[P]]) {
        are_inductive_chains(cs) implies Set[P].empty_set ∈ cs
    }
}

/// Smallest inductive chains is a set of chains.
theorem smallest_inductive_chains_are_chains[P: Partial_Order] {
    are_chains(smallest_inductive_chains[P])
} by {
    forall(c: Set[P]) {
        if c ∈ smallest_inductive_chains[P] {
            let cs: Set[Set[P]] satisfy { 
                c ∈ cs and are_inductive_chains(cs)
            }
            are_chains(cs)
            is_chain(c)
        } 
    }
}

/// Smallest inductive chains closed under successor.
theorem smallest_inductive_chains_contains_suc[P: Partial_Order] {
    contains_suc(smallest_inductive_chains[P])
} by {
    forall(c: Set[P]) {
        if c ∈ smallest_inductive_chains[P] {
            forall(cs: Set[Set[P]]) {
                if are_inductive_chains(cs) {
                    contains_suc(cs)
                    c ∈ cs
                    suc(c) ∈ cs
                }
            }
            suc(c) ∈ smallest_inductive_chains[P]
        }
    }
}

/// Smallest inductive chains closed under union of linear subchains.
theorem smallest_inductive_chains_contains_extension_of_linear_subchains[P: Partial_Order] {
    contains_extension_of_linear_subchains(smallest_inductive_chains[P])
} by {
    forall(ds: Set[Set[P]]) {
        if ds ⊆ smallest_inductive_chains[P] and is_linear_chains(ds) {
            forall(cs: Set[Set[P]]) {
                if are_inductive_chains(cs) {
                    ds ⊆ cs
                    union(ds) ∈ cs
                }
            }
            union(ds) ∈ smallest_inductive_chains[P]
        }
    }
}

/// The smallest inductive chains form an inductive collection.
theorem smallest_inductive_chains_are_inductive_chains[P: Partial_Order] {
    are_inductive_chains(smallest_inductive_chains[P])
}

/// A comparable chain is comparable with every chain in smallest inductive collection.
define is_comparable_chain[P: Partial_Order](c: Set[P]) -> Bool {
    c ∈ smallest_inductive_chains[P] and forall(d: Set[P]) {
        d ∈ smallest_inductive_chains[P] implies is_chain_comparable(c, d)
    }
}

/// Empty chain is comparable with all chains.
theorem empty_is_comparable_chain[P: Partial_Order] {
    is_comparable_chain(Set[P].empty_set)
}

// we want to prove that suc(c) is also is_comparable_chain, start from empty, and hence they form a are_inductive_chains

/// If comparable chain c strictly contains a, then successor of a is subset of c.
theorem inductive_compare_subset_not_eq[P: Partial_Order](c: Set[P], a: Set[P]) {
    is_comparable_chain(c) and a ∈ smallest_inductive_chains[P] and a ⊂ c implies suc(a) ⊆ c
} by {
    let s: P satisfy { s ∈ c and s ∉ a }
    is_chain_extention(a, s)
    is_non_maximal_chain(a)
    if not suc(a) ⊆ c {
        c ⊂ suc(a)
        let t: P satisfy { 
            t ∈ suc(a) and t ∉ c
        }
        if t ∈ a {
            t ∈ c
            false
        }
        not t ∈ a
        suc(a) = a ∪ Set[P].singleton(chain_extend_fn(a))
        c ⊂ a ∪ Set[P].singleton(chain_extend_fn(a))
        t ∈ Set[P].singleton(chain_extend_fn(a))
        t = chain_extend_fn(a)
        c ⊂ a ∪ Set[P].singleton(t)
        forall(u: P) {
            if u ∈ c {
                u != t 
                u ∉ Set[P].singleton(t)
                u ∈ a
            }
        }
        c ⊂ a
        false
    }
}

/// Elements of suc_compare are chains in smallest inductive comparable with c or containing suc(c).
define elem_in_suc_compare[P: Partial_Order](c: Set[P], a: Set[P]) -> Bool {
    is_comparable_chain(c) and a ∈ smallest_inductive_chains[P] and (a ⊆ c or suc(c) ⊆ a)
}

/// Set of chains comparable with c or containing successor of c.
define suc_compare[P: Partial_Order](c: Set[P]) -> Set[Set[P]] {
    Set[Set[P]].new(elem_in_suc_compare(c))
}

/// suc_compare is subset of smallest inductive chains.
theorem inductive_compare_subset[P: Partial_Order](c: Set[P]) {
    suc_compare(c) ⊆ smallest_inductive_chains[P]
}

/// For comparable chains, suc_compare forms an inductive collection.
theorem inductive_compare_are_inductive_chains[P: Partial_Order](c: Set[P]) {
    is_comparable_chain(c) implies are_inductive_chains(suc_compare(c))
} by {
    are_chains(suc_compare(c))

    Set[P].empty_set ⊆ c
    Set[P].empty_set ∈ suc_compare(c)

    forall(a: Set[P]) {
        if a ∈ suc_compare(c) {
            a ∈ smallest_inductive_chains[P]
            suc(a) ∈ smallest_inductive_chains[P]
            if a ⊂ c {
                suc(a) ⊆ c
                suc(a) ∈ suc_compare(c)
            } else {
                if a = c {
                    suc(a) = suc(c)
                    suc(c) ⊆ suc(a)
                    suc(a) ∈ suc_compare(c)
                } else {
                    suc(c) ⊆ a
                    a ⊆ suc(a)
                    suc(c) ⊆ suc(a)
                    suc(a) ∈ suc_compare(c)
                }
                suc(a) ∈ suc_compare(c)
            }
            suc(a) ∈ suc_compare(c)
        }
    }
    contains_suc(suc_compare(c))

    forall(ds: Set[Set[P]]) {
        if ds ⊆ suc_compare(c) and is_linear_chains(ds) {
            suc_compare(c) ⊆ smallest_inductive_chains[P]

            ds ⊆ smallest_inductive_chains[P]

            union(ds) ∈ smallest_inductive_chains[P]

            forall(a: P) {
                if a ∈ union(ds) {
                    elem_in_union_general(ds, a)
                    let d: Set[P] satisfy {
                        d ∈ ds and a ∈ d
                    }
                    d ∈ suc_compare(c) 
                    d ⊆ c or suc(c) ⊆ d
                    d ⊆ union(ds)
                    a ∈ c or suc(c) ⊆ union(ds)
                }
            }
            union(ds) ⊆ c or suc(c) ⊆ union(ds)

            union(ds) ∈ suc_compare(c)
        }
    }
    contains_extension_of_linear_subchains(suc_compare(c))
}

/// For comparable chains, suc_compare equals the smallest inductive chains.
theorem inductive_compare_is_smallest_inductive_chains[P: Partial_Order](c: Set[P]) {
    is_comparable_chain(c) implies suc_compare(c) = smallest_inductive_chains[P]
} by {
    are_inductive_chains(suc_compare(c))

    smallest_inductive_chains[P] ⊆ suc_compare(c)

    suc_compare(c) ⊆ smallest_inductive_chains[P]
}

/// Successor operation preserves the comparable chain property.
theorem suc_preserve_comparable_chain[P: Partial_Order](c: Set[P]) {
    is_comparable_chain(c) implies is_comparable_chain(suc(c))
} by {
    forall(a: Set[P]) {
        if a ∈ smallest_inductive_chains[P] {
            a ∈ suc_compare(c) 
            if not suc(c) ⊆ a {
                a ⊆ c
                c ⊆ suc(c)
                a ⊆ suc(c)
            }
            a ⊆ suc(c) or suc(c) ⊆ a
        }
    }
    suc(c) ∈ smallest_inductive_chains[P]
    is_comparable_chain(suc(c))
}

/// Set of all comparable chains in smallest inductive collection.
let comparable_chains[P: Partial_Order] = Set[Set[P]].new(is_comparable_chain)

/// Comparable chains are subset of smallest inductive chains.
theorem comparable_chains_subset[P: Partial_Order] {
    comparable_chains[P] ⊆ smallest_inductive_chains[P]
}

/// Comparable chains closed under successor.
theorem suc_preserve_comparable_chain_by_comparable_chains[P: Partial_Order](c: Set[P]) {
    c ∈ comparable_chains[P] implies suc(c) ∈ comparable_chains[P]
}

/// Comparable chains equal the smallest inductive chains.
theorem comparable_chains_is_smallest_inductive_chains[P: Partial_Order] {
    comparable_chains[P] = smallest_inductive_chains[P]
} by {
    are_chains(comparable_chains[P])

    Set[P].empty_set ∈ comparable_chains[P]

    contains_suc(comparable_chains[P])

    forall(cs: Set[Set[P]]) {
        if cs ⊆ comparable_chains[P] and is_linear_chains(cs) {
            cs ⊆ smallest_inductive_chains[P]
            
            union(cs) ∈ smallest_inductive_chains[P]

            forall(d: Set[P]) {
                if d ∈ smallest_inductive_chains[P] {
                    if forall(c: Set[P]) {
                        c ∈ cs implies c ⊆ d
                    } {
                        union(cs) ⊆ d
                        is_chain_comparable(union(cs), d)
                    } else {
                        let c: Set[P] satisfy {
                            c ∈ cs and (not c ⊆ d)
                        }
                        c ∈ comparable_chains[P]
                        is_chain_comparable(c, d)
                        d ⊂ c
                        d ⊆ c
                        c ⊆ union(cs)
                        d ⊆ union(cs)
                        is_chain_comparable(union(cs), d)
                    }
                    is_chain_comparable(union(cs), d)
                }
            }
            union(cs) ∈ comparable_chains[P]
        }     
    }
    contains_extension_of_linear_subchains(comparable_chains[P])

    are_inductive_chains(comparable_chains[P])

    smallest_inductive_chains[P] ⊆ comparable_chains[P]
}

/// Smallest inductive chains form a linear collection (all pairwise comparable).
theorem smallest_inductive_chains_is_linear_chains[P: Partial_Order] {
    is_linear_chains(smallest_inductive_chains[P])
} by {
    forall(c1: Set[P], c2: Set[P]) {
        if c1 ∈ smallest_inductive_chains[P] and c2 ∈ smallest_inductive_chains[P] {
            c1 ∈ comparable_chains[P]
            is_chain_comparable(c1, c2)
        } 
    }
}

/// Chosen maximal chain: union of all chains in smallest inductive collection.
let chosen_maximal_chain[P: Partial_Order] = union(smallest_inductive_chains[P])

/// Chosen maximal chain is a chain.
theorem chosen_maximal_chain_is_linear[P: Partial_Order] {
    is_chain(chosen_maximal_chain[P])
} 

/// Chosen maximal chain belongs to smallest inductive collection.
theorem chosen_maximal_chain_in_smallest_inductive_chains[P: Partial_Order] {
    chosen_maximal_chain[P] ∈ smallest_inductive_chains[P]
}

/// The chosen maximal chain is indeed maximal.
theorem chosen_maximal_chain_is_maximal[P: Partial_Order] {
    is_maximal_chain(chosen_maximal_chain[P])
} by {
    is_chain(chosen_maximal_chain[P])
    if not is_maximal_chain(chosen_maximal_chain[P]) {
        contains_suc(smallest_inductive_chains[P])

        chosen_maximal_chain[P] ∈ smallest_inductive_chains[P]

        suc(chosen_maximal_chain[P]) ∈ smallest_inductive_chains[P]

        suc(chosen_maximal_chain[P]) = chosen_maximal_chain[P] ∪ Set[P].singleton(chain_extend_fn(chosen_maximal_chain[P]))

        chain_extend_fn(chosen_maximal_chain[P]) ∉ chosen_maximal_chain[P]

        suc(chosen_maximal_chain[P]) ⊆ union(smallest_inductive_chains[P])

        suc(chosen_maximal_chain[P]) ⊆ chosen_maximal_chain[P]

        Set[P].singleton(chain_extend_fn(chosen_maximal_chain[P])) ⊆ chosen_maximal_chain[P]

        chain_extend_fn(chosen_maximal_chain[P]) ∈ chosen_maximal_chain[P]

        false
    }
}

// Zorn Lemma
theorem maximal_principle[P: Partial_Order] {
    exists(c: Set[P]) {
        is_maximal_chain(c)
    }
} 