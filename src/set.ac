from util import compose, id_map

/// Sets with elements of type `K` are defined as Boolean functions over `K`, in the form of named wrapper structure
structure Set[K] {
    /// ∈  
    /// True if the set has no elements.
    contains: K -> Bool
}

define constant_false[K](x: K) -> Bool {
    false
}

define constant_true[K](x: K) -> Bool {
    true
}

define negate_fn[K](f: K -> Bool) -> (K -> Bool) {
    function(x: K) {
        not f(x)
    }
}

theorem reflect_of_nagate_fn[K] (f: K -> Bool) {
    negate_fn[K](negate_fn[K](f)) = f
} by {
    forall(x: K) {
        negate_fn[K](negate_fn[K](f))(x) implies not not f(x)

        negate_fn[K](negate_fn[K](f))(x) = f(x)
    }
}

theorem dual_of_constant_bool_fn[K] {
    negate_fn(constant_false[K]) = constant_true[K]
}

define singleton_fn[K](x: K, y: K) -> Bool {
    x = y
}

attributes Set[K] {
    /// local empty of "type" K
    let empty_set = Set[K].new(constant_false[K])
    /// local universal of "type" K
    let universal_set = Set[K].new(constant_true[K])
    let singleton: K -> Set[K] = function(x: K) {
        Set[K].new(singleton_fn(x))
    }
    /// ∉
    define not_contains(self, x: K) -> Bool {
        not (self.contains(x))
    }

    define is_empty(self) -> Bool {
        forall(x: K) {
            not x ∈ self
        }
    }
    /// local completion of set in "type" K  
    /// a.c = { x: K | x ∉ a }
    define c(self) -> Set[K] {
        Set[K].new(self.not_contains)
    }

    /// True if the set contains exactly one element.
    define is_singleton(self) -> Bool {
        exists(x: K) {
            self = Set[K].singleton(x)
        }
    }
}

let empty[K] = Set[K].empty_set
let universe[K] = Set[K].universal_set

theorem empty_is_not_universal[K] {
    empty[K] != universe[K]
} by {
    let x: K satisfy { true }
    constant_false(x) = false
    constant_true(x) = true
}

theorem empty_set_is_empty[K](a: Set[K]) {
    (a = empty[K]) iff (a.is_empty)
} by {
    (a.is_empty) implies (a.contains = constant_false[K])

    if (a.is_empty) {
        a = empty[K]
    } // "=" or "iff" is not good enough in bool now
}

define is_nonempty[K](s: Set[K]) -> Bool {
    exists(x: K) {
        x ∈ s
    }
}

theorem is_nonempty_iff_is_not_empty_set[K](s: Set[K]) {
    is_nonempty(s) iff s != Set[K].empty_set
} by {
    is_nonempty(s) implies s != Set[K].empty_set
}

theorem singleton_set_is_singleton[K](a: Set[K]) {
    forall(x: K) { Set[K].singleton(x).is_singleton }

    and 

    (a.is_singleton) implies exists(x: K) {a = Set[K].singleton(x)}
}

theorem non_contains_is_negate_contains[K] (a: Set[K]) {
    a.not_contains = negate_fn[K](a.contains)
} by {
    forall(x: K) {
        not a.contains(x) = a.not_contains(x) 

        not a.contains(x) = negate_fn[K](a.contains)(x)

        a.not_contains(x) implies negate_fn[K](a.contains)(x) // "=" or "iff" is not good enough in bool now

        a.not_contains(x) iff negate_fn[K](a.contains)(x)
    }
}

theorem not_contains_is_not_in[K](a: Set[K], x: K) {
    (x ∉ a) iff (not x ∈ a)
} 

theorem element_not_in_is_element_in_compl[K](a: Set[K], x: K) {
    (x ∉ a) iff (x ∈ a.c)
} 

theorem compl_contains_is_non_contains[K](a: Set[K]) {
    a.c.contains = a.not_contains
} 

theorem compl_is_reflect[K](a: Set[K]) {
    a.c.c = a
} by {
    forall(x: K) {
        (x ∈ a.c.c) implies not (not (x ∈ a))

        (x ∈ a.c.c) iff (x ∈ a)
    }
    a.c.c.contains = a.contains
}

theorem compl_is_reflect_by_fn[K] {
    compose(Set[K].c, Set[K].c) = id_map[Set[K]]
} by {
    forall(s: Set[K]) {
        compose(Set[K].c, Set[K].c)(s) = s.c.c
        compose(Set[K].c, Set[K].c)(s) = id_map(s)
    }
}

theorem dual_of_empty_set_and_universal[K] {
    empty[K].c = universe[K]
    and 
    universe[K].c = empty[K]
} by {
    empty[K].c.contains = universe[K].contains

    empty[K].c = universe[K] // redundant
}

theorem singleton_set_is_not_empty[K](a: K) {
    not (Set[K].singleton(a)).is_empty
} 

attributes Set[K] {
    /// a ⊆ b
    let subset_eq = function(a: Set[K], b: Set[K]) {
        forall(x: K) {
            x ∈ a implies x ∈ b
        }
    }
    /// a ⊇ b
    let superset_eq = function(a: Set[K], b: Set[K]) {
        forall(x: K) {
            x ∈ b implies x ∈ a
        }
    }

    define subset(self, other: Set[K]) -> Bool {
        self ⊆ other and self != other
    }
}

theorem sym_of_subset_and_supset[K](a: Set[K], b: Set[K]) {
    (a ⊆ b) iff (b ⊇ a)
} by {
    (a ⊆ b) implies (b ⊇ a)
}

theorem empty_set_is_always_subset[K](a: Set[K]) {
    empty[K] ⊆ a
    // by "Vacuous Truth"
    // something like: if the condition in the "if" control flow is flase, then skip the execution block, without error
}

theorem all_sets_subset_universal[K](a: Set[K]) {
    a ⊆ universe[K]
}

theorem subset_self[K](a: Set[K]) {
    a ⊆ a
}

theorem subset_trans[K](a1: Set[K], a2: Set[K], a3: Set[K]) {
    (a1 ⊆ a2 and a2 ⊆ a3) implies a1 ⊆ a3
}

theorem subset_and_supset_iff_equal[K](a1: Set[K], a2: Set[K]) {
    (a1 = a2) iff (a1 ⊆ a2 and a1 ⊇ a2)
} by {
    if (a1 ⊆ a2 and a1 ⊇ a2) {
        forall(x: K) {
            x ∈ a1 implies x ∈ a2
            x ∈ a2 implies x ∈ a1
            (x ∈ a1) iff (x ∈ a2)
        }
        a1.contains = a2.contains
        a1 = a2
    }

    (a1 = a2) implies (a1 ⊆ a2)
    (a1 = a2) implies (a2 ⊆ a1)
}

define set_eq_prop[K](a: Set[K], b: Set[K]) -> Bool {
    forall(x: K) {
        ((x ∈ a) implies (x ∈ b)) 
        and 
        ((x ∈ b) implies (x ∈ a))
    }
}

theorem set_equal_representation[K](a: Set[K], b: Set[K]) {
    (a = b) iff set_eq_prop(a, b)
} by {
    (a = b) implies set_eq_prop(a, b)
    
    set_eq_prop(a, b) implies (a ⊆ b)

    set_eq_prop(a, b) implies (a ⊇ b)
}

define elem_in_union[K](a1: Set[K], a2: Set[K], x: K) -> Bool {
    x ∈ a1 or x ∈ a2
}

define elem_in_intersection[K](a1: Set[K], a2: Set[K], x: K) -> Bool {
    x ∈ a1 and x ∈ a2
}

define elem_in_difference[K](a: Set[K], b: Set[K], x: K) -> Bool {
    x ∈ a and not x ∈ b
}

attributes Set[K] {
    /// a1 ∪ a2
    let union = function(a: Set[K], b: Set[K]) {
    Set[K].new(elem_in_union(a, b))
    }
    /// a1 ∩ a2
    let intersection = function(a: Set[K], b: Set[K]) {
        Set[K].new(elem_in_intersection(a, b))
    }
    /// a \ b  
    /// in Typst it's "without". In LaTeX it's "setminus"
    let difference = function(a: Set[K], b: Set[K]) {
        Set[K].new(elem_in_difference(a, b))
    }
}

theorem in_union[K](a1: Set[K], a2: Set[K], x: K) {
    (x ∈ (a1 ∪ a2)) iff (x ∈ a1 or x ∈ a2)
} by {
    (x ∈ (a1 ∪ a2)) implies (x ∈ a1 or x ∈ a2) // redundant?

    (x ∈ a1 or x ∈ a2) implies (x ∈ (a1 ∪ a2))
}

theorem in_intersection[K](a1: Set[K], a2: Set[K], x: K) {
    x ∈ (a1 ∩ a2) = (x ∈ a1 and x ∈ a2)
    // parentheses required?
} by {
    x ∈ (a1 ∩ a2) implies (x ∈ a1 and x ∈ a2)
}

theorem compl_separate[K](a: Set[K]) {
    a ∩ a.c = empty[K]
}

theorem difference_is_intersection_with_compl[K](a: Set[K], b: Set[K]) {
    (a ∖ b) = (a ∩ b.c)
} by {
    forall(x: K) {
        (x ∈ (a ∖ b)) implies (x ∈ a) and (x ∉ b) 

        (x ∈ (a ∖ b)) implies (x ∈ (a ∩ b.c))

        (x ∈ (a ∖ b)) iff (x ∈ (a ∩ b.c))
    }
}

theorem union_comm[K](a1: Set[K], a2: Set[K]) {
    (a1 ∪ a2) = (a2 ∪ a1)
    // by the comm of logic operator `or`
} by {
    forall(x: K) {
        elem_in_union(a1, a2, x) implies elem_in_union(a2, a1, x)
        
        elem_in_union(a1, a2, x) = elem_in_union(a2, a1, x)
    }

    elem_in_union(a1, a2) = elem_in_union(a2, a1)
}

theorem intersection_comm[K](a1: Set[K], a2: Set[K]) {
    a1 ∩ a2 = a2 ∩ a1
} by {
    forall(x: K) {
        elem_in_intersection(a1, a2, x) implies elem_in_intersection(a2, a1, x)
        
        elem_in_intersection(a1, a2, x) = elem_in_intersection(a2, a1, x)
    }

    elem_in_intersection(a1, a2) = elem_in_intersection(a2, a1)
}

theorem union_intersection_compl_dual[K](a1: Set[K], a2: Set[K]) {
    (a1 ∪ a2).c = (a1.c ∩ a2.c)
    // by the De Morgan law of logic operator `and`, `or`
} by {
    forall(x: K) {
        x ∉ (a1 ∪ a2) implies ((x ∉ a1) and (x ∉ a2))

        x ∈ (a1 ∪ a2).c implies (x ∈ a1.c ∩ a2.c)

        x ∈ (a1 ∪ a2).c = (x ∈ a1.c ∩ a2.c)
    }
}

theorem set_in_union[K](a1: Set[K], a2: Set[K]) {
    a1 ⊆ a1 ∪ a2 and a2 ⊆ a1 ∪ a2
} by {
    a1 ⊆ a1 ∪ a2
    a2 ⊆ a1 ∪ a2
}

theorem subset_union_is_subset[K](sub_1: Set[K], sub_2: Set[K], a: Set[K]) {
    (sub_1 ⊆ a and sub_2 ⊆ a) implies ((sub_1 ∪ sub_2) ⊆ a)
}

theorem set_contains_intersection[K](a1: Set[K], a2: Set[K]) {
    a1 ∩ a2 ⊆ a1 and a1 ∩ a2 ⊆ a2
} by {
    a1 ∩ a2 ⊆ a1
    a1 ∩ a2 ⊆ a2
}

theorem supset_intersection_is_supset[K](sup_1: Set[K], sup_2: Set[K], a: Set[K]) {
    (sup_1 ⊇ a and sup_2 ⊇ a) implies ((sup_1 ∩ sup_2) ⊇ a)
}

define sym_difference[K](a: Set[K], b: Set[K]) -> Set[K] {
    (a ∖ b) ∪ (b ∖ a) 
}

theorem sym_difference_another_rep[K](a: Set[K], b: Set[K]) {
    (a ∖ b) ∪ (b ∖ a) = (a ∪ b) ∖ (a ∩ b) 
} by {
    // =>
    (a ∖ b) ⊆ (a ∪ b)
    (b ∖ a) ⊆ (a ∪ b)

    (a ∖ b) ⊆ b.c
    (a ∖ b) ⊆ a.c ∪ b.c

    (a ∖ b) ⊆ (a ∩ b).c
    (b ∖ a) ⊆ (a ∩ b).c 

    (a ∖ b) ∪ (b ∖ a) ⊆ (a ∪ b) ∩ (a ∩ b).c
    // <=
    forall(x: K) {
        if (x ∈ a) {
            x ∈ (a ∪ b) ∖ (a ∩ b) implies x ∈ (a ∖ b) ∪ (b ∖ a)
        }
        x ∈ (a ∪ b) ∖ (a ∩ b) implies x ∈ (a ∖ b) ∪ (b ∖ a)
    }

    (a ∪ b) ∖ (a ∩ b) ⊆ (a ∖ b) ∪ (b ∖ a)
}

theorem union_preserve_subset[K](a1: Set[K], a2: Set[K], b1: Set[K], b2: Set[K]) {
    a1 ⊆ b1 and a2 ⊆ b2 implies a1 ∪ a2 ⊆ b1 ∪ b2
}

theorem intersect_preserve_subset[K](a1: Set[K], a2: Set[K], b1: Set[K], b2: Set[K]) {
    a1 ⊆ b1 and a2 ⊆ b2 implies a1 ∩ a2 ⊆ b1 ∩ b2
}

theorem not_subset_iff_contains_compl[K](a: Set[K], b: Set[K]) {
    not a ⊆ b iff a ∩ b.c != empty[K] 
} by {
    not a ⊆ b implies a ∩ b.c != empty[K] 
}

theorem not_subset_iff_contains_diff[K](a: Set[K], b: Set[K]) {
    not a ⊆ b iff a ∖ b != empty[K] 
} by {
    a ∖ b = a ∩ b.c
    not a ⊆ b implies a ∖ b != empty[K]
}

theorem union_associative[K](a1: Set[K], a2: Set[K], a3: Set[K]) {
    (a1 ∪ a2) ∪ a3 = a1 ∪ (a2 ∪ a3)
    // by assoc if logic `or`
} by {
    let u1 = (a1 ∪ a2) ∪ a3
    let u2 = a1 ∪ (a2 ∪ a3)

    a1 ⊆ u1
    a2 ⊆ u1
    a3 ⊆ u1

    u2 ⊆ u1

    a1 ⊆ u2
    a2 ⊆ u2
    a3 ⊆ u2

    u1 ⊆ u2 
}

theorem intersection_associative[K](a1: Set[K], a2: Set[K], a3: Set[K]) {
    (a1 ∩ a2) ∩ a3 = a1 ∩ (a2 ∩ a3)
} by {
    // dual of ∪ and ∩, to simplify writing proof
    ((a1.c ∪ a2.c) ∪ a3.c).c = (a1.c ∪ (a2.c ∪ a3.c)).c
}

theorem union_idemp[K](a: Set[K]) {
    a ∪ a = a
}

theorem intersection_idemp[K](a: Set[K]) {
    a ∩ a = a
}

theorem union_subset_is_self[K](sub: Set[K], a: Set[K]) {
    sub ⊆ a implies sub ∪ a = a
}

theorem intersection_subset_is_self[K](sup: Set[K], a: Set[K]) {
    sup ⊇ a implies sup ∩ a = a
}

theorem union_empty_is_self[K](a: Set[K]) {
    a ∪ empty[K] = a
}

theorem union_universal_is_universal[K](a: Set[K]) {
    a ∪ universe[K] = universe[K]
}

theorem intersection_universal_is_self[K](a: Set[K]) {
    a ∩ universe[K] = a
}

theorem intersection_empty_is_empty[K](s: Set[K]) {
    s ∩ empty[K] = empty[K]
}

theorem decomposition_of_universe[K](a: Set[K], b: Set[K]) {
    a ∩ b = empty[K] and a ∪ b = universe[K] implies a = b.c
}

theorem decomposition_of_universe_imp_rev[K](a: Set[K], b: Set[K]) {
    a ∪ a.c = universe[K]
}

theorem bool_distributive(x1: Bool, x2: Bool, y: Bool) {
    ((x1 or x2) and y) = ((x1 and y) or (x2 and y))
    // parentheses is necessary
}

theorem bool_distributive_dual(x1: Bool, x2: Bool, y: Bool) {
    ((x1 and x2) or y) = ((x1 or y) and (x2 or y)) 
} // if put together "bool_distributive" and "bool_distributive_dual" with `and`, search fail

theorem union_intersection_distributive[K](a1: Set[K], a2: Set[K], b: Set[K]) {
    ((a1 ∪ a2) ∩ b) = ((a1 ∩ b) ∪ (a2 ∩ b))
} 
by {
    // ⊇
    a1 ∪ a2 ⊇ a1
    a1 ∪ a2 ⊇ a2
    ((a1 ∪ a2) ∩ b) ⊇ (a1 ∩ b) 
    ((a1 ∪ a2) ∩ b) ⊇ (a2 ∩ b) 
    ((a1 ∪ a2) ∩ b) ⊇ ((a1 ∩ b) ∪ (a2 ∩ b))

    // ⊆
    forall(x: K) {
        if x ∈ (a1 ∪ a2) ∩ b {
            (x ∈ a1 or x ∈ a2) and x ∈ b
            (x ∈ a1 and x ∈ b) or (x ∈ a2 and x ∈ b)
            (x ∈ a1 ∩ b) or (x ∈ a2 ∩ b)
            x ∈ (a1 ∩ b) ∪ (a2 ∩ b)
        }
    }

    ((a1 ∪ a2) ∩ b) ⊆ ((a1 ∩ b) ∪ (a2 ∩ b))
}

theorem union_intersection_distributive_dual[K](a1: Set[K], a2: Set[K], b: Set[K]) {
    ((a1 ∩ a2) ∪ b) = ((a1 ∪ b) ∩ (a2 ∪ b))
} by {
    ((a1.c ∪ a2.c) ∩ b.c).c = ((a1.c ∩ b.c) ∪ (a2.c ∩ b.c)).c
}

define or_index[I, K] (f: I -> Set[K], x: K) -> Bool {
    exists(i: I) {
        x ∈ f(i)
    }
}

define and_index[I, K] (f: I -> Set[K], x: K) -> Bool {
    forall(i: I) {
        x ∈ f(i)
    }
}

define union_index[I, K](f: I -> Set[K]) -> Set[K] {
    Set[K].new(or_index(f))
}

define intersection_index[I, K](f: I -> Set[K]) -> Set[K] {
    Set[K].new(and_index(f))
}

define index_compl[I, K](f: I -> Set[K]) -> (I -> Set[K]) {function(i: I) {f(i).c}}

theorem union_intersection_index_compl_dual[I, K](f: I -> Set[K]) {
    union_index(f).c = intersection_index(index_compl(f))
} by {
    forall(x: K) {
        // ⊆

        // by logic dual: forall(x: K) p(x) <=> exists(x: K) not p(x)
        x ∉ union_index(f) implies (
            forall(i: I) {
                x ∉ f(i)
            }
        )
        // by x ∉ a <=> x ∈ a.c
        x ∈ union_index(f).c implies x ∈ intersection_index(index_compl(f))

        // ⊇

        (
            forall(i: I) {
                x ∉ f(i)
            }
        ) implies x ∉ union_index(f)

        x ∈ intersection_index(index_compl[I, K](f)) implies x ∈ union_index(f).c

        x ∈ union_index(f).c iff x ∈ intersection_index(index_compl[I, K](f))
    }
}

// Proving indexed union and intersection definitions are consistent
// with index definitions

/// A type with exactly two values.
inductive Two {
    first
    second
}

theorem test_two(x: Two) {
    if (x = Two.first) {
        x != Two.second
    }
}

// Creates a function f: Two -> Set[K]
define fn_two[K](a1: Set[K], a2: Set[K], x: Two) -> Set[K] {
    match x {
        Two.first {
            a1
        }
        Two.second {
            a2
        }
    }
}

// Defines union in the case of two sets using index definition
define union_index_of_two[K](a1: Set[K], a2: Set[K]) -> Set[K] {
    union_index(fn_two(a1, a2))
} 

theorem union_is_union_index_of_two[K](a1: Set[K], a2: Set[K]) {
    a1 ∪ a2 = union_index_of_two(a1, a2)
} by {
    forall(x: K) {
        x ∈ a1 implies (
            exists(i: Two) {
                x ∈ fn_two(a1, a2, i)
            }
        )

        x ∈ a2 implies (
            exists(i: Two) {
                x ∈ fn_two(a1, a2, i)
            }
        )

        if (
            exists(i: Two) {
                x ∈ fn_two(a1, a2, i)
            }
        ) {
            Set[K].new(or_index(fn_two(a1, a2))).contains(x)
            x ∈ union_index_of_two(a1, a2)
        } 

        (x ∈ a1 ∪ a2) implies (x ∈ union_index_of_two(a1, a2))

        if x ∈ union_index_of_two(a1, a2) {
            Set[K].new(or_index(fn_two(a1, a2))).contains(x)
            (
                exists(i: Two) {
                x ∈ fn_two(a1, a2, i)
            }
            )
            x ∈ a1 or x ∈ a2
        }

        (x ∈ union_index_of_two(a1, a2)) implies x ∈ a1 or x ∈ a2

        (x ∈ a1 ∪ a2) = (x ∈ union_index_of_two(a1, a2))
    }
}

define intersection_index_of_two[K](a1: Set[K], a2: Set[K]) -> Set[K] {
    intersection_index(fn_two(a1, a2))
} 

theorem intersection_is_intersection_index_of_two[K](a1: Set[K], a2: Set[K]) {
    a1 ∩ a2 = intersection_index_of_two(a1, a2)
} by {
    forall(x: K) {
        (
            forall(i: Two) {
                x ∈ fn_two(a1, a2, i)
            }
        ) implies x ∈ a1

        (
            forall(i: Two) {
                x ∈ fn_two(a1, a2, i)
            }
        ) implies x ∈ a2

        (x ∈ intersection_index_of_two(a1, a2)) implies (x ∈ a1 and x ∈ a2) 

        (x ∈ a1 and x ∈ a2) implies (
            forall(i: Two) {
                x ∈ fn_two(a1, a2, i)
            }
        )

        (x ∈ a1 and x ∈ a2) implies (x ∈ intersection_index_of_two(a1, a2)) 

        (x ∈ a1 ∩ a2) implies (x ∈ intersection_index_of_two(a1, a2))

        (x ∈ a1 ∩ a2) = (x ∈ intersection_index_of_two(a1, a2))
    }
}

inductive Sum[K1, K2] {
    first(K1)
    second(K2)
}

define elem_in_sum[K1, K2](a1: Set[K1], a2: Set[K2], p: Sum[K1, K2]) -> Bool {
    match p {
        Sum[K1, K2].first(x1) {
            x1 ∈ a1
        }
        Sum[K1, K2].second(x2) {
            x2 ∈ a2
        }
    }
}

attributes Set[K1] {
    define add[K2](self, a: Set[K2]) -> Set[Sum[K1,K2]] {
        Set[Sum[K1,K2]].new(elem_in_sum(self, a))
    }
}

theorem add_test[K1, K2](a1: Set[K1], a2: Set[K2]) {
    a1 + a2 ⊆ Set[Sum[K1, K2]].universal_set
}

structure Product[K1, K2] {
    first: K1
    second: K2
}

define elem_in_product[K1,K2](a1: Set[K1], a2: Set[K2], p: Product[K1,K2]) -> Bool {
    p.first ∈ a1 and p.second ∈ a2
}

attributes Set[K1] {
    define product[K2](self, a: Set[K2]) -> Set[Product[K1,K2]] {
        Set[Product[K1,K2]].new(elem_in_product(self, a))
    }
}

theorem product_test[K1, K2](a1: Set[K1], a2: Set[K2]) {
    a1.product(a2) ⊆ Set[Product[K1, K2]].universal_set
}

define elem_in_product_index[I, K](f: I -> Set[K], x: I -> K) -> Bool {
    forall(i: I) {
        x(i) ∈ f(i)
    }
}

define elem_in_sum_index[I, K](f: I -> Set[K], x: Product[I, K]) -> Bool {
    exists(i: I) {
        x.first = i and x.second ∈ f(i)
    }
}

define product_index[I, K](f: I -> Set[K]) -> Set[I -> K] {
    Set[I -> K].new(elem_in_product_index(f))
}

define sum_index[I, K](f: I -> Set[K]) -> Set[Product[I, K]] {
    Set[Product[I, K]].new(elem_in_sum_index(f))
}

define elem_in_union_general[K](c: Set[Set[K]], x: K) -> Bool {
    exists(s: Set[K]) {
        s ∈ c and x ∈ s
    }
}

define union[K](c: Set[Set[K]]) -> Set[K] {
    Set[K].new(elem_in_union_general(c))
}

theorem subset_union_general_is_subset[K](c: Set[Set[K]], a: Set[K]) {
    forall(s: Set[K]) {
        s ∈ c implies s ⊆ a
    } implies union(c) ⊆ a
} by {
    forall(x: K) {
        if x ∈ union(c) {
            let s: Set[K] satisfy {
                s ∈ c and x ∈ s
            }
            s ⊆ a
            x ∈ a
        }
    }
    union(c) ⊆ a
}

theorem sets_subset_imp_union_subset[K](c1: Set[Set[K]], c2: Set[Set[K]]) {
    c1 ⊆ c2 implies union(c1) ⊆ union(c2)
} by {
    forall(x: K) {
        if x ∈ union(c1) {
            let s: Set[K] satisfy {
                s ∈ c1 and x ∈ s
            }
            s ∈ c2
            x ∈ union(c2)
        }
    }
}

theorem union_subset[K](c: Set[Set[K]], s: Set[K]) {
    s ∈ c implies s ⊆ union(c)
}

theorem superset_union[K](c: Set[Set[K]], s: Set[K]) {
    forall(t: Set[K]) {
        t ∈ c implies s ⊇ t
    } implies s ⊇ union(c)
}

define elem_in_intersection_general[K](c: Set[Set[K]], x: K) -> Bool {
    forall(s: Set[K]) {
        s ∈ c implies x ∈ s
    }
}

define intersection[K](c: Set[Set[K]]) -> Set[K] {
    Set[K].new(elem_in_intersection_general(c))
}

theorem sets_subset_imp_intersection_superset[K](c1: Set[Set[K]], c2: Set[Set[K]]) {
    c1 ⊆ c2 implies intersection(c1) ⊇ intersection(c2)
} by {
    forall(x: K) {
        if x ∈ intersection(c2) {
            forall(s: Set[K]) {
                if s ∈ c1 {
                    s ∈ c2
                    x ∈ s
                }
            }
            x ∈ intersection(c1)
        }
    }
}

theorem intersection_superset[K](c: Set[Set[K]], s: Set[K]) {
    s ∈ c implies s ⊇ intersection(c)
}

theorem subset_intersection[K](c: Set[Set[K]], s: Set[K]) {
    forall(t: Set[K]) {
        t ∈ c implies s ⊆ t
    } implies s ⊆ intersection(c)
} by {
    forall(x: K) {
        x ∈ s implies x ∈ intersection(c)
    }
}

theorem empty_intersection_is_universe[K] {
    intersection(Set[Set[K]].empty_set) = Set[K].universal_set
} by {
    forall(x: K) {
        x ∈ Set[K].universal_set
        forall(s: Set[K]) {
            if s ∈ Set[Set[K]].empty_set {
                if not x ∈ s {
                    false
                }
                x ∈ s
            }
            s ∈ Set[Set[K]].empty_set implies x ∈ s
        }
        x ∈ intersection(Set[Set[K]].empty_set)
    }
    intersection(Set[Set[K]].empty_set).contains = Set[K].universal_set.contains
}

define elem_in_compl_of_sets[K](sets: Set[Set[K]], s: Set[K]) -> Bool {
    s.c ∈ sets
}

define compl_of_sets[K](sets: Set[Set[K]]) -> Set[Set[K]] {
    Set[Set[K]].new(elem_in_compl_of_sets(sets))
}

theorem compl_of_sets_reflect[K](sets: Set[Set[K]]) {
    compl_of_sets(compl_of_sets(sets)) = sets
} by {
    forall(s: Set[K]) {
        if s ∈ sets {
            s.c ∈ compl_of_sets(sets)
            s ∈ compl_of_sets(compl_of_sets(sets))
            sets.contains(s) = compl_of_sets(compl_of_sets(sets)).contains(s)
        } else {
            not s ∈ sets
            not s.c ∈ compl_of_sets(sets)
            not s ∈ compl_of_sets(compl_of_sets(sets))
            sets.contains(s) = compl_of_sets(compl_of_sets(sets)).contains(s)
        }
        sets.contains(s) = compl_of_sets(compl_of_sets(sets)).contains(s)
    }
    sets.contains = compl_of_sets(compl_of_sets(sets)).contains
}

theorem union_intersection_compl_dual_general[K](sets: Set[Set[K]]) {
    union(sets).c = intersection(compl_of_sets(sets))
} by {
    forall(x: K) {
        if x ∈ union(sets).c {
            x ∉ union(sets)
            forall(s: Set[K]) {
                if s ∈ compl_of_sets(sets) {
                    s.c ∈ sets
                    x ∉ s.c
                    x ∈ s
                }
            }
            x ∈ intersection(compl_of_sets(sets))
        }
    }
    union(sets).c ⊆ intersection(compl_of_sets(sets))
    forall(x: K) {
        if x ∈ intersection(compl_of_sets(sets)) {
            forall(s: Set[K]) {
                if s ∈ sets {
                    s.c ∈ compl_of_sets(sets)
                    x ∈ s.c
                    x ∉ s
                }
            }
            x ∉ union(sets)
            x ∈ union(sets).c          
        }
    }
    union(sets).c ⊇ intersection(compl_of_sets(sets))
}

theorem empty_union_is_empty[K] {
    union(Set[Set[K]].empty_set) = Set[K].empty_set
}

define intersection_with_one[K](c: Set[Set[K]], s: Set[K]) -> Set[K] {
    Set[K].new(
        function(x: K) {
            forall(t: Set[K]) {
                t ∈ c implies x ∈ s ∩ t
            }
        }
    )
}

theorem intersection_comm_one[K](c: Set[Set[K]], s: Set[K]) {
    is_nonempty(c) implies intersection_with_one(c, s) = s ∩ intersection(c)
} by {
    forall(x: K) {
        if x ∈ intersection_with_one(c, s) {
            let u: Set[K] satisfy { u ∈ c }
            x ∈ s ∩ u
            x ∈ s
            forall(t: Set[K]) {
                if t ∈ c {
                    x ∈ s ∩ t
                    x ∈ t
                }
            }
            x ∈ intersection(c)
            x ∈ s and x ∈ intersection(c)
        }
    }
    intersection_with_one(c, s) ⊆ s ∩ intersection(c)

    forall(x: K) {
        if x ∈ s ∩ intersection(c) {
            forall(t: Set[K]) {
                if t ∈ c {
                    x ∈ s
                    x ∈ t
                    x ∈ s ∩ t
                }
            }
            x ∈ intersection_with_one(c, s)
        }
    }
    intersection_with_one(c, s) ⊇ s ∩ intersection(c)    
}

// todo: (product/sum)_index_of_two
structure Map[K, L] {
    in_space: Set[K]
    out_space: Set[L]
    fn: K -> L
} constraint {
    forall(x: K) {
        x ∈ in_space implies fn(x) ∈ out_space
    }
}

attributes Map[K, L] {
    define restrict(self, a: Set[K]) -> Map[K, L] {
        if a ⊆ self.in_space {
            Map.new(a, self.out_space, self.fn)
        } else {
            self
        }
    }
}

// maybe we sometime want to use f: a --> b instead of m: Map[K, L] ... is this possible?
define elem_in_map[K, L](in_space: Set[K], out_space: Set[L], fn: K -> L) -> Bool {
    forall(x: K) {
        x ∈ in_space implies fn(x) ∈ out_space
    }
}

define map[K, L](in_space: Set[K], out_space: Set[L]) -> Set[K -> L] {
    Set[K -> L].new(elem_in_map(in_space, out_space))
}

/// the set theory version of union_index
define elem_in_union_index_map[I, K](m: Map[I, Set[K]], x: K) -> Bool {
    exists(i: I) {
        i ∈ m.in_space and x ∈ m.fn(i)
    }
}

/// the set theory version of union_index
define union_index_map[I, K](m: Map[I, Set[K]]) -> Set[K] {
    Set[K].new(elem_in_union_index_map(m))
}

/// the set theory version of intersection_index
define elem_in_intersection_index_map[I, K](m: Map[I, Set[K]], x: K) -> Bool {
    forall(i: I) {
        i ∈ m.in_space implies x ∈ m.fn(i)
    }
}

/// the set theory version of intersection_index
define intersection_index_map[I, K](m: Map[I, Set[K]]) -> Set[K] {
    Set[K].new(elem_in_intersection_index_map(m))
}

/// the set theory version of product_index
define elem_in_product_index_map[I, K](m: Map[I, Set[K]], x: I -> K) -> Bool {
    forall(i: I) {
        i ∈ m.in_space implies x(i) ∈ m.fn(i)
    }
}

/// the set theory version of product_index
define product_index_map[I, K](m: Map[I, Set[K]]) -> Set[I -> K] {
    Set[I -> K].new(elem_in_product_index_map(m))
}

// todo: set theory version of sum_index

attributes Map[K, L] {
    define is_injective(self) -> Bool {
        forall(x1: K, x2: K) {
            x1 ∈ self.in_space and 
            x2 ∈ self.in_space implies (
                self.fn(x1) = self.fn(x2) implies x1 = x2
            ) 
        }
    }

    define is_surjective(self) -> Bool {
        forall(y: L) {
            y ∈ self.out_space implies exists(x: K) {
                x ∈ self.in_space and self.fn(x) = y
            }
        }
    }

    define is_bijective(self) -> Bool {
        self.is_injective and self.is_surjective
    }
}

define cardinal_lte[K, L](a: Set[K], b: Set[L]) -> Bool {
    exists(m: Map[K, L]) {
        m.in_space = a and
        m.out_space = b and
        m.is_injective 
    }
}

define cardinal_gte[K, L](a: Set[K], b: Set[L]) -> Bool {
    exists(m: Map[K, L]) {
        m.in_space = a and
        m.out_space = b and
        m.is_surjective 
    }
}

define cardinal_eq[K, L](a: Set[K], b: Set[L]) -> Bool {
    exists(m: Map[K, L]) {
        m.in_space = a and
        m.out_space = b and
        m.is_bijective 
    }
}

define power_set[K](a: Set[K]) -> Set[Set[K]] {
    Set[Set[K]].new(a.superset_eq)
}

define is_injective[K, L](f: K -> L) -> Bool {
    forall(x1: K, x2: K) { f(x1) = f(x2) implies x1 = x2 }  
}

define is_surjective[K, L](f: K -> L) -> Bool {
    forall(y: L) { exists(x: K) { f(x) = y } } 
}

define is_bijective[K, L](f: K -> L) -> Bool {
    is_injective(f) and is_surjective(f) 
}

theorem cardinal_lt_power[K](f: K -> Set[K]) {
    not is_surjective(f)
} by {
    define p(g: K -> Set[K], x: K) -> Bool {
        not g(x).contains(x)
    }

    let omega = Set[K].new(p(f))
    
    forall(x: K) {
        if omega.contains(x) { 
            not f(x).contains(x)
            omega != f(x)
        }
    }
}

define elem_in_image_of_function[K, L](a: Set[K], f: K -> L, y: L) -> Bool {
    exists(x: K) {
        x ∈ a and y = f(x)
    }
}

define elem_in_inv_image_of_function[K, L](b: Set[L], f: K -> L, x: K) -> Bool {
    exists(y: L) {
        y ∈ b and y = f(x)
    }
}

attributes Set[K] {
    define image[L](self, f: K -> L) -> Set[L] {
        Set[L].new(elem_in_image_of_function(self, f))
    }

    define inv_image[L](self, f: L -> K) -> Set[L] {
        Set[L].new(elem_in_inv_image_of_function(self, f))
    }
}

theorem point_image_is_image[K, L](a: Set[K], f: K -> L) {
    forall(x: K) {
        x ∈ a implies f(x) ∈ a.image(f)
    }
}

theorem point_description_of_image_subset_imp[K, L](a: Set[K], f: K -> L, b: Set[L]) {
    a.image(f) ⊆ b implies forall(x: K) {
        x ∈ a implies f(x) ∈ b
    }
} by {
    if a.image(f) ⊆ b {
        forall(x: K) {
            if x ∈ a {
                f(x) ∈ a.image(f)
                f(x) ∈ b
            }
        }
    }
}

theorem point_description_of_image_subset_imp_rev[K, L](a: Set[K], f: K -> L, b: Set[L]) {
    forall(x: K) {
        x ∈ a implies f(x) ∈ b
    } implies a.image(f) ⊆ b
} by {
    if forall(x: K) {
        x ∈ a implies f(x) ∈ b
    } {
        forall(y: L) {
            if y ∈ a.image(f) {
                let x: K satisfy { x ∈ a and y = f(x) }
                f(x) ∈ b
                y ∈ b
            }
        }
        a.image(f) ⊆ b
    }
}

theorem inv_image_description_of_image_subset[K, L](a: Set[K], f: K -> L, b: Set[L]) {
    a.image(f) ⊆ b iff a ⊆ b.inv_image(f)
} by {
    if a.image(f) ⊆ b {
        forall(x: K) {
            if x ∈ a {
                f(x) ∈ a.image(f)
                f(x) ∈ b
                x ∈ b.inv_image(f)
            }
        }
        a ⊆ b.inv_image(f)
    } 
    if a ⊆ b.inv_image(f) {
        forall(y: L) {
            if y ∈ a.image(f) {
                let x: K satisfy { x ∈ a and y = f(x) }
                x ∈ b.inv_image(f)
                f(x) ∈ b
                y ∈ b
            }
        }
        a.image(f) ⊆ b
    }
}

theorem inv_image_preserve_compl[K, L](b: Set[L], f: K -> L) {
    b.c.inv_image(f) = b.inv_image(f).c
} by {
    forall(x: K) {
        if x ∈ b.c.inv_image(f) {
            let y: L satisfy {
                y ∈ b.c and y = f(x)
            }
            if x ∈ b.inv_image(f) {
                f(x) ∈ b
                false
            }
            x ∈ b.inv_image(f).c
        }
    }

    b.c.inv_image(f) ⊆ b.inv_image(f).c

    forall(x: K) {
        if x ∈ b.inv_image(f).c {
            not x ∈ b.inv_image(f)
            forall(y: L) {
                not (y ∈ b and y = f(x))
                not f(x) ∈ b
            }
            f(x) ∈ b.c
            x ∈ b.c.inv_image(f)
        }
    }

    b.c.inv_image(f) ⊇ b.inv_image(f).c
}

theorem inv_image_preserve_intersection[K, L](a: Set[L], b: Set[L], f: K -> L) {
    (a ∩ b).inv_image(f) = a.inv_image(f) ∩ b.inv_image(f)
} by {
    forall(x: K) {
        if x ∈ (a ∩ b).inv_image(f) {
            f(x) ∈ a ∩ b
            f(x) ∈ a and f(x) ∈ b
            x ∈ a.inv_image(f)
            x ∈ b.inv_image(f)
            x ∈ a.inv_image(f) ∩ b.inv_image(f)
        }
    }

    (a ∩ b).inv_image(f) ⊆ a.inv_image(f) ∩ b.inv_image(f)

    forall(x: K) {
        if x ∈ a.inv_image(f) ∩ b.inv_image(f) {
            x ∈ a.inv_image(f) and x ∈ b.inv_image(f)
            f(x) ∈ a and f(x) ∈ b
            f(x) ∈ a ∩ b
            x ∈ (a ∩ b).inv_image(f)
        }
    }

    (a ∩ b).inv_image(f) ⊇ a.inv_image(f) ∩ b.inv_image(f)
}

theorem inv_image_preserve_union[K, L](a: Set[L], b: Set[L], f: K -> L) {
    (a ∩ b).inv_image(f) = a.inv_image(f) ∩ b.inv_image(f)
}

theorem image_of_inv_image_subset[K, L](f: K -> L, b: Set[L]) {
    b.inv_image(f).image(f) ⊆ b
} 

theorem image_preserve_subset[K, L](f: K -> L, a: Set[K], b: Set[K]) {
    a ⊆ b implies a.image(f) ⊆ b.image(f)
} 

theorem inv_image_preserve_subset[K, L](f: K -> L, a: Set[L], b: Set[L]) {
    a ⊆ b implies a.inv_image(f) ⊆ b.inv_image(f)
} 

theorem image_preserve_nomempty[K, L](f: K -> L, a: Set[K], b: Set[K]) {
    is_nonempty(a) implies is_nonempty(a.image(f))
} 

theorem in_singleton[K](x: K, y: K) {
    y ∈ Set[K].singleton(x) iff y = x
} by {
    y ∈ Set[K].singleton(x) implies y = x
}

theorem singleton_subset[K](a: Set[K], x: K) {
    Set[K].singleton(x) ⊆ a iff x ∈ a
} by {
    Set[K].singleton(x) ⊆ a implies x ∈ a
}

theorem subset_singleton[K](a: Set[K], x: K) {
    a ⊆ Set[K].singleton(x) implies (
        a = Set[K].singleton(x) or a = empty[K]
    )
} by {
    if a != empty[K] {
        let y: K satisfy { y ∈ a }
        y ∈ Set[K].singleton(x)
        y = x
        x ∈ a
        Set[K].singleton(x) ⊆ a
        a = Set[K].singleton(x)
    }
}

theorem subset_not_eq_singleton[K](a: Set[K], x: K) {
    a ⊂ Set[K].singleton(x) implies a = empty[K]
}

theorem subset_not_eq_by_contains[K](a: Set[K], b: Set[K]) {
    a ⊂ b implies exists(x: K) {
        x ∈ b and x ∉ a
    }
}

/// Creates a new function that returns true for the given item and delegates to the original function for all other inputs.  
/// i.e. add a true value to f: T -> Bool by change f(item) to true 
define functional_insert[T](f: T -> Bool, item: T, x: T) -> Bool {
    if x = item {
        true
    } else {
        f(x)
    }
}

/// Creates a new function that returns false for the given item and delegates to the original function for all other inputs.  
/// i.e. add a false value to f: T -> Bool by change f(item) to false 
define functional_remove[T](f: T -> Bool, item: T, x: T) -> Bool {
    if x = item {
        false
    } else {
        f(x)
    }
}

attributes Set[K] {
    define insert(self, item: K) -> Set[K] {
        Set[K].new(functional_insert(self.contains, item))
    }

    define remove(self, item: K) -> Set[K] {
        Set[K].new(functional_remove(self.contains, item))
    }
}

theorem insert_contains[T](a: Set[T], item: T) {
    item ∈ a.insert(item)
}

theorem remove_does_not_contain[T](a: Set[T], item: T) {
    not item ∈ a.remove(item)
}

theorem insert_other_contains_eq[T](a: Set[T], item: T, other: T) {
    item != other implies item ∈ a = item ∈ a.insert(other)
} by {
    if item ∈ a {
        item ∈ a iff item ∈ a.insert(other)
    } else {
        not item ∈ a
        not item ∈ a.insert(other)
        item ∈ a = item ∈ a.insert(other)
    }
}

theorem remove_other_contains_eq[T](a: Set[T], item: T, other: T) {
    item != other implies item ∈ a = item ∈ a.remove(other)
} by {
    if item ∈ a {
        item ∈ a iff item ∈ a.remove(other)
    } else {
        not item ∈ a
        not item ∈ a.remove(other)
        item ∈ a = item ∈ a.remove(other)
    }
}

theorem remove_then_insert[T](a: Set[T], item: T) {
    item ∈ a implies a.remove(item).insert(item) = a
} by {
    if a.remove(item).insert(item) != a {
        a.remove(item).insert(item).contains != a.contains
        let t: T satisfy {
            t ∈ a.remove(item).insert(item) != t ∈ a
        }
        if item != t {
            if t ∈ a {
                t ∈ a.remove(item)
                false
            } else {
                false
            }
        } else {
            item = t
            not t ∈ a
            false
        }
    }
}

theorem insert_then_remove[T](a: Set[T], item: T) {
    not item ∈ a implies a.insert(item).remove(item) = a
} by {
    if a.insert(item).remove(item) != a {
        a.insert(item).remove(item).contains != a.contains
        let t: T satisfy {
            t ∈ a.insert(item).remove(item) != t ∈ a
        }
        if item != t {
            if t ∈ a {
                false
            } else {
                t ∈ a.insert(item)
                false
            }
        } else {
            item = t
            not t ∈ a
            false
        }
    }
}