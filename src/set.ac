from util import compose, id_map, Inhabited

/// Sets with elements of type `K` are defined as Boolean functions over `K`, in the form of named wrapper structure
structure Set[K] {
    /// âˆˆ  
    /// True if the set has no elements.
    contains: K -> Bool
}

define constant_false[K](x: K) -> Bool {
    false
}

define constant_true[K](x: K) -> Bool {
    true
}

define negate_fn[K](f: K -> Bool) -> (K -> Bool) {
    function(x: K) {
        not f(x)
    }
}

/// The negation of negation returns the original function.
theorem reflect_of_nagate_fn[K] (f: K -> Bool) {
    negate_fn[K](negate_fn[K](f)) = f
} by {
    forall(x: K) {
        negate_fn[K](negate_fn[K](f))(x) implies not not f(x)

        negate_fn[K](negate_fn[K](f))(x) = f(x)
    }
}

/// Negating the constant false function yields constant true.
theorem dual_of_constant_bool_fn[K] {
    negate_fn(constant_false[K]) = constant_true[K]
}

define singleton_fn[K](x: K, y: K) -> Bool {
    x = y
}

attributes Set[K] {
    /// local empty of "type" K
    let empty_set = Set[K].new(constant_false[K])
    /// local universal of "type" K
    let universal_set = Set[K].new(constant_true[K])
    let singleton: K -> Set[K] = function(x: K) {
        Set[K].new(singleton_fn(x))
    }
    /// âˆ‰
    define not_contains(self, x: K) -> Bool {
        not (self.contains(x))
    }

    define is_empty(self) -> Bool {
        forall(x: K) {
            not x âˆˆ self
        }
    }
    define is_nonempty(self) -> Bool {
        exists(x: K) {
            x âˆˆ self
        }
    }
    define is_universal(self) -> Bool {
        forall(x: K) {
            x âˆˆ self
        }
    }
    /// local completion of set in "type" K  
    /// a.c = { x: K | x âˆ‰ a }
    define c(self) -> Set[K] {
        Set[K].new(self.not_contains)
    }

    /// True if the set contains exactly one element.
    define is_singleton(self) -> Bool {
        exists(x: K) {
            self = Set[K].singleton(x)
        }
    }
}

let empty[K] = Set[K].empty_set
let universe[K] = Set[K].universal_set

theorem empty_is_not_universal[K: Inhabited] {
    empty[K] != universe[K]
} by {
    let x: K satisfy { true }
    constant_false(x) = false
    constant_true(x) = true
}

/// A set equals the empty set iff it contains no elements.
theorem empty_set_is_empty[K](a: Set[K]) {
    (a = empty[K]) iff (a.is_empty)
} by {
    (a.is_empty) implies (a.contains = constant_false[K])

    if (a.is_empty) {
        a = empty[K]
    } // "=" or "iff" is not good enough in bool now
}

/// A set equals the universal set iff it contains all elements of type K.
theorem universal_set_is_universal[K](a: Set[K]) {
    (a = universe[K]) iff (a.is_universal)
} by {
    (a.is_universal) implies (a.contains = constant_true[K])

    if (a.is_universal) {
        a = universe[K]
    } // "=" or "iff" is not good enough in bool now
}

/// A set is nonempty iff it is not equal to the empty set.
theorem is_nonempty_iff_is_not_empty_set[K](s: Set[K]) {
    (s).is_nonempty iff s != Set[K].empty_set
} by {
    (s).is_nonempty implies s != Set[K].empty_set
}

/// Singleton sets have exactly one element, and any set with exactly one element is a singleton.
theorem singleton_set_is_singleton[K](a: Set[K]) {
    forall(x: K) { Set[K].singleton(x).is_singleton }

    and 

    (a.is_singleton) implies exists(x: K) {a = Set[K].singleton(x)}
}

/// The not_contains function is equivalent to the negation of contains.
theorem non_contains_is_negate_contains[K] (a: Set[K]) {
    a.not_contains = negate_fn[K](a.contains)
} by {
    forall(x: K) {
        not a.contains(x) = a.not_contains(x) 

        not a.contains(x) = negate_fn[K](a.contains)(x)

        a.not_contains(x) implies negate_fn[K](a.contains)(x) // "=" or "iff" is not good enough in bool now

        a.not_contains(x) iff negate_fn[K](a.contains)(x)
    }
}

/// Element not in set is logically equivalent to negation of element in set.
theorem not_contains_is_not_in[K](a: Set[K], x: K) {
    (x âˆ‰ a) iff (not x âˆˆ a)
} 

/// Element not in set iff element is in complement of set.
theorem element_not_in_is_element_in_compl[K](a: Set[K], x: K) {
    (x âˆ‰ a) iff (x âˆˆ a.c)
} 

/// The complement's contains function equals the set's not_contains function.
theorem compl_contains_is_non_contains[K](a: Set[K]) {
    a.c.contains = a.not_contains
} 

/// Taking complement twice returns original set.
theorem compl_is_reflect[K](a: Set[K]) {
    a.c.c = a
} by {
    forall(x: K) {
        (x âˆˆ a.c.c) implies not (not (x âˆˆ a))

        (x âˆˆ a.c.c) iff (x âˆˆ a)
    }
    a.c.c.contains = a.contains
}

/// Complement operation is involutive: applying complement twice is identity function.
theorem compl_is_reflect_by_fn[K] {
    compose(Set[K].c, Set[K].c) = id_map[Set[K]]
} by {
    forall(s: Set[K]) {
        compose(Set[K].c, Set[K].c)(s) = s.c.c
        compose(Set[K].c, Set[K].c)(s) = id_map(s)
    }
}

/// Complement of empty set is universal set, and complement of universal set is empty set.
theorem dual_of_empty_set_and_universal[K] {
    empty[K].c = universe[K]
    and 
    universe[K].c = empty[K]
} by {
    empty[K].c.contains = universe[K].contains

    empty[K].c = universe[K] // redundant
}

/// A singleton set is never empty.
theorem singleton_set_is_not_empty[K](a: K) {
    not (Set[K].singleton(a)).is_empty
} 

attributes Set[K] {
    /// a âŠ† b: Every element of a is also an element of b.
    define subset_eq(self, other: Set[K]) -> Bool {
        forall(x: K) {
            x âˆˆ self implies x âˆˆ other
        }
    }
    /// a âŠ‡ b: Every element of b is also an element of a.
    define superset_eq(self, other: Set[K]) -> Bool {
        (other).subset_eq(self)
    }

    /// a âŠ‚ b: a is a proper subset of b (a âŠ† b and a â‰  b).
    define subset(self, other: Set[K]) -> Bool {
        self âŠ† other and self != other
    }
}

/// Subset and superset are dual relations.
theorem sym_of_subset_and_supset[K](a: Set[K], b: Set[K]) {
    (a âŠ† b) iff (b âŠ‡ a)
} by {
    (a âŠ† b) implies (b âŠ‡ a)
}

/// Empty set is subset of every set (vacuous truth).
theorem empty_set_is_always_subset[K](a: Set[K]) {
    empty[K] âŠ† a
    // by "Vacuous Truth"
    // something like: if the condition in the "if" control flow is flase, then skip the execution block, without error
}

/// Every set is a subset of the universal set.
theorem all_sets_subset_universal[K](a: Set[K]) {
    a âŠ† universe[K]
}

/// Every set is a subset of itself.
theorem subset_self[K](a: Set[K]) {
    a âŠ† a
}

/// Subset relation is transitive.
theorem subset_trans[K](a1: Set[K], a2: Set[K], a3: Set[K]) {
    (a1 âŠ† a2 and a2 âŠ† a3) implies a1 âŠ† a3
}

/// Two sets are equal iff they are subsets of each other (extensionality).
theorem subset_and_supset_iff_equal[K](a1: Set[K], a2: Set[K]) {
    (a1 = a2) iff (a1 âŠ† a2 and a1 âŠ‡ a2)
} by {
    if (a1 âŠ† a2 and a1 âŠ‡ a2) {
        forall(x: K) {
            x âˆˆ a1 implies x âˆˆ a2
            x âˆˆ a2 implies x âˆˆ a1
            (x âˆˆ a1) iff (x âˆˆ a2)
        }
        a1.contains = a2.contains
        a1 = a2
    }

    (a1 = a2) implies (a1 âŠ† a2)
    (a1 = a2) implies (a2 âŠ† a1)
}

/// Characterizes set equality via extensionality: a = b iff âˆ€ x, x âˆˆ a â‡” x âˆˆ b.
define set_eq_prop[K](a: Set[K], b: Set[K]) -> Bool {
    forall(x: K) {
        ((x âˆˆ a) implies (x âˆˆ b)) 
        and 
        ((x âˆˆ b) implies (x âˆˆ a))
    }
}

/// Sets are equal iff they have the same elements (extensionality).
theorem set_equal_representation[K](a: Set[K], b: Set[K]) {
    (a = b) iff set_eq_prop(a, b)
} by {
    (a = b) implies set_eq_prop(a, b)
    
    set_eq_prop(a, b) implies (a âŠ† b)

    set_eq_prop(a, b) implies (a âŠ‡ b)
}

define elem_in_union[K](a1: Set[K], a2: Set[K], x: K) -> Bool {
    x âˆˆ a1 or x âˆˆ a2
}

define elem_in_intersection[K](a1: Set[K], a2: Set[K], x: K) -> Bool {
    x âˆˆ a1 and x âˆˆ a2
}

define elem_in_difference[K](a: Set[K], b: Set[K], x: K) -> Bool {
    x âˆˆ a and not x âˆˆ b
}

attributes Set[K] {
    /// a1 âˆª a2
    let union = function(a: Set[K], b: Set[K]) {
    Set[K].new(elem_in_union(a, b))
    }
    /// a1 âˆ© a2
    let intersection = function(a: Set[K], b: Set[K]) {
        Set[K].new(elem_in_intersection(a, b))
    }
    /// a \ b  
    /// in Typst it's "without". In LaTeX it's "setminus"
    let difference = function(a: Set[K], b: Set[K]) {
        Set[K].new(elem_in_difference(a, b))
    }
}

/// Element in union iff element in either set.
theorem in_union[K](a1: Set[K], a2: Set[K], x: K) {
    (x âˆˆ (a1 âˆª a2)) iff (x âˆˆ a1 or x âˆˆ a2)
} by {
    (x âˆˆ (a1 âˆª a2)) implies (x âˆˆ a1 or x âˆˆ a2) // redundant?

    (x âˆˆ a1 or x âˆˆ a2) implies (x âˆˆ (a1 âˆª a2))
}

/// Element in intersection iff element in both sets.
theorem in_intersection[K](a1: Set[K], a2: Set[K], x: K) {
    x âˆˆ (a1 âˆ© a2) = (x âˆˆ a1 and x âˆˆ a2)
    // parentheses required?
} by {
    x âˆˆ (a1 âˆ© a2) implies (x âˆˆ a1 and x âˆˆ a2)
}

/// A set and its complement are disjoint.
theorem compl_separate[K](a: Set[K]) {
    a âˆ© a.c = empty[K]
}

/// Set difference equals intersection with complement.
theorem difference_is_intersection_with_compl[K](a: Set[K], b: Set[K]) {
    (a âˆ– b) = (a âˆ© b.c)
} by {
    forall(x: K) {
        (x âˆˆ (a âˆ– b)) implies (x âˆˆ a) and (x âˆ‰ b) 

        (x âˆˆ (a âˆ– b)) implies (x âˆˆ (a âˆ© b.c))

        (x âˆˆ (a âˆ– b)) iff (x âˆˆ (a âˆ© b.c))
    }
}

/// Set difference is subset of minuend.
theorem diff_subset[K](a: Set[K], b: Set[K]) {
    (a âˆ– b) âŠ† a
}

/// Subset relation reverses under complement.
theorem subset_compl_to_superset[K](a: Set[K], b: Set[K]) {
    a âŠ† b iff a.c âŠ‡ b.c
} by {
    a âŠ† b implies a.c âŠ‡ b.c
}

/// Subset relation reverses under difference with fixed superset.
theorem subset_diff_to_superset[K](a: Set[K], b: Set[K], s: Set[K]) {
    a âŠ† b implies s âˆ– a âŠ‡ s âˆ– b
} 

/// Union is commutative.
theorem union_comm[K](a1: Set[K], a2: Set[K]) {
    (a1 âˆª a2) = (a2 âˆª a1)
    // by the comm of logic operator `or`
} by {
    forall(x: K) {
        elem_in_union(a1, a2, x) implies elem_in_union(a2, a1, x)
        
        elem_in_union(a1, a2, x) = elem_in_union(a2, a1, x)
    }

    elem_in_union(a1, a2) = elem_in_union(a2, a1)
}

/// Intersection is commutative.
theorem intersection_comm[K](a1: Set[K], a2: Set[K]) {
    a1 âˆ© a2 = a2 âˆ© a1
} by {
    forall(x: K) {
        elem_in_intersection(a1, a2, x) implies elem_in_intersection(a2, a1, x)
        
        elem_in_intersection(a1, a2, x) = elem_in_intersection(a2, a1, x)
    }

    elem_in_intersection(a1, a2) = elem_in_intersection(a2, a1)
}

/// De Morgan's law: complement of union equals intersection of complements.
theorem union_intersection_compl_dual[K](a1: Set[K], a2: Set[K]) {
    (a1 âˆª a2).c = (a1.c âˆ© a2.c)
    // by the De Morgan law of logic operator `and`, `or`
} by {
    forall(x: K) {
        x âˆ‰ (a1 âˆª a2) implies ((x âˆ‰ a1) and (x âˆ‰ a2))

        x âˆˆ (a1 âˆª a2).c implies (x âˆˆ a1.c âˆ© a2.c)

        x âˆˆ (a1 âˆª a2).c = (x âˆˆ a1.c âˆ© a2.c)
    }
}

/// Each set is subset of their union.
theorem set_in_union[K](a1: Set[K], a2: Set[K]) {
    a1 âŠ† a1 âˆª a2 and a2 âŠ† a1 âˆª a2
} by {
    a1 âŠ† a1 âˆª a2
    a2 âŠ† a1 âˆª a2
}

/// If both sets are subsets of a third, their union is also subset.
theorem subset_union_is_subset[K](sub_1: Set[K], sub_2: Set[K], a: Set[K]) {
    (sub_1 âŠ† a and sub_2 âŠ† a) implies ((sub_1 âˆª sub_2) âŠ† a)
}

/// Intersection is subset of each operand.
theorem set_contains_intersection[K](a1: Set[K], a2: Set[K]) {
    a1 âˆ© a2 âŠ† a1 and a1 âˆ© a2 âŠ† a2
} by {
    a1 âˆ© a2 âŠ† a1
    a1 âˆ© a2 âŠ† a2
}

/// If both sets are supersets of a third, their intersection is also superset.
theorem supset_intersection_is_supset[K](sup_1: Set[K], sup_2: Set[K], a: Set[K]) {
    (sup_1 âŠ‡ a and sup_2 âŠ‡ a) implies ((sup_1 âˆ© sup_2) âŠ‡ a)
}

/// Symmetric difference: elements in exactly one of two sets.
define sym_difference[K](a: Set[K], b: Set[K]) -> Set[K] {
    (a âˆ– b) âˆª (b âˆ– a) 
}

/// Alternative representation of symmetric difference via union minus intersection.
theorem sym_difference_another_rep[K](a: Set[K], b: Set[K]) {
    (a âˆ– b) âˆª (b âˆ– a) = (a âˆª b) âˆ– (a âˆ© b) 
} by {
    // =>
    (a âˆ– b) âŠ† (a âˆª b)
    (b âˆ– a) âŠ† (a âˆª b)

    (a âˆ– b) âŠ† b.c
    (a âˆ– b) âŠ† a.c âˆª b.c

    (a âˆ– b) âŠ† (a âˆ© b).c
    (b âˆ– a) âŠ† (a âˆ© b).c 

    (a âˆ– b) âˆª (b âˆ– a) âŠ† (a âˆª b) âˆ© (a âˆ© b).c
    // <=
    forall(x: K) {
        if (x âˆˆ a) {
            x âˆˆ (a âˆª b) âˆ– (a âˆ© b) implies x âˆˆ (a âˆ– b) âˆª (b âˆ– a)
        }
        x âˆˆ (a âˆª b) âˆ– (a âˆ© b) implies x âˆˆ (a âˆ– b) âˆª (b âˆ– a)
    }

    (a âˆª b) âˆ– (a âˆ© b) âŠ† (a âˆ– b) âˆª (b âˆ– a)
}

/// Symmetric difference is symmetric in its arguments.
theorem sym_diff_is_sym[K](a: Set[K], b: Set[K]) {
    sym_difference(a, b) = sym_difference(b, a)
}

/// Union preserves subset relation in both arguments.
theorem union_preserve_subset[K](a1: Set[K], a2: Set[K], b1: Set[K], b2: Set[K]) {
    a1 âŠ† b1 and a2 âŠ† b2 implies a1 âˆª a2 âŠ† b1 âˆª b2
}

/// Intersection preserves subset relation in both arguments.
theorem intersect_preserve_subset[K](a1: Set[K], a2: Set[K], b1: Set[K], b2: Set[K]) {
    a1 âŠ† b1 and a2 âŠ† b2 implies a1 âˆ© a2 âŠ† b1 âˆ© b2
}

/// Being subset of intersection is equivalent to being subset of both operands.
theorem superset_interseciton_superset_to_and[K](sup_1: Set[K], sup_2: Set[K], a: Set[K]) {
    a âŠ† sup_1 âˆ© sup_2 iff a âŠ† sup_1 and a âŠ† sup_2
} by {
    a âŠ† sup_1 âˆ© sup_2 implies a âŠ† sup_1 and a âŠ† sup_2
}

/// Being subset of union is equivalent to each operand being subset.
theorem subset_union_subset_to_and[K](sub_1: Set[K], sub_2: Set[K], a: Set[K]) {
    sub_1 âˆª sub_2 âŠ† a iff sub_1 âŠ† a and sub_2 âŠ† a
} by {
    sub_1 âˆª sub_2 âŠ† a implies sub_1 âŠ† a and sub_2 âŠ† a
}

/// Not subset iff intersection with complement is nonempty.
theorem not_subset_iff_contains_compl[K](a: Set[K], b: Set[K]) {
    not a âŠ† b iff a âˆ© b.c != empty[K] 
} by {
    not a âŠ† b implies a âˆ© b.c != empty[K] 
}

/// Not subset iff set difference is nonempty.
theorem not_subset_iff_contains_diff[K](a: Set[K], b: Set[K]) {
    not a âŠ† b iff a âˆ– b != empty[K] 
} by {
    a âˆ– b = a âˆ© b.c
    not a âŠ† b implies a âˆ– b != empty[K]
}

/// Subset iff set difference is empty.
theorem subset_iff_not_contains_diff[K](a: Set[K], b: Set[K]) {
    a âŠ† b iff a âˆ– b = empty[K] 
} by {
    a âŠ† b implies a âˆ– b = empty[K] 
}

/// Symmetric difference reduces to single difference when one set is subset of the other.
theorem when_sym_diff_is_diff[K](a: Set[K], b: Set[K]) {
    sym_difference(a, b) = b âˆ– a iff a âŠ† b
} by {
    if sym_difference(a, b) = b âˆ– a {
        b âˆ– a = (b âˆ– a) âˆª (a âˆ– b)
        (a âˆ– b) âŠ† (b âˆ– a)
        forall(x: K) {
            if x âˆˆ a âˆ– b {
                x âˆˆ a
                x âˆˆ b âˆ– a
                x âˆ‰ a
                false
            }
            x âˆ‰ a âˆ– b
        }
        a âˆ– b = empty[K]
        a âŠ† b
    }
    if a âŠ† b {
        a âˆ– b = empty[K]
        sym_difference(a, b) = b âˆ– a
    }
}

/// Two sets are disjoint iff their intersection is empty.
define disjoint[K](a: Set[K], b: Set[K]) -> Bool {
    a âˆ© b = empty[K]
}

/// Disjoint sets have no common elements.
theorem disjoint_by_logic_imp[K](a: Set[K], b: Set[K]) {
    disjoint(a, b) implies forall(x: K) {
        not (x âˆˆ a and x âˆˆ b)
    }
} 

/// Sets with no common elements are disjoint.
theorem disjoint_by_logic_imp_by[K](a: Set[K], b: Set[K]) {
    forall(x: K) {
        not (x âˆˆ a and x âˆˆ b)
    } implies disjoint(a, b)
}

/// A set is disjoint with its difference from another set.
theorem diff_disjointt[K](a: Set[K], b: Set[K]) {
    disjoint(a, b âˆ– a)
} by {
    forall(x: K) {
        if x âˆˆ a âˆ© (b âˆ– a) {
            x âˆˆ a
            x âˆˆ b and x âˆ‰ a
            x âˆ‰ a
            false
        } 
        x âˆ‰ a âˆ© (b âˆ– a)
    }
    a âˆ© (b âˆ– a) = empty[K]
}

/// Removing a set from union with disjoint set returns the other set.
theorem disjoint_substract[K](a: Set[K], b: Set[K]) {
    disjoint(a, b) implies (a âˆª b) âˆ– a = b
} by {
    forall(x: K) {
        if x âˆˆ (a âˆª b) âˆ– a {
            x âˆˆ a âˆª b and x âˆ‰ a
            x âˆˆ a or x âˆˆ b
            x âˆ‰ a
            x âˆˆ b
        }
    }
    (a âˆª b) âˆ– a âŠ† b
    forall(x: K) {
        if x âˆˆ b {
            x âˆ‰ a
            x âˆˆ a âˆª b
            x âˆˆ a âˆª b and x âˆ‰ a
            x âˆˆ (a âˆª b) âˆ– a
        }
    }
    (a âˆª b) âˆ– a âŠ‡ b
}

/// Any set can be decomposed as subset union with its difference.
theorem recover_from_subset_substract[K](a: Set[K], b: Set[K]) {
    a âŠ† b implies b = a âˆª (b âˆ– a)
} by {
    // This direction dose not need a âŠ† b 
    forall(x: K) {
        if x âˆˆ b {
            if x âˆˆ a {
                x âˆˆ a âˆª (b âˆ– a)
            } else {
                x âˆ‰ a
                x âˆˆ b âˆ– a
                x âˆˆ a âˆª (b âˆ– a)
            }
            x âˆˆ a âˆª (b âˆ– a)
        }
    }
    b âŠ† a âˆª (b âˆ– a)
    
    a âŠ† b
    b âˆ– a âŠ† b
    a âˆª (b âˆ– a) âŠ† b
}

/// Subset equals complement of difference from superset.
theorem sym_of_subset_substract[K](a: Set[K], b: Set[K]) {
    a âŠ† b implies a = b âˆ– (b âˆ– a)
} by {
    b = a âˆª (b âˆ– a)
    disjoint(a, b âˆ– a)
    b âˆ– (b âˆ– a) = a
}

/// Difference can be computed using smaller first operand.
theorem to_subset_substract[K](a: Set[K], b: Set[K]) {
    b âˆ– a = b âˆ– (a âˆ© b)
} by {
    a âˆ© b âŠ† a
    b âˆ– (a âˆ© b) âŠ‡ b âˆ– a
    forall(x: K) {
        if x âˆˆ b âˆ– (a âˆ© b) {
            x âˆˆ b
            x âˆ‰ a âˆ© b
            if x âˆˆ a {
                x âˆˆ a and x âˆˆ b
                x âˆˆ a âˆ© b
                false
            }
            x âˆ‰ a
            x âˆˆ b âˆ– a
        }
    }
    b âˆ– a âŠ† b âˆ– (a âˆ© b)
}

/// A set decomposes into disjoint union of intersection with and difference of intersection.
theorem substract_decomp[K](a: Set[K], b: Set[K]) {
    disjoint(a âˆ© b, b âˆ– (a âˆ© b)) and b = (a âˆ© b) âˆª (b âˆ– (a âˆ© b))
} by {
    disjoint(a âˆ© b, b âˆ– (a âˆ© b))
    (a âˆ© b) âŠ† b
}

/// Union can be expressed as disjoint union with difference from other operand.
theorem force_disjoint_union[K](a: Set[K], b: Set[K]) {
    a âˆª b = a âˆª (b âˆ– a)
} by {
    b âˆ– a âŠ† b
    a âˆª (b âˆ– a) âŠ† a âˆª b
    forall(x: K) {
        if x âˆˆ a âˆª b {
            if x âˆˆ a {
                x âˆˆ a âˆª (b âˆ– a)
            } else {
                x âˆ‰ a
                x âˆˆ b 
                x âˆˆ b âˆ– a
                x âˆˆ a âˆª (b âˆ– a)
            }
            x âˆˆ a âˆª (b âˆ– a)
        }
    }
    a âˆª b âŠ† a âˆª (b âˆ– a)
}

/// Union decomposes into disjoint union of  symmetric difference with intersection.
theorem sym_diff_decomp_1[K](a: Set[K], b: Set[K]) {
    disjoint(sym_difference(a, b), a âˆ© b) and a âˆª b = sym_difference(a, b) âˆª (a âˆ© b)
} by {
    sym_difference(a, b) âŠ† a âˆª b
    a âˆ© b âŠ† a âˆª b
    sym_difference(a, b) = (a âˆª b) âˆ– (a âˆ© b)
    a âˆª b = (a âˆ© b) âˆª ((a âˆª b) âˆ– (a âˆ© b))
}

/// Symmetric difference is disjoint union of two differences.
theorem sym_diff_decomp_2[K](a: Set[K], b: Set[K]) {
    disjoint(a âˆ– b, b âˆ– a) and sym_difference(a, b) = (a âˆ– b) âˆª (b âˆ– a)
} 

/// Union is associative.
theorem union_associative[K](a1: Set[K], a2: Set[K], a3: Set[K]) {
    (a1 âˆª a2) âˆª a3 = a1 âˆª (a2 âˆª a3)
    // by assoc if logic `or`
} by {
    let u1 = (a1 âˆª a2) âˆª a3
    let u2 = a1 âˆª (a2 âˆª a3)

    a1 âŠ† u1
    a2 âŠ† u1
    a3 âŠ† u1

    u2 âŠ† u1

    a1 âŠ† u2
    a2 âŠ† u2
    a3 âŠ† u2

    u1 âŠ† u2 
}

/// Intersection is associative.
theorem intersection_associative[K](a1: Set[K], a2: Set[K], a3: Set[K]) {
    (a1 âˆ© a2) âˆ© a3 = a1 âˆ© (a2 âˆ© a3)
} by {
    // dual of âˆª and âˆ©, to simplify writing proof
    ((a1.c âˆª a2.c) âˆª a3.c).c = (a1.c âˆª (a2.c âˆª a3.c)).c
}

/// Union is idempotent.
theorem union_idemp[K](a: Set[K]) {
    a âˆª a = a
}

/// Intersection is idempotent.
theorem intersection_idemp[K](a: Set[K]) {
    a âˆ© a = a
}

/// Union with superset returns superset.
theorem union_subset_is_self[K](sub: Set[K], a: Set[K]) {
    sub âŠ† a implies sub âˆª a = a
}

/// Intersection with subset returns subset.
theorem intersection_subset_is_self[K](sup: Set[K], a: Set[K]) {
    sup âŠ‡ a implies sup âˆ© a = a
}

/// Union with empty set returns original set.
theorem union_empty_is_self[K](a: Set[K]) {
    a âˆª empty[K] = a
}

/// Union with universal set returns universal set.
theorem union_universal_is_universal[K](a: Set[K]) {
    a âˆª universe[K] = universe[K]
}

/// Intersection with universal set returns original set.
theorem intersection_universal_is_self[K](a: Set[K]) {
    a âˆ© universe[K] = a
}

/// Intersection with empty set returns empty set.
theorem intersection_empty_is_empty[K](s: Set[K]) {
    s âˆ© empty[K] = empty[K]
}

/// If two disjoint sets have union equal to universal, they are complements.
theorem decomposition_of_universe[K](a: Set[K], b: Set[K]) {
    a âˆ© b = empty[K] and a âˆª b = universe[K] implies a = b.c
}

/// A set union with its complement equals universal set.
theorem decomposition_of_universe_imp_rev[K](a: Set[K], b: Set[K]) {
    a âˆª a.c = universe[K]
}

/// Boolean distributive law.
theorem bool_distributive(x1: Bool, x2: Bool, y: Bool) {
    ((x1 or x2) and y) = ((x1 and y) or (x2 and y))
    // parentheses is necessary
}

/// Boolean dual distributive law.
theorem bool_distributive_dual(x1: Bool, x2: Bool, y: Bool) {
    ((x1 and x2) or y) = ((x1 or y) and (x2 or y)) 
} // if put together "bool_distributive" and "bool_distributive_dual" with `and`, search fail

/// Set distributive law: union distributes over intersection.
theorem union_intersection_distributive[K](a1: Set[K], a2: Set[K], b: Set[K]) {
    ((a1 âˆª a2) âˆ© b) = ((a1 âˆ© b) âˆª (a2 âˆ© b))
} 
by {
    // âŠ‡
    a1 âˆª a2 âŠ‡ a1
    a1 âˆª a2 âŠ‡ a2
    ((a1 âˆª a2) âˆ© b) âŠ‡ (a1 âˆ© b) 
    ((a1 âˆª a2) âˆ© b) âŠ‡ (a2 âˆ© b) 
    ((a1 âˆª a2) âˆ© b) âŠ‡ ((a1 âˆ© b) âˆª (a2 âˆ© b))

    // âŠ†
    forall(x: K) {
        if x âˆˆ (a1 âˆª a2) âˆ© b {
            (x âˆˆ a1 or x âˆˆ a2) and x âˆˆ b
            (x âˆˆ a1 and x âˆˆ b) or (x âˆˆ a2 and x âˆˆ b)
            (x âˆˆ a1 âˆ© b) or (x âˆˆ a2 âˆ© b)
            x âˆˆ (a1 âˆ© b) âˆª (a2 âˆ© b)
        }
    }

    ((a1 âˆª a2) âˆ© b) âŠ† ((a1 âˆ© b) âˆª (a2 âˆ© b))
}

/// Set distributive law: intersection distributes over union.
theorem union_intersection_distributive_dual[K](a1: Set[K], a2: Set[K], b: Set[K]) {
    ((a1 âˆ© a2) âˆª b) = ((a1 âˆª b) âˆ© (a2 âˆª b))
} by {
    ((a1.c âˆª a2.c) âˆ© b.c).c = ((a1.c âˆ© b.c) âˆª (a2.c âˆ© b.c)).c
}

define or_index[I, K] (f: I -> Set[K], x: K) -> Bool {
    exists(i: I) {
        x âˆˆ f(i)
    }
}

define and_index[I, K] (f: I -> Set[K], x: K) -> Bool {
    forall(i: I) {
        x âˆˆ f(i)
    }
}

define union_index[I, K](f: I -> Set[K]) -> Set[K] {
    Set[K].new(or_index(f))
}

define intersection_index[I, K](f: I -> Set[K]) -> Set[K] {
    Set[K].new(and_index(f))
}

define index_compl[I, K](f: I -> Set[K]) -> (I -> Set[K]) {function(i: I) {f(i).c}}

theorem union_intersection_index_compl_dual[I, K](f: I -> Set[K]) {
    union_index(f).c = intersection_index(index_compl(f))
} by {
    forall(x: K) {
        // âŠ†

        // by logic dual: forall(x: K) p(x) <=> exists(x: K) not p(x)
        x âˆ‰ union_index(f) implies (
            forall(i: I) {
                x âˆ‰ f(i)
            }
        )
        // by x âˆ‰ a <=> x âˆˆ a.c
        x âˆˆ union_index(f).c implies x âˆˆ intersection_index(index_compl(f))

        // âŠ‡

        (
            forall(i: I) {
                x âˆ‰ f(i)
            }
        ) implies x âˆ‰ union_index(f)

        x âˆˆ intersection_index(index_compl[I, K](f)) implies x âˆˆ union_index(f).c

        x âˆˆ union_index(f).c iff x âˆˆ intersection_index(index_compl[I, K](f))
    }
}

// Proving indexed union and intersection definitions are consistent
// with index definitions

/// A type with exactly two values.
inductive Two {
    first
    second
}

theorem test_two(x: Two) {
    if (x = Two.first) {
        x != Two.second
    }
}

// Creates a function f: Two -> Set[K]
define fn_two[K](a1: Set[K], a2: Set[K], x: Two) -> Set[K] {
    match x {
        Two.first {
            a1
        }
        Two.second {
            a2
        }
    }
}

// Defines union in the case of two sets using index definition
define union_index_of_two[K](a1: Set[K], a2: Set[K]) -> Set[K] {
    union_index(fn_two(a1, a2))
} 

theorem union_is_union_index_of_two[K](a1: Set[K], a2: Set[K]) {
    a1 âˆª a2 = union_index_of_two(a1, a2)
} by {
    forall(x: K) {
        x âˆˆ a1 implies (
            exists(i: Two) {
                x âˆˆ fn_two(a1, a2, i)
            }
        )

        x âˆˆ a2 implies (
            exists(i: Two) {
                x âˆˆ fn_two(a1, a2, i)
            }
        )

        if (
            exists(i: Two) {
                x âˆˆ fn_two(a1, a2, i)
            }
        ) {
            Set[K].new(or_index(fn_two(a1, a2))).contains(x)
            x âˆˆ union_index_of_two(a1, a2)
        } 

        (x âˆˆ a1 âˆª a2) implies (x âˆˆ union_index_of_two(a1, a2))

        if x âˆˆ union_index_of_two(a1, a2) {
            Set[K].new(or_index(fn_two(a1, a2))).contains(x)
            (
                exists(i: Two) {
                x âˆˆ fn_two(a1, a2, i)
            }
            )
            x âˆˆ a1 or x âˆˆ a2
        }

        (x âˆˆ union_index_of_two(a1, a2)) implies x âˆˆ a1 or x âˆˆ a2

        (x âˆˆ a1 âˆª a2) = (x âˆˆ union_index_of_two(a1, a2))
    }
}

define intersection_index_of_two[K](a1: Set[K], a2: Set[K]) -> Set[K] {
    intersection_index(fn_two(a1, a2))
} 

theorem intersection_is_intersection_index_of_two[K](a1: Set[K], a2: Set[K]) {
    a1 âˆ© a2 = intersection_index_of_two(a1, a2)
} by {
    forall(x: K) {
        (
            forall(i: Two) {
                x âˆˆ fn_two(a1, a2, i)
            }
        ) implies x âˆˆ a1

        (
            forall(i: Two) {
                x âˆˆ fn_two(a1, a2, i)
            }
        ) implies x âˆˆ a2

        (x âˆˆ intersection_index_of_two(a1, a2)) implies (x âˆˆ a1 and x âˆˆ a2) 

        (x âˆˆ a1 and x âˆˆ a2) implies (
            forall(i: Two) {
                x âˆˆ fn_two(a1, a2, i)
            }
        )

        (x âˆˆ a1 and x âˆˆ a2) implies (x âˆˆ intersection_index_of_two(a1, a2)) 

        (x âˆˆ a1 âˆ© a2) implies (x âˆˆ intersection_index_of_two(a1, a2))

        (x âˆˆ a1 âˆ© a2) = (x âˆˆ intersection_index_of_two(a1, a2))
    }
}

/// Ordered pair of elements from types K1 and K2.
structure Product[K1, K2] {
    first: K1
    second: K2
}

/// Curries a two-argument function: f(i)(j) â†¦ f(i,j).
/// Converts I -> (J -> T) to (I Ã— J) -> T.
define suc_to_product[I, J, T](f: I -> (J -> T)) -> Product[I, J] -> T {
    function(p: Product[I, J]) {
        f(p.first)(p.second)
    }
}

define suc_union_index[I, J, K](f: I -> (J -> Set[K]), i: I) -> Set[K] {
    union_index(f(i))
}

theorem suc_union_index_to_union_index_product[I, J, K](f: I -> (J -> Set[K])) {
    union_index(suc_union_index(f)) = union_index(suc_to_product(f))
} by {
    forall(x: K) {
        if x âˆˆ union_index(suc_union_index(f)) {
            let i: I satisfy {
                x âˆˆ union_index(f(i))
            }
            let j: J satisfy {
                x âˆˆ f(i)(j)
            }
            x âˆˆ suc_to_product(f)(Product[I, J].new(i, j))
            x âˆˆ union_index(suc_to_product(f))
        }
    }
    union_index(suc_union_index(f)) âŠ† union_index(suc_to_product(f))
    forall(x: K) {
        if x âˆˆ union_index(suc_to_product(f)) {
            let p: Product[I, J] satisfy {
                x âˆˆ suc_to_product(f)(p)
            }
            let i0 = p.first
            let j0 = p.second
            x âˆˆ f(i0)(j0)
            x âˆˆ union_index(f(i0))
            x âˆˆ union_index(suc_union_index(f))
        }
    }
    union_index(suc_union_index(f)) âŠ‡ union_index(suc_to_product(f))
}

define suc_intersection_index[I, J, K](f: I -> (J -> Set[K]), i: I) -> Set[K] {
    intersection_index(f(i))
}

theorem suc_intersection_index_to_intersection_index_product[I, J, K](f: I -> (J -> Set[K])) {
    intersection_index(suc_intersection_index(f)) = intersection_index(suc_to_product(f))
} by {
    forall(x: K) {
        if x âˆˆ intersection_index(suc_intersection_index(f)) {
            forall(p: Product[I, J]) {
                let i = p.first
                let j = p.second
                x âˆˆ suc_intersection_index(f)(i)
                x âˆˆ intersection_index(f(i))
                x âˆˆ f(i)(j)
                x âˆˆ suc_to_product(f)(Product[I, J].new(i, j))
                x âˆˆ suc_to_product(f)(p)
            }
            x âˆˆ intersection_index(suc_to_product(f))
        }
    }
    intersection_index(suc_intersection_index(f)) âŠ† intersection_index(suc_to_product(f))
    forall(x: K) {
        if x âˆˆ intersection_index(suc_to_product(f)) {
            forall(i: I) {
                forall(j: J) {
                    x âˆˆ suc_to_product(f)(Product[I, J].new(i, j))
                    x âˆˆ f(i)(j)
                }
                x âˆˆ intersection_index(f(i))
                x âˆˆ suc_intersection_index(f)(i)
            }
            x âˆˆ intersection_index(suc_intersection_index(f))
        }
    }
    intersection_index(suc_intersection_index(f)) âŠ‡ intersection_index(suc_to_product(f))
}

/// Disjoint union (sum type) of K1 and K2.
/// Either value from K1 (inl) or value from K2 (inr).
inductive Sum[K1, K2] {
    first(K1)
    second(K2)
}

define elem_in_sum[K1, K2](a1: Set[K1], a2: Set[K2], p: Sum[K1, K2]) -> Bool {
    match p {
        Sum[K1, K2].first(x1) {
            x1 âˆˆ a1
        }
        Sum[K1, K2].second(x2) {
            x2 âˆˆ a2
        }
    }
}

attributes Set[K1] {
    define add[K2](self, a: Set[K2]) -> Set[Sum[K1,K2]] {
        Set[Sum[K1,K2]].new(elem_in_sum(self, a))
    }
}

theorem add_test[K1, K2](a1: Set[K1], a2: Set[K2]) {
    a1 + a2 âŠ† Set[Sum[K1, K2]].universal_set
}

define elem_in_product[K1,K2](a1: Set[K1], a2: Set[K2], p: Product[K1,K2]) -> Bool {
    p.first âˆˆ a1 and p.second âˆˆ a2
}

attributes Set[K1] {
    define product[K2](self, a: Set[K2]) -> Set[Product[K1,K2]] {
        Set[Product[K1,K2]].new(elem_in_product(self, a))
    }
}

theorem product_test[K1, K2](a1: Set[K1], a2: Set[K2]) {
    a1.product(a2) âŠ† Set[Product[K1, K2]].universal_set
}

define elem_in_product_index[I, K](f: I -> Set[K], x: I -> K) -> Bool {
    forall(i: I) {
        x(i) âˆˆ f(i)
    }
}

define elem_in_sum_index[I, K](f: I -> Set[K], x: Product[I, K]) -> Bool {
    exists(i: I) {
        x.first = i and x.second âˆˆ f(i)
    }
}

define product_index[I, K](f: I -> Set[K]) -> Set[I -> K] {
    Set[I -> K].new(elem_in_product_index(f))
}

define sum_index[I, K](f: I -> Set[K]) -> Set[Product[I, K]] {
    Set[Product[I, K]].new(elem_in_sum_index(f))
}

define elem_in_union_general[K](c: Set[Set[K]], x: K) -> Bool {
    exists(s: Set[K]) {
        s âˆˆ c and x âˆˆ s
    }
}

define union[K](c: Set[Set[K]]) -> Set[K] {
    Set[K].new(elem_in_union_general(c))
}

theorem elem_in_union_helper[K](c: Set[Set[K]], x: K) {
    x âˆˆ union(c) implies exists(s: Set[K]) { s âˆˆ c and x âˆˆ s }
}

theorem subset_union_general_is_subset[K](c: Set[Set[K]], a: Set[K]) {
    forall(s: Set[K]) {
        s âˆˆ c implies s âŠ† a
    } implies union(c) âŠ† a
} by {
    forall(x: K) {
        if x âˆˆ union(c) {
            let s: Set[K] satisfy {
                s âˆˆ c and x âˆˆ s
            }
            s âŠ† a
            x âˆˆ a
        }
    }
    union(c) âŠ† a
}

theorem sets_subset_imp_union_subset[K](c1: Set[Set[K]], c2: Set[Set[K]]) {
    c1 âŠ† c2 implies union(c1) âŠ† union(c2)
} by {
    forall(x: K) {
        if x âˆˆ union(c1) {
            let s: Set[K] satisfy {
                s âˆˆ c1 and x âˆˆ s
            }
            s âˆˆ c2
            x âˆˆ union(c2)
        }
    }
}

/// Every set in collection is subset of their union.
theorem union_subset[K](c: Set[Set[K]], s: Set[K]) {
    s âˆˆ c implies s âŠ† union(c)
}

/// If every set in collection is subset of s, then union is also subset.
theorem superset_union[K](c: Set[Set[K]], s: Set[K]) {
    forall(t: Set[K]) {
        t âˆˆ c implies s âŠ‡ t
    } implies s âŠ‡ union(c)
}

define elem_in_intersection_general[K](c: Set[Set[K]], x: K) -> Bool {
    forall(s: Set[K]) {
        s âˆˆ c implies x âˆˆ s
    }
}

define intersection[K](c: Set[Set[K]]) -> Set[K] {
    Set[K].new(elem_in_intersection_general(c))
}

theorem intersection_helper[K](c: Set[Set[K]], x: K) {
    forall(s: Set[K]) {
        s âˆˆ c implies x âˆˆ s
    } implies x âˆˆ intersection(c)
}

/// Subset of sets implies superset of intersections.
theorem sets_subset_imp_intersection_superset[K](c1: Set[Set[K]], c2: Set[Set[K]]) {
    c1 âŠ† c2 implies intersection(c1) âŠ‡ intersection(c2)
} by {
    forall(x: K) {
        if x âˆˆ intersection(c2) {
            forall(s: Set[K]) {
                if s âˆˆ c1 {
                    s âˆˆ c2
                    x âˆˆ s
                }
            }
            x âˆˆ intersection(c1)
        }
    }
}

/// Every set in collection is superset of their intersection.
theorem intersection_superset[K](c: Set[Set[K]], s: Set[K]) {
    s âˆˆ c implies s âŠ‡ intersection(c)
}

/// If s is subset of every set in collection, s is subset of intersection.
theorem subset_intersection[K](c: Set[Set[K]], s: Set[K]) {
    forall(t: Set[K]) {
        t âˆˆ c implies s âŠ† t
    } implies s âŠ† intersection(c)
} by {
    forall(x: K) {
        x âˆˆ s implies x âˆˆ intersection(c)
    }
}

/// Intersection over empty collection equals universal set.
theorem empty_intersection_is_universe[K] {
    intersection(Set[Set[K]].empty_set) = Set[K].universal_set
} by {
    forall(x: K) {
        x âˆˆ Set[K].universal_set
        forall(s: Set[K]) {
            if s âˆˆ Set[Set[K]].empty_set {
                if not x âˆˆ s {
                    false
                }
                x âˆˆ s
            }
            s âˆˆ Set[Set[K]].empty_set implies x âˆˆ s
        }
        x âˆˆ intersection(Set[Set[K]].empty_set)
    }
    intersection(Set[Set[K]].empty_set).contains = Set[K].universal_set.contains
}

/// Helper predicate for set of complements.
define elem_in_compl_of_sets[K](sets: Set[Set[K]], s: Set[K]) -> Bool {
    s.c âˆˆ sets
}

/// Set of complements of a collection of sets.
define compl_of_sets[K](sets: Set[Set[K]]) -> Set[Set[K]] {
    Set[Set[K]].new(elem_in_compl_of_sets(sets))
}

/// Taking complements twice returns original collection.
theorem compl_of_sets_reflect[K](sets: Set[Set[K]]) {
    compl_of_sets(compl_of_sets(sets)) = sets
} by {
    forall(s: Set[K]) {
        if s âˆˆ sets {
            s.c âˆˆ compl_of_sets(sets)
            s âˆˆ compl_of_sets(compl_of_sets(sets))
            sets.contains(s) = compl_of_sets(compl_of_sets(sets)).contains(s)
        } else {
            not s âˆˆ sets
            not s.c âˆˆ compl_of_sets(sets)
            not s âˆˆ compl_of_sets(compl_of_sets(sets))
            sets.contains(s) = compl_of_sets(compl_of_sets(sets)).contains(s)
        }
        sets.contains(s) = compl_of_sets(compl_of_sets(sets)).contains(s)
    }
    sets.contains = compl_of_sets(compl_of_sets(sets)).contains
}

/// Complement of union equals intersection of complements (generalized De Morgan).
theorem union_intersection_compl_dual_general[K](sets: Set[Set[K]]) {
    union(sets).c = intersection(compl_of_sets(sets))
} by {
    forall(x: K) {
        if x âˆˆ union(sets).c {
            x âˆ‰ union(sets)
            forall(s: Set[K]) {
                if s âˆˆ compl_of_sets(sets) {
                    s.c âˆˆ sets
                    x âˆ‰ s.c
                    x âˆˆ s
                }
            }
            x âˆˆ intersection(compl_of_sets(sets))
        }
    }
    union(sets).c âŠ† intersection(compl_of_sets(sets))
    forall(x: K) {
        if x âˆˆ intersection(compl_of_sets(sets)) {
            forall(s: Set[K]) {
                if s âˆˆ sets {
                    s.c âˆˆ compl_of_sets(sets)
                    x âˆˆ s.c
                    x âˆ‰ s
                }
            }
            x âˆ‰ union(sets)
            x âˆˆ union(sets).c          
        }
    }
    union(sets).c âŠ‡ intersection(compl_of_sets(sets))
}

/// Union over empty collection equals empty set.
theorem empty_union_is_empty[K] {
    union(Set[Set[K]].empty_set) = Set[K].empty_set
}

define intersection_with_one[K](c: Set[Set[K]], s: Set[K]) -> Set[K] {
    Set[K].new(
        function(x: K) {
            forall(t: Set[K]) {
                t âˆˆ c implies x âˆˆ s âˆ© t
            }
        }
    )
}

/// If set is in nonempty collection, intersection with it equals intersection.
theorem intersection_comm_one[K](c: Set[Set[K]], s: Set[K]) {
    (c).is_nonempty implies intersection_with_one(c, s) = s âˆ© intersection(c)
} by {
    forall(x: K) {
        if x âˆˆ intersection_with_one(c, s) {
            let u: Set[K] satisfy { u âˆˆ c }
            x âˆˆ s âˆ© u
            x âˆˆ s
            forall(t: Set[K]) {
                if t âˆˆ c {
                    x âˆˆ s âˆ© t
                    x âˆˆ t
                }
            }
            x âˆˆ intersection(c)
            x âˆˆ s and x âˆˆ intersection(c)
        }
    }
    intersection_with_one(c, s) âŠ† s âˆ© intersection(c)

    forall(x: K) {
        if x âˆˆ s âˆ© intersection(c) {
            forall(t: Set[K]) {
                if t âˆˆ c {
                    x âˆˆ s
                    x âˆˆ t
                    x âˆˆ s âˆ© t
                }
            }
            x âˆˆ intersection_with_one(c, s)
        }
    }
    intersection_with_one(c, s) âŠ‡ s âˆ© intersection(c)    
}

theorem intersection_with_one_that_in_sets[K](c: Set[Set[K]], s: Set[K]) {
    (c).is_nonempty and s âˆˆ c implies intersection_with_one(c, s) = intersection(c)
} by {
    intersection_with_one(c, s) = s âˆ© intersection(c)
    intersection(c) âŠ† s
    s âˆ© intersection(c) = intersection(c)
}

/// All pairs of sets in collection are disjoint.
define pairwise_disjoint[K](c: Set[Set[K]]) -> Bool {
    forall(a: Set[K], b: Set[K]) {
        a âˆˆ c and b âˆˆ c implies disjoint(a, b)
    }
}

// todo: (product/sum)_index_of_two
/// A function with specified domain and codomain as sets.
/// Represents a function f: A â†’ B where A âŠ† in_space and f(A) âŠ† out_space.
structure Map[K, L] {
    in_space: Set[K]
    out_space: Set[L]
    fn: K -> L
} constraint {
    forall(x: K) {
        x âˆˆ in_space implies fn(x) âˆˆ out_space
    }
}

attributes Map[K, L] {
    define restrict(self, a: Set[K]) -> Map[K, L] {
        if a âŠ† self.in_space {
            Map.new(a, self.out_space, self.fn)
        } else {
            self
        }
    }
}

// maybe we sometime want to use f: a --> b instead of m: Map[K, L] ... is this possible?
define elem_in_map[K, L](in_space: Set[K], out_space: Set[L], fn: K -> L) -> Bool {
    forall(x: K) {
        x âˆˆ in_space implies fn(x) âˆˆ out_space
    }
}

define map[K, L](in_space: Set[K], out_space: Set[L]) -> Set[K -> L] {
    Set[K -> L].new(elem_in_map(in_space, out_space))
}

/// the set theory version of union_index
define elem_in_union_index_map[I, K](m: Map[I, Set[K]], x: K) -> Bool {
    exists(i: I) {
        i âˆˆ m.in_space and x âˆˆ m.fn(i)
    }
}

/// the set theory version of union_index
define union_index_map[I, K](m: Map[I, Set[K]]) -> Set[K] {
    Set[K].new(elem_in_union_index_map(m))
}

/// the set theory version of intersection_index
define elem_in_intersection_index_map[I, K](m: Map[I, Set[K]], x: K) -> Bool {
    forall(i: I) {
        i âˆˆ m.in_space implies x âˆˆ m.fn(i)
    }
}

/// the set theory version of intersection_index
define intersection_index_map[I, K](m: Map[I, Set[K]]) -> Set[K] {
    Set[K].new(elem_in_intersection_index_map(m))
}

/// the set theory version of product_index
define elem_in_product_index_map[I, K](m: Map[I, Set[K]], x: I -> K) -> Bool {
    forall(i: I) {
        i âˆˆ m.in_space implies x(i) âˆˆ m.fn(i)
    }
}

/// the set theory version of product_index
define product_index_map[I, K](m: Map[I, Set[K]]) -> Set[I -> K] {
    Set[I -> K].new(elem_in_product_index_map(m))
}

// todo: set theory version of sum_index

attributes Map[K, L] {
    /// True if the function is injective: f(xâ‚) = f(xâ‚‚) â‡’ xâ‚ = xâ‚‚.
    define is_injective(self) -> Bool {
        forall(x1: K, x2: K) {
            x1 âˆˆ self.in_space and 
            x2 âˆˆ self.in_space implies (
                self.fn(x1) = self.fn(x2) implies x1 = x2
            ) 
        }
    }

    /// True if the function is surjective: âˆ€ y âˆˆ B, âˆƒ x âˆˆ A, f(x) = y.
    define is_surjective(self) -> Bool {
        forall(y: L) {
            y âˆˆ self.out_space implies exists(x: K) {
                x âˆˆ self.in_space and self.fn(x) = y
            }
        }
    }

    /// True if the function is both injective and surjective (bijective).
    define is_bijective(self) -> Bool {
        self.is_injective and self.is_surjective
    }
}

/// |A| â‰¤ |B|: There exists an injective function f: A â†’ B.
define cardinal_lte[K, L](a: Set[K], b: Set[L]) -> Bool {
    exists(m: Map[K, L]) {
        m.in_space = a and
        m.out_space = b and
        m.is_injective 
    }
}

/// |A| â‰¥ |B|: There exists a surjective function f: A â†’ B.
define cardinal_gte[K, L](a: Set[K], b: Set[L]) -> Bool {
    exists(m: Map[K, L]) {
        m.in_space = a and
        m.out_space = b and
        m.is_surjective 
    }
}

/// |A| = |B|: There exists a bijective function f: A â†’ B.
define cardinal_eq[K, L](a: Set[K], b: Set[L]) -> Bool {
    exists(m: Map[K, L]) {
        m.in_space = a and
        m.out_space = b and
        m.is_bijective 
    }
}

/// The power set ð’«(A): The set of all subsets of A.
define power_set[K](a: Set[K]) -> Set[Set[K]] {
    Set[Set[K]].new(a.superset_eq)
}

/// Function is injective: distinct inputs give distinct outputs.
define is_injective[K, L](f: K -> L) -> Bool {
    forall(x1: K, x2: K) { f(x1) = f(x2) implies x1 = x2 }  
}

/// Injectivity implies distinct inputs have distinct outputs.
theorem is_injective_rev_imp[K, L](f: K -> L) {
    is_injective(f) implies forall(x1: K, x2: K) { x1 != x2 implies f(x1) != f(x2) }  
} 

/// Distinct inputs having distinct outputs implies injectivity.
theorem is_injective_rev_imp_by[K, L](f: K -> L) {
    forall(x1: K, x2: K) { x1 != x2 implies f(x1) != f(x2) } implies is_injective(f)
}

/// Function is surjective: every output has some input.
define is_surjective[K, L](f: K -> L) -> Bool {
    forall(y: L) { exists(x: K) { f(x) = y } } 
}

/// Function is bijective: both injective and surjective.
define is_bijective[K, L](f: K -> L) -> Bool {
    is_injective(f) and is_surjective(f) 
}

/// Cantor's theorem: no function from K to power set of K is surjective.
theorem cardinal_lt_power[K](f: K -> Set[K]) {
    not is_surjective(f)
} by {
    define p(g: K -> Set[K], x: K) -> Bool {
        not g(x).contains(x)
    }

    let omega = Set[K].new(p(f))
    
    forall(x: K) {
        if omega.contains(x) { 
            not f(x).contains(x)
            omega != f(x)
        }
    }
}

define elem_in_image_of_function[K, L](a: Set[K], f: K -> L, y: L) -> Bool {
    exists(x: K) {
        x âˆˆ a and y = f(x)
    }
}

define elem_in_inv_image_of_function[K, L](b: Set[L], f: K -> L, x: K) -> Bool {
    exists(y: L) {
        y âˆˆ b and y = f(x)
    }
}

attributes Set[K] {
    /// The image f(A) = {f(x) | x âˆˆ A}.
    define image[L](self, f: K -> L) -> Set[L] {
        Set[L].new(elem_in_image_of_function(self, f))
    }

    /// The preimage (inverse image) fâ»Â¹(B) = {x | f(x) âˆˆ B}.
    define inv_image[L](self, f: L -> K) -> Set[L] {
        Set[L].new(elem_in_inv_image_of_function(self, f))
    }
}

theorem image_helper[K, L](a: Set[K], f: K -> L, y: L) {
    y âˆˆ a.image(f) implies exists(x: K) {
        x âˆˆ a and y = f(x)
    }
}

theorem point_image_is_image[K, L](a: Set[K], f: K -> L) {
    forall(x: K) {
        x âˆˆ a implies f(x) âˆˆ a.image(f)
    }
}

theorem point_description_of_image_subset_imp[K, L](a: Set[K], f: K -> L, b: Set[L]) {
    a.image(f) âŠ† b implies forall(x: K) {
        x âˆˆ a implies f(x) âˆˆ b
    }
} by {
    if a.image(f) âŠ† b {
        forall(x: K) {
            if x âˆˆ a {
                f(x) âˆˆ a.image(f)
                f(x) âˆˆ b
            }
        }
    }
}

theorem point_description_of_image_subset_imp_rev[K, L](a: Set[K], f: K -> L, b: Set[L]) {
    forall(x: K) {
        x âˆˆ a implies f(x) âˆˆ b
    } implies a.image(f) âŠ† b
} by {
    if forall(x: K) {
        x âˆˆ a implies f(x) âˆˆ b
    } {
        forall(y: L) {
            if y âˆˆ a.image(f) {
                let x: K satisfy { x âˆˆ a and y = f(x) }
                f(x) âˆˆ b
                y âˆˆ b
            }
        }
        a.image(f) âŠ† b
    }
}

theorem inv_image_description_of_image_subset[K, L](a: Set[K], f: K -> L, b: Set[L]) {
    a.image(f) âŠ† b iff a âŠ† b.inv_image(f)
} by {
    if a.image(f) âŠ† b {
        forall(x: K) {
            if x âˆˆ a {
                f(x) âˆˆ a.image(f)
                f(x) âˆˆ b
                x âˆˆ b.inv_image(f)
            }
        }
        a âŠ† b.inv_image(f)
    } 
    if a âŠ† b.inv_image(f) {
        forall(y: L) {
            if y âˆˆ a.image(f) {
                let x: K satisfy { x âˆˆ a and y = f(x) }
                x âˆˆ b.inv_image(f)
                f(x) âˆˆ b
                y âˆˆ b
            }
        }
        a.image(f) âŠ† b
    }
}

theorem inv_image_preserve_compl[K, L](b: Set[L], f: K -> L) {
    b.c.inv_image(f) = b.inv_image(f).c
} by {
    forall(x: K) {
        if x âˆˆ b.c.inv_image(f) {
            let y: L satisfy {
                y âˆˆ b.c and y = f(x)
            }
            if x âˆˆ b.inv_image(f) {
                f(x) âˆˆ b
                false
            }
            x âˆˆ b.inv_image(f).c
        }
    }

    b.c.inv_image(f) âŠ† b.inv_image(f).c

    forall(x: K) {
        if x âˆˆ b.inv_image(f).c {
            not x âˆˆ b.inv_image(f)
            forall(y: L) {
                not (y âˆˆ b and y = f(x))
                not f(x) âˆˆ b
            }
            f(x) âˆˆ b.c
            x âˆˆ b.c.inv_image(f)
        }
    }

    b.c.inv_image(f) âŠ‡ b.inv_image(f).c
}

theorem inv_image_preserve_intersection[K, L](a: Set[L], b: Set[L], f: K -> L) {
    (a âˆ© b).inv_image(f) = a.inv_image(f) âˆ© b.inv_image(f)
} by {
    forall(x: K) {
        if x âˆˆ (a âˆ© b).inv_image(f) {
            f(x) âˆˆ a âˆ© b
            f(x) âˆˆ a and f(x) âˆˆ b
            x âˆˆ a.inv_image(f)
            x âˆˆ b.inv_image(f)
            x âˆˆ a.inv_image(f) âˆ© b.inv_image(f)
        }
    }

    (a âˆ© b).inv_image(f) âŠ† a.inv_image(f) âˆ© b.inv_image(f)

    forall(x: K) {
        if x âˆˆ a.inv_image(f) âˆ© b.inv_image(f) {
            x âˆˆ a.inv_image(f) and x âˆˆ b.inv_image(f)
            f(x) âˆˆ a and f(x) âˆˆ b
            f(x) âˆˆ a âˆ© b
            x âˆˆ (a âˆ© b).inv_image(f)
        }
    }

    (a âˆ© b).inv_image(f) âŠ‡ a.inv_image(f) âˆ© b.inv_image(f)
}

theorem inv_image_preserve_union[K, L](a: Set[L], b: Set[L], f: K -> L) {
    (a âˆ© b).inv_image(f) = a.inv_image(f) âˆ© b.inv_image(f)
}

theorem image_of_inv_image_subset[K, L](f: K -> L, b: Set[L]) {
    b.inv_image(f).image(f) âŠ† b
} 

theorem image_preserve_subset[K, L](f: K -> L, a: Set[K], b: Set[K]) {
    a âŠ† b implies a.image(f) âŠ† b.image(f)
} 

theorem inv_image_preserve_subset[K, L](f: K -> L, a: Set[L], b: Set[L]) {
    a âŠ† b implies a.inv_image(f) âŠ† b.inv_image(f)
} 

theorem image_preserve_nomempty[K, L](f: K -> L, a: Set[K]) {
    (a).is_nonempty implies (a.image(f)).is_nonempty
} 

theorem image_preserve_empty[K, L](f: K -> L, a: Set[K]) {
    (a).is_empty implies (a.image(f)).is_empty
} 

theorem intersection_image_subset_image_intersection[K, L](f: K -> L, a: Set[K], b: Set[K]) {
    (a âˆ© b).image(f) âŠ† a.image(f) âˆ© b.image(f)
} by {
    forall(y: L) {
        if y âˆˆ (a âˆ© b).image(f) {
            let x: K satisfy { x âˆˆ a âˆ© b and y = f(x) }
            x âˆˆ a
            y âˆˆ a.image(f)
            x âˆˆ b 
            y âˆˆ b.image(f)
            y âˆˆ a.image(f) âˆ© b.image(f)
        }
    }
}

define fn_image[I, K](f: I -> K) -> Set[K] {
    universe[I].image(f)
}

theorem fn_image_helper[I, K](f: I -> K, i: I) {
    f(i) âˆˆ fn_image(f) 
} by {
    i âˆˆ universe[I]
}

theorem union_index_to_general[I, K](f: I -> Set[K]) {
    union_index(f) = union(fn_image(f))
} by {
    forall(x: K) {
        if x âˆˆ union_index(f) {
            let i: I satisfy {
                x âˆˆ f(i)
            }
            f(i) âˆˆ fn_image(f)
            x âˆˆ union(fn_image(f))
        }
    }
    union_index(f) âŠ† union(fn_image(f))
    forall(x: K) {
        if x âˆˆ union(fn_image(f)) {
            let s: Set[K] satisfy {
                s âˆˆ fn_image(f) and x âˆˆ s 
            }
            let i: I satisfy {
                s = f(i)
            }
            x âˆˆ f(i)
            x âˆˆ union_index(f)
        }
    }
    union_index(f) âŠ‡ union(fn_image(f))
}

theorem intersection_index_to_general[I, K](f: I -> Set[K]) {
    intersection_index(f) = intersection(fn_image(f))
} by {
    forall(x: K) {
        if x âˆˆ intersection_index(f) {
            forall(s: Set[K]) {
                if s âˆˆ fn_image(f) {
                    let i: I satisfy {
                        f(i) = s
                    }
                    x âˆˆ f(i)
                    x âˆˆ s
                }
            }
            x âˆˆ intersection(fn_image(f))
        }
    }
    intersection_index(f) âŠ† intersection(fn_image(f))

    forall(x: K) {
        if x âˆˆ intersection(fn_image(f)) {
            forall(i: I) {
                f(i) âˆˆ fn_image(f)
                x âˆˆ f(i)
            }
            x âˆˆ intersection_index(f)
        }
    }
    intersection_index(f) âŠ‡ intersection(fn_image(f))
}

theorem surjective_same_image[I, J, K](g: I -> J, f: J -> Set[K]) {
    is_surjective(g) implies (
        fn_image(compose(f, g)) = fn_image(f)
    )
} by {
    forall(s: Set[K]) {
        if s âˆˆ fn_image(compose(f, g)) {
            let i: I satisfy {
                s = compose(f, g)(i)
            }
            s = f(g(i))
            g(i) âˆˆ universe[J]
            s âˆˆ fn_image(f)    
        }
    }
    fn_image(compose(f, g)) âŠ† fn_image(f)

    forall(s: Set[K]) {
        if s âˆˆ fn_image(f) {
            let j: J satisfy {
                s = f(j)
            }
            let i: I satisfy {
                j = g(i)
            }
            s = f(g(i))
            s = compose(f, g)(i)
            i âˆˆ universe[I]
            s âˆˆ fn_image(compose(f, g))
        }
    }
    fn_image(compose(f, g)) âŠ‡ fn_image(f)
}

theorem surective_same_union_index[I, J, K](g: I -> J, f: J -> Set[K]) {
    is_surjective(g) implies union_index(compose(f, g)) = union_index(f)
} by {
    union_index(compose(f, g)) = union(fn_image(compose(f, g)))
    union_index(f) = union(fn_image(f))
    fn_image(compose(f, g)) = fn_image(f)
}

theorem surective_same_intersection_index[I, J, K](g: I -> J, f: J -> Set[K]) {
    is_surjective(g) implies intersection_index(compose(f, g)) = intersection_index(f)
} by {
    intersection_index(compose(f, g)) = intersection(fn_image(compose(f, g)))
    intersection_index(f) = intersection(fn_image(f))
    fn_image(compose(f, g)) = fn_image(f)
}

theorem pullback_forall_image_imp[K, L](a: Set[K], f: K -> L, prop: L -> Bool) {
    forall(y: L) {
        y âˆˆ a.image(f) implies prop(y)
    } implies forall(x: K) {
        x âˆˆ a implies prop(f(x))
    }
} 

theorem pullback_forall_image_imp_by[K, L](a: Set[K], f: K -> L, prop: L -> Bool) {
    forall(x: K) {
        x âˆˆ a implies prop(f(x))
    } implies forall(y: L) {
        y âˆˆ a.image(f) implies prop(y)
    }
} 

theorem pullback_forall_fn_image_imp[K, L](f: K -> L, prop: L -> Bool) {
    forall(y: L) {
        y âˆˆ fn_image(f) implies prop(y)
    } implies forall(x: K) {
        prop(f(x))
    }
} 

theorem pullback_forall_fn_image_imp_by[K, L](a: Set[K], f: K -> L, prop: L -> Bool) {
    forall(x: K) {
        prop(f(x))
    } implies forall(y: L) {
        y âˆˆ fn_image(f) implies prop(y)
    }
} 

theorem in_singleton[K](x: K, y: K) {
    y âˆˆ Set[K].singleton(x) iff y = x
} by {
    y âˆˆ Set[K].singleton(x) implies y = x
}

theorem singleton_subset[K](a: Set[K], x: K) {
    Set[K].singleton(x) âŠ† a iff x âˆˆ a
} by {
    Set[K].singleton(x) âŠ† a implies x âˆˆ a
}

theorem subset_singleton[K](a: Set[K], x: K) {
    a âŠ† Set[K].singleton(x) implies (
        a = Set[K].singleton(x) or a = empty[K]
    )
} by {
    if a != empty[K] {
        let y: K satisfy { y âˆˆ a }
        y âˆˆ Set[K].singleton(x)
        y = x
        x âˆˆ a
        Set[K].singleton(x) âŠ† a
        a = Set[K].singleton(x)
    }
}

theorem subset_not_eq_singleton[K](a: Set[K], x: K) {
    a âŠ‚ Set[K].singleton(x) implies a = empty[K]
}

theorem subset_not_eq_by_contains[K](a: Set[K], b: Set[K]) {
    a âŠ‚ b implies exists(x: K) {
        x âˆˆ b and x âˆ‰ a
    }
} by {
    a != b
}

/// Creates a new function that returns true for the given item and delegates to the original function for all other inputs.  
/// i.e. add a true value to f: T -> Bool by change f(item) to true 
define functional_insert[T](f: T -> Bool, item: T, x: T) -> Bool {
    if x = item {
        true
    } else {
        f(x)
    }
}

/// Creates a new function that returns false for the given item and delegates to the original function for all other inputs.  
/// i.e. add a false value to f: T -> Bool by change f(item) to false 
define functional_remove[T](f: T -> Bool, item: T, x: T) -> Bool {
    if x = item {
        false
    } else {
        f(x)
    }
}

attributes Set[K] {
    define insert(self, item: K) -> Set[K] {
        Set[K].new(functional_insert(self.contains, item))
    }

    define remove(self, item: K) -> Set[K] {
        Set[K].new(functional_remove(self.contains, item))
    }
}

theorem insert_contains[T](a: Set[T], item: T) {
    item âˆˆ a.insert(item)
}

theorem remove_does_not_contain[T](a: Set[T], item: T) {
    not item âˆˆ a.remove(item)
}

theorem insert_other_contains_eq[T](a: Set[T], item: T, other: T) {
    item != other implies item âˆˆ a = item âˆˆ a.insert(other)
} by {
    if item âˆˆ a {
        item âˆˆ a iff item âˆˆ a.insert(other)
    } else {
        not item âˆˆ a
        not item âˆˆ a.insert(other)
        item âˆˆ a = item âˆˆ a.insert(other)
    }
}

theorem remove_other_contains_eq[T](a: Set[T], item: T, other: T) {
    item != other implies item âˆˆ a = item âˆˆ a.remove(other)
} by {
    if item âˆˆ a {
        item âˆˆ a iff item âˆˆ a.remove(other)
    } else {
        not item âˆˆ a
        not item âˆˆ a.remove(other)
        item âˆˆ a = item âˆˆ a.remove(other)
    }
}

theorem remove_then_insert[T](a: Set[T], item: T) {
    item âˆˆ a implies a.remove(item).insert(item) = a
} by {
    if a.remove(item).insert(item) != a {
        a.remove(item).insert(item).contains != a.contains
        let t: T satisfy {
            t âˆˆ a.remove(item).insert(item) != t âˆˆ a
        }
        if item != t {
            if t âˆˆ a {
                t âˆˆ a.remove(item)
                false
            } else {
                false
            }
        } else {
            item = t
            not t âˆˆ a
            false
        }
    }
}

theorem insert_then_remove[T](a: Set[T], item: T) {
    not item âˆˆ a implies a.insert(item).remove(item) = a
} by {
    if a.insert(item).remove(item) != a {
        a.insert(item).remove(item).contains != a.contains
        let t: T satisfy {
            t âˆˆ a.insert(item).remove(item) != t âˆˆ a
        }
        if item != t {
            if t âˆˆ a {
                false
            } else {
                t âˆˆ a.insert(item)
                false
            }
        } else {
            item = t
            not t âˆˆ a
            false
        }
    }
}