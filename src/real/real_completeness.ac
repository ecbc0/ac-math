from nat import ℕ
from rat import ℚ
from real.real_base import ℝ, is_cut, is_lower_interval, is_greatest, has_greatest, is_dedekind_cut
numerals ℝ
from set import Set, empty, intersection, constant_false
from limit.net import Net, no_empty, subset_two_intersection, is_net

attributes ℝ {
    /// True if this real number is an upper bound for the set s.
    define is_set_upper_bound(self, s: Set[ℝ]) -> Bool {
        forall(y: ℝ) {
            y ∈ s implies y <= self
        }
    }

    /// True if this real number is a lower bound for the set s.
    define is_set_lower_bound(self, s: Set[ℝ]) -> Bool {
        forall(y: ℝ) {
            y ∈ s implies self <= y
        }
    }

    /// True if this real number is the least upper bound (supremum) for the set s.
    define is_set_least_upper_bound(self, s: Set[ℝ]) -> Bool {
        self.is_set_upper_bound(s) and
        forall(y: ℝ) {
            y.is_set_upper_bound(s) implies self <= y
        }
    }

    /// True if this real number is the greatest lower bound (infimum) for the set s.
    define is_set_greatest_lower_bound(self, s: Set[ℝ]) -> Bool {
        self.is_set_lower_bound(s) and
        forall(y: ℝ) {
            y.is_set_lower_bound(s) implies y <= self
        }
    }
}

theorem uniqueness_of_least_upper_bound(u1: ℝ, u2: ℝ, s: Set[ℝ]) {
    u1.is_set_least_upper_bound(s) and u2.is_set_least_upper_bound(s) implies u1 = u2
}

theorem uniqueness_of_greatest_lower_bound(u1: ℝ, u2: ℝ, s: Set[ℝ]) {
    u1.is_set_greatest_lower_bound(s) and u2.is_set_greatest_lower_bound(s) implies u1 = u2
}

define is_nonempty[K](s: Set[K]) -> Bool {
    exists(x: K) {
        x ∈ s
    }
}

theorem is_nonempty_iff_is_not_empty_set[K](s: Set[K]) {
    is_nonempty(s) iff s != Set[K].empty_set
} by {
    is_nonempty(s) implies s != Set[K].empty_set
}

// The supremum condition on s is that it's nonempty, and has
// an upper bound.
// sup_cut is the Dedekind cut that will be the supremum of s.
// First we define it, then we prove that it is a Dedekind cut.
/// All r ∈ ℚ that r < sup(s)  
/// Or written as ∪(a ∈ s, ℚ_(< a)) = ℚ_(< sup(s))
define sup_cut(s: Set[ℝ], r: ℚ) -> Bool {
    not ℝ.from_rat(r).is_set_upper_bound(s)
}

theorem sup_cut_is_cut(s: Set[ℝ], ub: ℝ) {
    is_nonempty(s) and ub.is_set_upper_bound(s)
    implies
    is_cut(sup_cut(s))
} by {
    let x: ℝ satisfy {
        x ∈ s
    }

    let r1: ℚ satisfy {
        ℝ.from_rat(r1) < x
    }

    not ℝ.from_rat(r1).is_set_upper_bound(s)
    sup_cut(s, r1)

    let r2: ℚ satisfy {
        ℝ.from_rat(r2) > ub
    }

    // Show that r2 is an upper bound of s
    forall(y: ℝ) {
        if y ∈ s {
            y <= ub
            ub < ℝ.from_rat(r2)
            y < ℝ.from_rat(r2)
            y <= ℝ.from_rat(r2)
        }
    }
    ℝ.from_rat(r2).is_set_upper_bound(s)
    not sup_cut(s, r2)
}

theorem sup_cut_is_lower_interval(s: Set[ℝ], ub: ℝ) {
    is_nonempty(s) and ub.is_set_upper_bound(s)
    implies
    is_lower_interval(sup_cut(s))
} by {
    forall(x: ℚ, y: ℚ) {
        if sup_cut(s, y) and x < y {
            not ℝ.from_rat(y).is_set_upper_bound(s)
            let z: ℝ satisfy {
                z ∈ s and z > ℝ.from_rat(y)
            }
            z > ℝ.from_rat(x)
            not ℝ.from_rat(x).is_set_upper_bound(s)
            sup_cut(s, x)
        }
    }
}

// r ∈ ℚ, r < sup(s) have no greatest
theorem sup_cut_not_has_greatest(s: Set[ℝ], ub: ℝ) {
    is_nonempty(s) and ub.is_set_upper_bound(s)
    implies
    not has_greatest(sup_cut(s))
} by {
    if has_greatest(sup_cut(s)) {
        let q: ℚ satisfy {
            is_greatest(sup_cut(s), q)
        }

        sup_cut(s, q)
        not ℝ.from_rat(q).is_set_upper_bound(s)
        let z: ℝ satisfy {
            z ∈ s and z > ℝ.from_rat(q)
        }

        ℝ.from_rat(q) < z
        let q_prime: ℚ satisfy {
            q < q_prime and ℝ.from_rat(q_prime) < z
        }

        // Since ℝ.from_rat(q_prime) < z and z is in s,
        // ℝ.from_rat(q_prime) is not an upper bound for s
        not ℝ.from_rat(q_prime).is_set_upper_bound(s)

        // Therefore q_prime is in the cut
        sup_cut(s, q_prime)

        // But q < q_prime, contradicting our assumption
        not q_prime <= q
        not is_greatest(sup_cut(s), q)
        false
    }
}

define have_upper_bound(s: Set[ℝ]) -> Bool {
    exists(ub: ℝ) {
        ub.is_set_upper_bound(s)
    }
}

theorem sup_cut_is_dedekind_cut(s: Set[ℝ], ub: ℝ) {
    is_nonempty(s) and have_upper_bound(s)
    implies
    is_dedekind_cut(sup_cut(s))
}

theorem sup_dedekind_cut_imp_no_empty_and_have_upper_bound(s: Set[ℝ]) {
    is_dedekind_cut(sup_cut(s)) implies is_nonempty(s) and have_upper_bound(s)
} 

let sup = function(s: Set[ℝ]) {
    if is_nonempty(s) and have_upper_bound(s) {
        ℝ.new(sup_cut(s))
    } else {
        0
    }
}

theorem ub_imp_lub(s: Set[ℝ], x: ℝ) {
    is_nonempty(s) and have_upper_bound(s)
    implies sup(s).is_set_least_upper_bound(s)
    
} by {
    is_dedekind_cut(sup_cut(s))
    let y = sup(s)

    // Part 1: Show y is an upper bound of s
    forall(z: ℝ) {
        if z ∈ s {
            if z > y {
                let q: ℚ satisfy {
                    z > ℝ.from_rat(q) and ℝ.from_rat(q) > y
                }
                not y.gt_rat(q)
                not sup_cut(s, q)
                ℝ.from_rat(q).is_set_upper_bound(s)
                z <= ℝ.from_rat(q)
                false
            }
        }
    }
    y.is_set_upper_bound(s)

    // Part 2: Show y is the least upper bound
    forall(w: ℝ) {
        if w.is_set_upper_bound(s) {
            // We'll prove y <= w by contradiction
            if y > w {
                let q: ℚ satisfy {
                    y > ℝ.from_rat(q) and ℝ.from_rat(q) > w
                }
                not y <= ℝ.from_rat(q)
                sup_cut(s, q)
                not ℝ.from_rat(q).is_set_upper_bound(s)
                let z: ℝ satisfy {
                    z ∈ s and z > ℝ.from_rat(q)
                }
                z <= w
                ℝ.from_rat(q) > w
                z > ℝ.from_rat(q)
                z > w
                false
            }
        }
    }
}

theorem lte_sup(s: Set[ℝ], y: ℝ, a: ℝ) {
    y.is_set_least_upper_bound(s) and a ∈ s implies a <= y
}

theorem closely_lt_sup(s: Set[ℝ], y: ℝ, ε: ℝ) {
    y.is_set_least_upper_bound(s) and ε > 0 implies exists(a: ℝ) {
        a ∈ s and y - ε < a and a <= y
    }
    
} by {
    y - ε < y

    not (y - ε).is_set_upper_bound(s)

    let a: ℝ satisfy {
        a ∈ s and not a <= y - ε
    }

    a > y - ε

    a <= y

    a ∈ s and y - ε < a and a <= y
}

theorem closely_lt_sup_directly(s: Set[ℝ], y: ℝ, l: ℝ) {
    y.is_set_least_upper_bound(s) and l < y implies exists(a: ℝ) {
        a ∈ s and l < a and a <= y
    }
} by {
    let ε = y - l
    ε > 0
}

define flip_fn(f: ℝ -> Bool, x: ℝ) -> Bool {
    f(-x)
}

theorem flip_flip_fn(f: ℝ -> Bool) {
    flip_fn(flip_fn(f)) = f
} by {
    forall(x: ℝ) {
        flip_fn(flip_fn(f), x) = flip_fn(f)(-x)
        flip_fn(flip_fn(f), x) = f(x)
    }
}

define flip(s: Set[ℝ]) -> Set[ℝ] {
    Set[ℝ].new(flip_fn(s.contains))
}

theorem flip_flip(s: Set[ℝ]) {
    flip(flip(s)) = s
} by {
    flip(s).contains = flip_fn(s.contains)
    flip(flip(s)).contains = flip_fn(flip_fn(s.contains))
    flip(flip(s)).contains = s.contains
}

theorem lb_imp_flip_ub(s: Set[ℝ], x: ℝ) {
    x.is_set_lower_bound(s) implies (-x).is_set_upper_bound(flip(s))
} by {
    forall(y: ℝ) {
        if y ∈ flip(s) {
            -y ∈ s
            x <= -y
            -x >= y
        }
    }
}

theorem neg_lte(a: ℝ, b: ℝ) {
    -a <= b implies -b <= a
} 

theorem ub_imp_flip_lb(s: Set[ℝ], x: ℝ) {
    x.is_set_upper_bound(s) implies (-x).is_set_lower_bound(flip(s))
} by {
    forall(y: ℝ) {
        if y ∈ flip(s) {
            -y ∈ s
            -y <= x
            -x <= y
        }
    }
}

theorem glb_imp_flip_lub(s: Set[ℝ], x: ℝ) {
    x.is_set_greatest_lower_bound(s)
    implies (-x).is_set_least_upper_bound(flip(s))
} by {
    x.is_set_lower_bound(s)
    (-x).is_set_upper_bound(flip(s))

    forall(y: ℝ) {
        if y.is_set_upper_bound(flip(s)) {
            (-y).is_set_lower_bound(flip(flip(s)))
            (-y).is_set_lower_bound(s)
            -y <= x
            -x <= y
        }
    }
    (-x).is_set_least_upper_bound(flip(s))
}

theorem lub_imp_flip_glb(s: Set[ℝ], x: ℝ) {
    x.is_set_least_upper_bound(s)
    implies (-x).is_set_greatest_lower_bound(flip(s))
} by {
    x.is_set_upper_bound(s)
    (-x).is_set_lower_bound(flip(s))

    forall(y: ℝ) {
        if y.is_set_lower_bound(flip(s)) {
            (-y).is_set_upper_bound(flip(flip(s)))
            (-y).is_set_upper_bound(s)
            x <= -y
            y <= -x
        }
    }
}

theorem flip_preserve_nonempty(s: Set[ℝ]) {
    is_nonempty(s) implies is_nonempty(flip(s))
} by {
    let x: ℝ satisfy { x ∈ s }
    -x ∈ flip(s)
}

define have_lower_bound(s: Set[ℝ]) -> Bool {
    exists(lb: ℝ) {
        lb.is_set_lower_bound(s)
    }
}

let inf = function(s: Set[ℝ]) {
    if is_nonempty(s) and have_lower_bound(s) {
        -ℝ.new(sup_cut(flip(s)))
    } else {
        0
    }
}

theorem lb_imp_glb(s: Set[ℝ]) {
    is_nonempty(s) and have_lower_bound(s)
    implies inf(s).is_set_greatest_lower_bound(s)
} by {
    let x: ℝ satisfy { x.is_set_lower_bound(s) }
    is_nonempty(flip(s))
    (-x).is_set_upper_bound(flip(s))
    let y: ℝ satisfy {
        y.is_set_least_upper_bound(flip(s))
    }
    (-y).is_set_greatest_lower_bound(flip(flip(s)))
    flip(flip(s)) = s
    (-y).is_set_greatest_lower_bound(s)
}

theorem gte_inf(s: Set[ℝ], y: ℝ, a: ℝ) {
    y.is_set_greatest_lower_bound(s) and a ∈ s implies a >= y
}

theorem inf_lte_sup(s: Set[ℝ]) {
    is_nonempty(s) and have_lower_bound(s) and have_upper_bound(s) implies inf(s) <= sup(s)
}

theorem closely_gt_inf(s: Set[ℝ], y: ℝ, ε: ℝ) {
    y.is_set_greatest_lower_bound(s) and ε > 0 implies exists(a: ℝ) {
        a ∈ s and y <= a and a < y + ε 
    }
} by {
    (-y).is_set_least_upper_bound(flip(s))
    let b: ℝ satisfy {
        b ∈ flip(s) and -y - ε < b and b <= -y
    }
    -b ∈ s
    y <= -b
    -b < y + ε
    let a = -b
    a ∈ s and y <= a and a < y + ε 
}

theorem closely_gt_inf_directly(s: Set[ℝ], y: ℝ, u: ℝ) {
    y.is_set_greatest_lower_bound(s) and u > y implies exists(a: ℝ) {
        a ∈ s and y <= a and a < u 
    }
} by {
    let ε = u - y
    ε > 0
}

define converge_to(f: ℕ -> ℝ, a: ℝ) -> Bool {
    forall(ε: ℝ) {
        ε > 0 implies exists(n: ℕ) {
            forall(m: ℕ) {
                m > n implies (f(m) - a).abs < ε
            }
        }
    }
}

define converge(f: ℕ -> ℝ) -> Bool {
    exists(a: ℝ) {
        converge_to(f, a)
    }
}

define is_monotone_increase(f: ℕ -> ℝ) -> Bool {
    forall(n: ℕ, m: ℕ) {
        n < m implies f(n) <= f(m)
    }
}

attributes ℝ {
    define is_seq_upper_bound(self, f: ℕ -> ℝ) -> Bool {
        forall(n: ℕ) {
            f(n) <= self
        }
    }
}

define have_seq_upper_bound(f: ℕ -> ℝ) -> Bool {
    exists(a: ℝ) {
        a.is_seq_upper_bound(f)
    }
}

define elem_in_real_seq_image_to_set(f: ℕ -> ℝ, x: ℝ) -> Bool {
    exists(n: ℕ) { x = f(n) }
}

define seq_image(f: ℕ -> ℝ) -> Set[ℝ] {
    Set.new(elem_in_real_seq_image_to_set(f))
}

theorem seq_upper_bound_to_upper_bound(f: ℕ -> ℝ) {
    have_seq_upper_bound(f) implies have_upper_bound(seq_image(f))
} by {
    let a: ℝ satisfy { 
        a.is_seq_upper_bound(f) 
    }
    forall(x: ℝ) {
        if x ∈ seq_image(f) {
            let n: ℕ satisfy { x = f(n) }
            f(n) <= a
            x <= a
        }
    }
    a.is_set_upper_bound(seq_image(f))
    have_upper_bound(seq_image(f))
}

theorem seq_nonempty(f: ℕ -> ℝ) {
    is_nonempty(seq_image(f))
} by {
    f(ℕ.0) ∈ seq_image(f)
}

theorem monotone_convergence_to(f: ℕ -> ℝ) {
    is_monotone_increase(f) and have_seq_upper_bound(f) implies converge_to(f, ℝ.new(sup_cut(seq_image(f))))
} by {
    is_nonempty(seq_image(f))
    have_upper_bound(seq_image(f))
    let a = ℝ.new(sup_cut(seq_image(f)))
    a.is_set_least_upper_bound(seq_image(f))
    forall(ε: ℝ) {
        if ε > 0 {
            let x: ℝ satisfy {
                x ∈ seq_image(f) and a - ε < x and x <= a
            }
            let n: ℕ satisfy { x = f(n) }
            forall(m: ℕ) {
                if m > n {
                    f(m) >= f(n)
                    a - ε < f(m)
                    a.is_set_upper_bound(seq_image(f))
                    f(m) ∈ seq_image(f)
                    f(m) <= a 
                    - ε < f(m) - a
                    f(m) - a <= 0
                    f(m) - a < ε
                    (f(m) - a).abs < ε
                }
            }
        }
    }
    converge_to(f, a)
}

theorem monotone_convergence(f: ℕ -> ℝ) {
    is_monotone_increase(f) and have_seq_upper_bound(f) implies converge(f)
}

define elem_in_closed_interval(a: ℝ, b: ℝ, x: ℝ) -> Bool {
    a <= x and x <= b
}

define closed_interval(a: ℝ, b: ℝ) -> Set[ℝ] {
    Set[ℝ].new(elem_in_closed_interval(a, b))
}

define is_closed_interval(s: Set[ℝ]) -> Bool {
    exists(a: ℝ, b: ℝ) {
        a <= b and s = closed_interval(a, b)
    }
}

theorem closed_interval_is_nonempty(s: Set[ℝ]) {
    is_closed_interval(s) implies is_nonempty(s)
} by {
    let (a: ℝ, b: ℝ) satisfy {
        a <= b and s = closed_interval(a, b)
    }
    let x: ℝ satisfy { a <= x and x <= b }
    elem_in_closed_interval(a, b, x)
    x ∈ closed_interval(a, b)
    x ∈ s
}

theorem end_point_in_closed_interval(a: ℝ, b: ℝ) {
    a <= b implies (
        a ∈ closed_interval(a, b) and b ∈ closed_interval(a, b)
    )
} by {
    a ∈ closed_interval(a, b)
    b ∈ closed_interval(a, b)
}

theorem end_point_order_imp_subset_order(a1: ℝ, b1: ℝ, a2: ℝ, b2: ℝ) {
    (a1 <= b1 and a2 <= b2) implies (
        a1 >= a2 and b1 <= b2 implies closed_interval(a1, b1) ⊆ closed_interval(a2, b2)
    )
} by {
    if a1 >= a2 and b1 <= b2 {
        forall(x: ℝ) {
            if x ∈ closed_interval(a1, b1) {
                a1 <= x
                x <= b1
                a2 <= x
                x <= b2
                x ∈ closed_interval(a2, b2)
            }
        }
        closed_interval(a1, b1) ⊆ closed_interval(a2, b2)
    }
}

theorem subset_order_imp_end_point_order_imp(a1: ℝ, b1: ℝ, a2: ℝ, b2: ℝ) {
    (a1 <= b1 and a2 <= b2) implies (
        closed_interval(a1, b1) ⊆ closed_interval(a2, b2) implies  a1 >= a2 and b1 <= b2
    )
} by {
    if closed_interval(a1, b1) ⊆ closed_interval(a2, b2) {
        a1 ∈ closed_interval(a1, b1)
        a1 ∈ closed_interval(a2, b2)
        a1 >= a2
        b1 ∈ closed_interval(a1, b1)
        b1 ∈ closed_interval(a2, b2)
        b1 <= b2 
        a1 >= a2 and b1 <= b2
    }
}

theorem interval_have_inf_sup(s: Set[ℝ]) {
    is_closed_interval(s) implies is_nonempty(s) and have_lower_bound(s) and have_upper_bound(s)
} by {
    let (a: ℝ, b: ℝ) satisfy {
        a <= b and s = closed_interval(a, b)
    }
    a ∈ s
    b ∈ s
    is_nonempty(s)
    forall(x: ℝ) {
        if x ∈ s {
            x ∈ closed_interval(a, b)
            a <= x
        }
    }
    a.is_set_lower_bound(s)
    forall(x: ℝ) {
        if x ∈ s {
            x ∈ closed_interval(a, b)
            x <= b
        }
    }
    b.is_set_upper_bound(s)
    have_lower_bound(s)
    have_upper_bound(s)
}

theorem end_point_is_inf_sup(s: Set[ℝ]) {
    is_closed_interval(s) implies s = closed_interval(inf(s), sup(s))
} by {
    let (a: ℝ, b: ℝ) satisfy {
        a <= b and s = closed_interval(a, b)
    }
    a ∈ s
    b ∈ s
    inf(s).is_set_greatest_lower_bound(s)
    sup(s).is_set_least_upper_bound(s)
    inf(s) <= a
    b <= sup(s)

    if inf(s) < a {
        a > inf(s)
        let x: ℝ satisfy { 
            x ∈ s and inf(s) <= x and x < a
        }
        x ∈ closed_interval(a, b)
        a <= x
        false
    }

    inf(s) = a

    if b < sup(s) {
        let x: ℝ satisfy { 
            x ∈ s and x <= sup(s) and b < x
        }
        x ∈ closed_interval(a, b)
        x <= b
        false
    }

    sup(s) = b
}

theorem inf_sup_in_closed_interval(s: Set[ℝ]) {
    is_closed_interval(s) implies (
        inf(s) ∈ s and sup(s) ∈ s
    )
} by {
    inf(s) <= sup(s)
    s = closed_interval(inf(s), sup(s))
}

theorem in_closed_interval_imp_gte_lower_end_point(s: Set[ℝ], x: ℝ) {
    is_closed_interval(s) and x ∈ s implies x >= inf(s)
}

theorem in_closed_interval_imp_lte_upper_end_point(s: Set[ℝ], x: ℝ) {
    is_closed_interval(s) and x ∈ s implies x <= sup(s)
}

define are_closed_intervals(c: Set[Set[ℝ]]) -> Bool {
    forall(s: Set[ℝ]) {
        s ∈ c implies is_closed_interval(s)
    }
}

define comparable(a: Set[ℝ], b: Set[ℝ]) -> Bool {
    a ⊆ b or b ⊆ a
}

define is_chain(c: Set[Set[ℝ]]) -> Bool {
    forall(a: Set[ℝ], b: Set[ℝ]) {
        a ∈ c and b ∈ c implies comparable(a, b)
    }
}

define is_closed_interval_chain(c: Set[Set[ℝ]]) -> Bool {
    is_chain(c) and are_closed_intervals(c)
}

define elem_in_closed_intervals_lower_end_point(c: Set[Set[ℝ]], x: ℝ) -> Bool {
    if are_closed_intervals(c) {
        exists(s: Set[ℝ]) {
            s ∈ c and x = inf(s)
        }
    } else {
        false
    }
}

define elem_in_closed_intervals_upper_end_point(c: Set[Set[ℝ]], x: ℝ) -> Bool {
    if are_closed_intervals(c) {
        exists(s: Set[ℝ]) {
            s ∈ c and x = sup(s)
        }
    } else {
        false
    }
}

define closed_intervals_lower_end_point(c: Set[Set[ℝ]]) -> Set[ℝ] {
    Set[ℝ].new(elem_in_closed_intervals_lower_end_point(c))
}

define closed_intervals_upper_end_point(c: Set[Set[ℝ]]) -> Set[ℝ] {
    Set[ℝ].new(elem_in_closed_intervals_upper_end_point(c))
}

define lower_lte_upper(c: Set[Set[ℝ]]) -> Bool {
    forall(l: ℝ, u: ℝ) {
        l ∈ closed_intervals_lower_end_point(c) and u ∈ closed_intervals_upper_end_point(c) implies l <= u 
    }
}

define is_lower_lte_upper_intervals(c: Set[Set[ℝ]]) -> Bool {
    are_closed_intervals(c) and lower_lte_upper(c)
}

theorem closed_interval_chain_imp_lower_lte_upper(c: Set[Set[ℝ]]) {
    is_closed_interval_chain(c) implies is_lower_lte_upper_intervals(c)
} by {
    let ls = closed_intervals_lower_end_point(c)
    let us = closed_intervals_upper_end_point(c)
    forall(a1: ℝ, a2: ℝ) {
        if a1 ∈ closed_intervals_lower_end_point(c) and a2 ∈ closed_intervals_upper_end_point(c) {
            elem_in_closed_intervals_lower_end_point(c, a1)
            let s1: Set[ℝ] satisfy {
                s1 ∈ c and a1 = inf(s1)
            }
            elem_in_closed_intervals_upper_end_point(c, a2)
            let s2: Set[ℝ] satisfy {
                s2 ∈ c and a2 = sup(s2)
            }
            if s1 ⊆ s2 {
                inf(s1) ∈ s1
                a1 ∈ s1
                a1 ∈ s2
                a1 <= sup(s2)
                inf(s1) <= sup(s2)
                a1 <= a2
            } else {
                s2 ⊆ s1
                sup(s2) ∈ s2
                a2 ∈ s2
                a2 ∈ s1
                is_closed_interval(s1)
                inf(s1) <= a2
                inf(s1) <= sup(s2)
                a1 <= a2
            }
            a1 <= a2
        }
    }
}

theorem lower_lte_upper_intervals_lower_end_point_have_upper_bound(c: Set[Set[ℝ]]) {
    is_nonempty(c) and is_lower_lte_upper_intervals(c) implies have_upper_bound(closed_intervals_lower_end_point(c))
} by {
    let s: Set[ℝ] satisfy { s ∈ c }
    sup(s) ∈ closed_intervals_upper_end_point(c)
    let ls = closed_intervals_lower_end_point(c)
    forall(x: ℝ) {
        if x ∈ ls {
            x <= sup(s)
        }
    }
    sup(s).is_set_upper_bound(ls)
}

theorem lower_lte_upper_intervals_upper_end_point_have_lower_bound(c: Set[Set[ℝ]]) {
    is_nonempty(c) and is_lower_lte_upper_intervals(c) implies have_lower_bound(closed_intervals_upper_end_point(c))
} by {
    let s: Set[ℝ] satisfy { s ∈ c }
    inf(s) ∈ closed_intervals_lower_end_point(c)
    let us = closed_intervals_upper_end_point(c)
    forall(x: ℝ) {
        if x ∈ us {
            inf(s) <= x
        }
    }
    inf(s).is_set_lower_bound(us)
}

theorem lower_lte_upper_intervals_lower_end_point_is_nonempty(c: Set[Set[ℝ]]) {
    is_nonempty(c) and are_closed_intervals(c) implies is_nonempty(closed_intervals_lower_end_point(c))
} by {
    let s: Set[ℝ] satisfy { s ∈ c }
}

theorem lower_lte_upper_intervals_upper_end_point_is_nonempty(c: Set[Set[ℝ]]) {
    is_nonempty(c) and are_closed_intervals(c) implies is_nonempty(closed_intervals_upper_end_point(c))
} by {
    let s: Set[ℝ] satisfy { s ∈ c }
}

theorem lower_lte_upper_intervals_lower_sup_lte_upper_inf(c: Set[Set[ℝ]]) {
    is_nonempty(c) and is_lower_lte_upper_intervals(c) implies (
        sup(closed_intervals_lower_end_point(c)) <= inf(closed_intervals_upper_end_point(c))
    )
} by {
    let ls = closed_intervals_lower_end_point(c)
    let us = closed_intervals_upper_end_point(c)
    let a = sup(ls)
    let b = inf(us)
    if a > b {
        let r: ℝ satisfy { b < r and r < a }
        a.is_set_least_upper_bound(ls)
        closely_lt_sup_directly(ls, a, r)
        let x: ℝ satisfy {
            x ∈ ls and r < x and x <= a
        }
        b.is_set_greatest_lower_bound(us)
        closely_gt_inf_directly(us, b, r)
        let y: ℝ satisfy {
            y ∈ us and y < r and b <= y
        }
        y < x
        x <= y
        false
    }
}

theorem closed_interval_intersection(c: Set[Set[ℝ]]) {
    is_nonempty(c) and is_lower_lte_upper_intervals(c) implies intersection(c) = closed_interval(
        sup(closed_intervals_lower_end_point(c)), 
        inf(closed_intervals_upper_end_point(c))
    )
} by {
    let ls = closed_intervals_lower_end_point(c)
    let us = closed_intervals_upper_end_point(c)
    let a = sup(ls)
    let b = inf(us)
    a <= b
    forall(s: Set[ℝ]) {
        if s ∈ c {
            inf(s) ∈ ls
            sup(s) ∈ us
            inf(s) <= a
            inf(us) <= sup(s)
            b <= sup(s)
            s = closed_interval(inf(s), sup(s))
            closed_interval(a, b) ⊆ s
        }
    }
    forall(x: ℝ) {
        if x ∈ closed_interval(a, b) {
            forall(s: Set[ℝ]) {
                s ∈ c implies closed_interval(a, b) ⊆ s
                s ∈ c implies x ∈ s
            }
            x ∈ intersection(c)
        }
    }
    closed_interval(a, b) ⊆ intersection(c)

    forall(x: ℝ) {
        if x ∈ intersection(c) {
            if x < a {
                x < sup(ls)
                sup(ls).is_set_least_upper_bound(ls)
                let l: ℝ satisfy { l ∈ ls and x < l }
                l ∈ closed_intervals_lower_end_point(c)
                elem_in_closed_intervals_lower_end_point(c, l)
                let s_l: Set[ℝ] satisfy {
                    s_l ∈ c and l = inf(s_l)
                }
                not l <= x
                is_closed_interval(s_l)
                not x ∈ s_l
                not x ∈ intersection(c)
                false
            }
            a <= x
            if x > b {
                x > inf(us)
                inf(us).is_set_greatest_lower_bound(us)
                let u: ℝ satisfy { u ∈ us and x > u }
                u ∈ closed_intervals_upper_end_point(c)
                elem_in_closed_intervals_upper_end_point(c, u)
                let s_u: Set[ℝ] satisfy {
                    s_u ∈ c and u = sup(s_u)
                }
                not x <= u
                is_closed_interval(s_u)
                not x ∈ s_u
                not x ∈ intersection(c)
                false
            }
            x <= b
            x ∈ closed_interval(a, b)
        }
    }
    intersection(c) ⊆ closed_interval(a, b)
    intersection(c) = closed_interval(a, b)
}

theorem closed_interval_intersection_theorem(c: Set[Set[ℝ]]) {
    is_nonempty(c) and is_lower_lte_upper_intervals(c) implies intersection(c) != empty
} by {
    let (a: ℝ, b: ℝ) satisfy {
        a <= b and intersection(c) = closed_interval(a, b)
    }
    is_nonempty(closed_interval(a, b))
}

define is_closed_interval_net(n: Set[Set[ℝ]]) -> Bool {
    are_closed_intervals(n) and is_net(n)
}

theorem closed_interval_net_is_lower_lte_upper_intervals(n: Set[Set[ℝ]]) {
    is_closed_interval_net(n) implies is_lower_lte_upper_intervals(n)
} by {
    forall(a1: ℝ, a2: ℝ) {
        if a1 ∈ closed_intervals_lower_end_point(n) and a2 ∈ closed_intervals_upper_end_point(n) {
            let s1: Set[ℝ] satisfy {
                s1 ∈ n and a1 = inf(s1)
            }

            elem_in_closed_intervals_upper_end_point(n, a2)
            let s2: Set[ℝ] satisfy {
                s2 ∈ n and a2 = sup(s2)
            }
            
            subset_two_intersection(n)
            let s: Set[ℝ] satisfy {
                s ∈ n and s ⊆ s1 ∩ s2
            }

            is_nonempty(s)
            let x: ℝ satisfy { x ∈ s }

            x ∈ s1
            s1 = closed_interval(inf(s1), sup(s1))
            inf(s1) <= x
            a1 <= x

            x ∈ s2
            s2 = closed_interval(inf(s2), sup(s2))
            x <= sup(s2)
            x <= a2

            a1 <= a2
        }
    }
}