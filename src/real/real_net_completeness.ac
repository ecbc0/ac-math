
from real.real_completeness import ℝ, inf, sup, have_lower_bound, have_upper_bound, directly_closely_lt_sup, directly_closely_gt_inf, intersection, have_inf, have_sup, converge, converge_to, have_seq_upper_bound, have_seq_lower_bound, is_increase, is_decrease, tail_bound
from top.metric_space import Distance_Space, Metric_Space, Point_Net_System, Topology, Distance_Net_System, Distance_Top, is_dist_vanish_net, is_bounded, are_bounded, dist_set, dist, elem_in_dist_set, Metric_Top, Complete_Distance_Top, Complete_Metric_Top, distance_space_converge_to_definition_expand_ball_imp_by
from limit.net import Set, Net, no_empty, directed, is_net, set_intersect_sets, subnet_sets, elem_in_subnet_sets, directed_helper, directed_helper_imp_by, seq_net, seq_tail, elem_in_seq_tail
from top.top_base import limit_pt, are_closed, converge_to as top_converge_to
from top.compact import is_compact, to_closure_net, to_closure
from set import elem_in_intersection_general, fn_image
from list.list_base import list_has_max, max_list, list_has_min, min_list
numerals ℝ
from nat import ℕ

define elem_in_closed_interval(a: ℝ, b: ℝ, x: ℝ) -> Bool {
    a <= x and x <= b
}

define closed_interval(a: ℝ, b: ℝ) -> Set[ℝ] {
    Set[ℝ].new(elem_in_closed_interval(a, b))
}

define is_closed_interval(s: Set[ℝ]) -> Bool {
    exists(a: ℝ, b: ℝ) {
        a <= b and s = closed_interval(a, b)
    }
}

theorem closed_interval_is_nonempty(s: Set[ℝ]) {
    is_closed_interval(s) implies (s).is_nonempty
} by {
    let (a: ℝ, b: ℝ) satisfy {
        a <= b and s = closed_interval(a, b)
    }
    let x: ℝ satisfy { a <= x and x <= b }
    elem_in_closed_interval(a, b, x)
    x ∈ closed_interval(a, b)
    x ∈ s
}

theorem end_point_in_closed_interval(a: ℝ, b: ℝ) {
    a <= b implies (
        a ∈ closed_interval(a, b) and b ∈ closed_interval(a, b)
    )
} by {
    a ∈ closed_interval(a, b)
    b ∈ closed_interval(a, b)
}

theorem end_point_order_imp_subset_order(a1: ℝ, b1: ℝ, a2: ℝ, b2: ℝ) {
    (a1 <= b1 and a2 <= b2) implies (
        a1 >= a2 and b1 <= b2 implies closed_interval(a1, b1) ⊆ closed_interval(a2, b2)
    )
} by {
    if a1 >= a2 and b1 <= b2 {
        forall(x: ℝ) {
            if x ∈ closed_interval(a1, b1) {
                a1 <= x
                x <= b1
                a2 <= x
                x <= b2
                x ∈ closed_interval(a2, b2)
            }
        }
        closed_interval(a1, b1) ⊆ closed_interval(a2, b2)
    }
}

theorem subset_order_imp_end_point_order_imp(a1: ℝ, b1: ℝ, a2: ℝ, b2: ℝ) {
    (a1 <= b1 and a2 <= b2) implies (
        closed_interval(a1, b1) ⊆ closed_interval(a2, b2) implies  a1 >= a2 and b1 <= b2
    )
} by {
    if closed_interval(a1, b1) ⊆ closed_interval(a2, b2) {
        a1 ∈ closed_interval(a1, b1)
        a1 ∈ closed_interval(a2, b2)
        a1 >= a2
        b1 ∈ closed_interval(a1, b1)
        b1 ∈ closed_interval(a2, b2)
        b1 <= b2 
        a1 >= a2 and b1 <= b2
    }
}

theorem interval_have_inf_sup(s: Set[ℝ]) {
    is_closed_interval(s) implies (s).is_nonempty and have_lower_bound(s) and have_upper_bound(s)
} by {
    let (a: ℝ, b: ℝ) satisfy {
        a <= b and s = closed_interval(a, b)
    }
    a ∈ s
    b ∈ s
    (s).is_nonempty
    forall(x: ℝ) {
        if x ∈ s {
            x ∈ closed_interval(a, b)
            a <= x
        }
    }
    a.is_set_lower_bound(s)
    forall(x: ℝ) {
        if x ∈ s {
            x ∈ closed_interval(a, b)
            x <= b
        }
    }
    b.is_set_upper_bound(s)
    have_lower_bound(s)
    have_upper_bound(s)
}

theorem end_point_is_inf_sup(s: Set[ℝ]) {
    is_closed_interval(s) implies s = closed_interval(inf(s), sup(s))
} by {
    let (a: ℝ, b: ℝ) satisfy {
        a <= b and s = closed_interval(a, b)
    }
    a ∈ s
    b ∈ s
    inf(s).is_set_greatest_lower_bound(s)
    sup(s).is_set_least_upper_bound(s)
    inf(s) <= a
    b <= sup(s)

    if inf(s) < a {
        a > inf(s)
        let x: ℝ satisfy { 
            x ∈ s and inf(s) <= x and x < a
        }
        x ∈ closed_interval(a, b)
        a <= x
        false
    }

    inf(s) = a

    if b < sup(s) {
        let x: ℝ satisfy { 
            x ∈ s and x <= sup(s) and b < x
        }
        x ∈ closed_interval(a, b)
        x <= b
        false
    }

    sup(s) = b
}

theorem inf_sup_in_closed_interval(s: Set[ℝ]) {
    is_closed_interval(s) implies (
        inf(s) ∈ s and sup(s) ∈ s
    )
} by {
    inf(s) <= sup(s)
    s = closed_interval(inf(s), sup(s))
}

define distance(x: ℝ, y: ℝ) -> ℝ {
    (x - y).abs
}

theorem self_distance_is_zero(x: ℝ) {
    distance(x, x) = 0
}

theorem dist_zero_imp_eq(x: ℝ, y: ℝ) {
    distance(x, y) = 0 implies x = y
}

theorem symmetric(x: ℝ, y: ℝ) {
    distance(x, y) = distance(y, x)
}

theorem triangle(x: ℝ, y: ℝ, z: ℝ) {
    distance(x, z) <= distance(x, y) + distance(y, z)
} by {
    x - z = x + (-y + y) + -z
    x - z = (x - y) + (y - z) 
    (x - z).abs <= (x - y).abs + (y - z).abs
}

instance ℝ: Distance_Space {
    let distance = distance
}

instance ℝ: Metric_Space
instance ℝ: Point_Net_System {
    let net = function(x: ℝ) {
        Net.new(ℝ.ball_net(x))
    }
}
instance ℝ: Distance_Net_System
instance ℝ: Topology
instance ℝ: Distance_Top
instance ℝ: Metric_Top

theorem inf_in_closed_set(s: Set[ℝ]) {
    s.is_closed and have_inf(s) implies inf(s) ∈ s
} by {
    forall(t: Set[ℝ]) {
        if t ∈ inf(s).net {
            let ε: ℝ satisfy {
                ε > 0 and t = inf(s).ball(ε)
            }
            let x: ℝ satisfy {
                x ∈ s and inf(s) <= x and x < inf(s) + ε
            }
            x - inf(s) >= 0
            x - inf(s) < ε
            (inf(s) - x).abs < ε
            inf(s).distance(x) < ε
            x ∈ inf(s).ball(ε)
            x ∈ t
            x ∈ s ∩ t
            s ∩ t != Set[ℝ].empty_set
        }
    }
    limit_pt(s, inf(s))
    s.closure = s
    inf(s) ∈ s
}

theorem sup_in_closed_set(s: Set[ℝ]) {
    s.is_closed and have_sup(s) implies sup(s) ∈ s
} by {
    forall(t: Set[ℝ]) {
        if t ∈ sup(s).net {
            let ε: ℝ satisfy {
                ε > 0 and t = sup(s).ball(ε)
            }
            let x: ℝ satisfy {
                x ∈ s and sup(s) - ε < x and x <= sup(s) 
            }
            sup(s) - x >= 0
            sup(s) < x + ε
            sup(s) - x < ε
            (sup(s) - x).abs < ε
            sup(s).distance(x) < ε
            x ∈ sup(s).ball(ε)
            x ∈ t
            x ∈ s ∩ t
            s ∩ t != Set[ℝ].empty_set
        }
    }
    limit_pt(s, sup(s))
    s.closure = s
    sup(s) ∈ s
}

theorem inf_closure(a: Set[ℝ]) {
    have_inf(a) implies have_inf(a.closure) and inf(a.closure) = inf(a)
} by {
    forall(x: ℝ) {
        if x ∈ a.closure {
            forall(ε: ℝ) {
                if ε > 0 {
                    x.ball_net = x.net.sets
                    x.ball(ε) ∈ x.net
                    (x.ball(ε) ∩ a).is_nonempty
                    let y: ℝ satisfy { y ∈ x.ball(ε) ∩ a }
                    y ∈ x.ball(ε)
                    y ∈ a
                    x.distance(y) < ε
                    (y - x).abs < ε
                    y - x < ε
                    y < x + ε
                    inf(a) <= y
                    inf(a) < x + ε
                }
            }
            inf(a) <= x
        }
    }
    inf(a).is_set_lower_bound(a.closure)
    (a).is_nonempty
    (a.closure).is_nonempty
    have_inf(a.closure)
    inf(a) <= inf(a.closure)
    a ⊆ a.closure
    inf(a) >= inf(a.closure)
    inf(a) = inf(a.closure)
}

theorem sup_closure(a: Set[ℝ]) {
    have_sup(a) implies have_sup(a.closure) and sup(a.closure) = sup(a)
} by {
    forall(x: ℝ) {
        if x ∈ a.closure {
            forall(ε: ℝ) {
                if ε > 0 {
                    x.ball_net = x.net.sets
                    x.ball(ε) ∈ x.net
                    (x.ball(ε) ∩ a).is_nonempty
                    let y: ℝ satisfy { y ∈ x.ball(ε) ∩ a }
                    y ∈ x.ball(ε)
                    y ∈ a
                    x.distance(y) < ε
                    (x - y).abs < ε
                    x < y + ε
                    y <= sup(a)
                    x < sup(a) + ε
                }
            }
            x <= sup(a)
        }
    }
    sup(a).is_set_upper_bound(a.closure)
    (a).is_nonempty
    (a.closure).is_nonempty
    have_sup(a.closure)
    sup(a) >= sup(a.closure)
    a ⊆ a.closure
    sup(a) <= sup(a.closure)
    sup(a) = sup(a.closure)
}

theorem bounded_closed_set_contains_subset_inf(a: Set[ℝ], b: Set[ℝ]) {
    b.is_closed and a ⊆ b and have_inf(a) implies inf(a) ∈ b
} by {
    a.closure ⊆ b.closure
    b.closure = b
    inf(a) = inf(a.closure)
    a.closure.is_closed
    inf(a.closure) ∈ a.closure
    inf(a.closure) ∈ b
}

theorem bounded_closed_set_contains_subset_sup(a: Set[ℝ], b: Set[ℝ]) {
    b.is_closed and a ⊆ b and have_sup(a) implies sup(a) ∈ b
} by {
    a.closure ⊆ b.closure
    b.closure = b
    sup(a) = sup(a.closure)
    a.closure.is_closed
    sup(a.closure) ∈ a.closure
    sup(a.closure) ∈ b
}

theorem in_closed_interval_imp_gte_lower_end_point(s: Set[ℝ], x: ℝ) {
    is_closed_interval(s) and x ∈ s implies x >= inf(s)
}

theorem in_closed_interval_imp_lte_upper_end_point(s: Set[ℝ], x: ℝ) {
    is_closed_interval(s) and x ∈ s implies x <= sup(s)
}

define are_closed_intervals(c: Set[Set[ℝ]]) -> Bool {
    forall(s: Set[ℝ]) {
        s ∈ c implies is_closed_interval(s)
    }
}

define comparable(a: Set[ℝ], b: Set[ℝ]) -> Bool {
    a ⊆ b or b ⊆ a
}

define is_chain(c: Set[Set[ℝ]]) -> Bool {
    forall(a: Set[ℝ], b: Set[ℝ]) {
        a ∈ c and b ∈ c implies comparable(a, b)
    }
}

define is_closed_interval_chain(c: Set[Set[ℝ]]) -> Bool {
    is_chain(c) and are_closed_intervals(c)
}

define elem_in_lower_end_point(c: Set[Set[ℝ]], x: ℝ) -> Bool {
    exists(s: Set[ℝ]) {
        s ∈ c and x = inf(s)
    }
}

define elem_in_upper_end_point(c: Set[Set[ℝ]], x: ℝ) -> Bool {
    exists(s: Set[ℝ]) {
        s ∈ c and x = sup(s)
    }
}

define lower_end_point(c: Set[Set[ℝ]]) -> Set[ℝ] {
    Set[ℝ].new(elem_in_lower_end_point(c))
}

define upper_end_point(c: Set[Set[ℝ]]) -> Set[ℝ] {
    Set[ℝ].new(elem_in_upper_end_point(c))
}

define lower_lte_upper(c: Set[Set[ℝ]]) -> Bool {
    forall(l: ℝ, u: ℝ) {
        l ∈ lower_end_point(c) and u ∈ upper_end_point(c) implies l <= u 
    }
}

define is_lower_lte_upper_intervals(c: Set[Set[ℝ]]) -> Bool {
    are_closed_intervals(c) and lower_lte_upper(c)
}

theorem closed_interval_chain_imp_lower_lte_upper(c: Set[Set[ℝ]]) {
    is_closed_interval_chain(c) implies is_lower_lte_upper_intervals(c)
} by {
    let ls = lower_end_point(c)
    let us = upper_end_point(c)
    forall(a1: ℝ, a2: ℝ) {
        if a1 ∈ lower_end_point(c) and a2 ∈ upper_end_point(c) {
            elem_in_lower_end_point(c, a1)
            let s1: Set[ℝ] satisfy {
                s1 ∈ c and a1 = inf(s1)
            }
            elem_in_upper_end_point(c, a2)
            let s2: Set[ℝ] satisfy {
                s2 ∈ c and a2 = sup(s2)
            }
            if s1 ⊆ s2 {
                inf(s1) ∈ s1
                a1 ∈ s1
                a1 ∈ s2
                a1 <= sup(s2)
                inf(s1) <= sup(s2)
                a1 <= a2
            } else {
                s2 ⊆ s1
                sup(s2) ∈ s2
                a2 ∈ s2
                a2 ∈ s1
                is_closed_interval(s1)
                inf(s1) <= a2
                inf(s1) <= sup(s2)
                a1 <= a2
            }
            a1 <= a2
        }
    }
}

theorem bounded_imp_have_lower_upper_bound(s: Set[ℝ]) {
    (s).is_nonempty and is_bounded(s) implies have_lower_bound(s) and have_upper_bound(s)
} by {
    let r: ℝ satisfy {
        r = sup(dist_set(s))
    }
    let x: ℝ satisfy { x ∈ s }
    forall(y: ℝ) {
        if y ∈ s {
            x - y <= x.distance(y)
            y - x <= x.distance(y)
            x.distance(y) ∈ dist_set(s)
            x.distance(y) <= r
            x - y <= r
            y >= x - r
            y - x <= r
            y <= x + r
            x - r <= y and y <= x + r
        }
    }
    (x - r).is_set_lower_bound(s)
    (x + r).is_set_upper_bound(s)
}

theorem bounded_imp_have_inf_sup(s: Set[ℝ]) {
    (s).is_nonempty and is_bounded(s) implies have_inf(s) and have_sup(s)
}

theorem have_lower_upper_bound_imp_bounded(s: Set[ℝ]) {
    (s).is_nonempty and have_lower_bound(s) and have_upper_bound(s) implies is_bounded(s) 
} by {
    let l: ℝ satisfy { l.is_set_lower_bound(s) }
    let u: ℝ satisfy { u.is_set_upper_bound(s) }
    l <= u
    forall(r: ℝ) {
        if r ∈ dist_set(s) {
            elem_in_dist_set(s, r)
            let (x: ℝ, y: ℝ) satisfy {
                x ∈ s and y ∈ s and r = x.distance(y)
            }
            x >= l
            x <= u
            y >= l
            y <= u
            if x >= y {
                x - y >= 0
                (x - y).abs = x - y
                -y <= -l
                x + -y <= u + -l
                x - y <= u - l
                (x - y).abs <= u - l
            } else {
                x < y
                y - x > 0
                (x - y).abs = y - x
                -x <= -l
                y + -x <= u + -l
                y - x <= u - l
                (x - y).abs <= u - l
            }
            (x - y).abs <= u - l
            x.distance(y) <= u - l
            r <= u - l
        }
    }
    (u - l).is_set_upper_bound(dist_set(s))
    have_sup(dist_set(s))
}

theorem have_inf_sup_imp_bounded(s: Set[ℝ]) {
    (s).is_nonempty and have_inf(s) and have_sup(s) implies is_bounded(s) 
}

theorem closed_intervals_are_bounded(c: Set[Set[ℝ]]) {
    are_closed_intervals(c) implies are_bounded(c)
}

theorem net_imp_lower_lte_upper(c: Set[Set[ℝ]]) {
    is_net(c) and are_bounded(c) implies lower_lte_upper(c)
} by {
    let ls = lower_end_point(c)
    let us = upper_end_point(c)
    forall(a1: ℝ, a2: ℝ) {
        if a1 ∈ lower_end_point(c) and a2 ∈ upper_end_point(c) {
            elem_in_lower_end_point(c, a1)
            let s1: Set[ℝ] satisfy {
                s1 ∈ c and a1 = inf(s1)
            }
            elem_in_upper_end_point(c, a2)
            let s2: Set[ℝ] satisfy {
                s2 ∈ c and a2 = sup(s2)
            }
            let s: Set[ℝ] satisfy {
                s ∈ c and s ⊆ s1 and s ⊆ s2
            }
            let x: ℝ satisfy { x ∈ s }
            have_inf(s1)
            x ∈ s1
            inf(s1) <= x 
            a1 <= x
            x ∈ s2
            have_sup(s2)
            x <= sup(s2)
            x <= a2
            a1 <= a2
        }
    }    
}

theorem lower_lte_upper_imp_lower_end_point_have_upper_bound(c: Set[Set[ℝ]]) {
    (c).is_nonempty and are_bounded(c) and lower_lte_upper(c) implies have_upper_bound(lower_end_point(c))
} by {
    let s: Set[ℝ] satisfy { s ∈ c }
    sup(s) ∈ upper_end_point(c)
    let ls = lower_end_point(c)
    forall(x: ℝ) {
        if x ∈ ls {
            x <= sup(s)
        }
    }
    sup(s).is_set_upper_bound(ls)
}

theorem lower_lte_upper_imp_upper_end_point_have_lower_bound(c: Set[Set[ℝ]]) {
    (c).is_nonempty and are_bounded(c) and lower_lte_upper(c) implies have_lower_bound(upper_end_point(c))
} by {
    let s: Set[ℝ] satisfy { s ∈ c }
    inf(s) ∈ lower_end_point(c)
    let us = upper_end_point(c)
    forall(x: ℝ) {
        if x ∈ us {
            inf(s) <= x
        }
    }
    inf(s).is_set_lower_bound(us)
}

theorem lower_lte_upper_imp_lower_end_point_is_nonempty(c: Set[Set[ℝ]]) {
    (c).is_nonempty and are_bounded(c) implies (lower_end_point(c)).is_nonempty
} by {
    let s: Set[ℝ] satisfy { s ∈ c }
    inf(s) ∈ lower_end_point(c)
}

theorem lower_lte_upper_intervals_upper_end_point_is_nonempty(c: Set[Set[ℝ]]) {
    (c).is_nonempty and are_bounded(c) implies (upper_end_point(c)).is_nonempty
} by {
    let s: Set[ℝ] satisfy { s ∈ c }
    sup(s) ∈ upper_end_point(c)
}

theorem lower_lte_upper_imp_lower_end_point_have_sup(c: Set[Set[ℝ]]) {
    (c).is_nonempty and are_bounded(c) and lower_lte_upper(c) implies have_sup(lower_end_point(c))
}

theorem lower_lte_upper_imp_upper_end_point_have_inf(c: Set[Set[ℝ]]) {
    (c).is_nonempty and are_bounded(c) and lower_lte_upper(c) implies have_inf(upper_end_point(c))
}

theorem lower_lte_upper_imp_lower_sup_lte_upper_inf(c: Set[Set[ℝ]]) {
    (c).is_nonempty and are_bounded(c) and lower_lte_upper(c) implies (
        sup(lower_end_point(c)) <= inf(upper_end_point(c))
    )
} by {
    let ls = lower_end_point(c)
    let us = upper_end_point(c)
    forall(l: ℝ) {
        if l ∈ ls {
            forall(u: ℝ) {
                u ∈ us implies l <= u
            }
            l.is_set_lower_bound(us)
            l <= inf(us)
        }
    }
    inf(us).is_set_upper_bound(ls)
    sup(ls) <= inf(us)
}

theorem closed_interval_intersection(c: Set[Set[ℝ]]) {
    (c).is_nonempty and is_lower_lte_upper_intervals(c) implies intersection(c) = closed_interval(
        sup(lower_end_point(c)), 
        inf(upper_end_point(c))
    )
} by {
    let ls = lower_end_point(c)
    let us = upper_end_point(c)
    let a = sup(ls)
    let b = inf(us)
    are_bounded(c)
    a <= b
    forall(s: Set[ℝ]) {
        if s ∈ c {
            inf(s) ∈ lower_end_point(c)
            inf(s) ∈ ls
            sup(s) ∈ upper_end_point(c)
            sup(s) ∈ us
            inf(s) <= a
            inf(us) <= sup(s)
            b <= sup(s)
            s = closed_interval(inf(s), sup(s))
            closed_interval(a, b) ⊆ s
        }
    }
    closed_interval(a, b) ⊆ intersection(c)

    forall(x: ℝ) {
        if x ∈ intersection(c) {
            if x < a {
                x < sup(ls)
                sup(ls).is_set_least_upper_bound(ls)
                let l: ℝ satisfy { l ∈ ls and x < l }
                l ∈ lower_end_point(c)
                elem_in_lower_end_point(c, l)
                let s_l: Set[ℝ] satisfy {
                    s_l ∈ c and l = inf(s_l)
                }
                not l <= x
                is_closed_interval(s_l)
                not x ∈ s_l
                not x ∈ intersection(c)
                false
            }
            a <= x
            if x > b {
                x > inf(us)
                inf(us).is_set_greatest_lower_bound(us)
                let u: ℝ satisfy { u ∈ us and x > u }
                u ∈ upper_end_point(c)
                elem_in_upper_end_point(c, u)
                let s_u: Set[ℝ] satisfy {
                    s_u ∈ c and u = sup(s_u)
                }
                not x <= u
                is_closed_interval(s_u)
                not x ∈ s_u
                not x ∈ intersection(c)
                false
            }
            x <= b
            x ∈ closed_interval(a, b)
        }
    }
    intersection(c) ⊆ closed_interval(a, b)
    intersection(c) = closed_interval(a, b)
}

theorem closed_interval_intersection_theorem(c: Set[Set[ℝ]]) {
    (c).is_nonempty and is_lower_lte_upper_intervals(c) implies intersection(c) != Set[ℝ].empty_set
} by {
    let (a: ℝ, b: ℝ) satisfy {
        a <= b and intersection(c) = closed_interval(a, b)
    }
    (closed_interval(a, b)).is_nonempty
}

define is_closed_interval_net(n: Set[Set[ℝ]]) -> Bool {
    are_closed_intervals(n) and is_net(n)
}

theorem closed_interval_net_is_lower_lte_upper_intervals(n: Set[Set[ℝ]]) {
    is_closed_interval_net(n) implies is_lower_lte_upper_intervals(n)
}

theorem bounded_net_intersection_contains_lower_end_point_sup(n: Set[Set[ℝ]]) {
    is_net(n) and are_closed(n) and are_bounded(n) implies sup(lower_end_point(n)) ∈ intersection(n)
} by {
    lower_lte_upper(n)
    let ls = lower_end_point(n)
    forall(b0: Set[ℝ]) {
        if b0 ∈ n {
            define elem_in_subnet_inf(r: ℝ) -> Bool {
                exists(b: Set[ℝ]) {
                    b ∈ n and b ⊆ b0 and r = inf(b)
                }
            }
            let s = Set[ℝ].new(elem_in_subnet_inf)
            inf(b0) ∈ s
            (s).is_nonempty
            forall(r: ℝ) {
                if r ∈ s {
                    elem_in_subnet_inf(r)
                    let b: Set[ℝ] satisfy {
                        b ∈ n and b ⊆ b0 and r = inf(b)
                    }
                    have_inf(b0)
                    inf(b0) <= inf(b)
                    inf(b0) <= r
                    inf(b) ∈ b
                    r ∈ b
                    r ∈ b0
                    r ∈ lower_end_point(n)
                    r ∈ ls
                    inf(b0) <= r and r ∈ b0 and r ∈ ls
                }
            }
            s ⊆ b0
            b0.is_closed
            sup(s) ∈ b0
            
            s ⊆ ls
            sup(s) <= sup(ls)

            forall(l: ℝ) {
                if l ∈ ls {
                    l ∈ lower_end_point(n)
                    elem_in_lower_end_point(n, l)
                    let b1: Set[ℝ] satisfy {
                        b1 ∈ n and l = inf(b1)
                    }
                    directed_helper_imp_by(n)
                    let b: Set[ℝ] satisfy {
                        b ∈ n and b ⊆ b0 and b ⊆ b1
                    }
                    b ⊆ b0
                    inf(b) ∈ s
                    inf(b) <= sup(s)
                    b ⊆ b1
                    have_inf(b1)
                    inf(b1) <= inf(b)
                    inf(b1) <= sup(s)
                    l <= sup(s)
                }
            }
            sup(s).is_set_upper_bound(ls)
            sup(ls) <= sup(s)
            sup(ls) = sup(s)

            sup(ls) ∈ b0
        }
    }
    sup(ls) ∈ intersection(n)
}

theorem bounded_net_intersection_theorem(n: Set[Set[ℝ]]) {
    is_net(n) and are_closed(n) and are_bounded(n) implies (intersection(n)).is_nonempty
}

theorem real_bounded_closed_set_is_compact(s: Set[ℝ]) {
    s.is_closed and is_bounded(s) implies is_compact(s)
} by {
    forall(n: Set[Set[ℝ]]) {
        if (n).is_nonempty and is_net(n) and are_closed(n) and set_intersect_sets(n, s) {
            forall(sub: Set[ℝ]) {
                if sub ∈ subnet_sets(n, s) {
                    elem_in_subnet_sets(n, s, sub)
                    let (t: Set[ℝ]) satisfy {
                        t ∈ n and sub = s ∩ t
                    }
                    (sub).is_nonempty
                    t.is_closed
                    (s ∩ t).is_closed
                    sub.is_closed

                    sub ⊆ s
                    (s).is_nonempty
                    have_inf(sub)
                    have_sup(sub)
                    is_bounded(sub)

                    sub.is_closed and is_bounded(sub)
                }
            }
            are_closed(subnet_sets(n, s))
            are_bounded(subnet_sets(n, s))
            (intersection(subnet_sets(n, s))).is_nonempty
            forall(x: ℝ) {
                if x ∈ intersection(subnet_sets(n, s)) {
                    let non_empty: Set[ℝ] satisfy { non_empty ∈ n }
                    non_empty ∩ s ∈ subnet_sets(n, s)
                    (subnet_sets(n, s)).is_nonempty
                    let a: Set[ℝ] satisfy { a ∈ subnet_sets(n, s) }
                    elem_in_subnet_sets(n, s, a)
                    let b: Set[ℝ] satisfy { b ∈ n and a = s ∩ b }
                    x ∈ a
                    x ∈ s
                    forall(t: Set[ℝ]) {
                        if t ∈ n {
                            s ∩ t ∈ subnet_sets(n, s)
                            x ∈ s ∩ t
                            x ∈ t
                        }
                    }
                    elem_in_intersection_general(n, x)
                    x ∈ intersection(n)
                    x ∈ s and x ∈ intersection(n)
                    x ∈ s ∩ intersection(n)
                }
            }
            intersection(subnet_sets(n, s)) ⊆ s ∩ intersection(n)
            (s ∩ intersection(n)).is_nonempty
        } 
    }
}

theorem real_bounded_dist_vanish_net_converge(n: Net[ℝ]) {
    is_dist_vanish_net(n) and are_bounded(n.sets) implies exists(x: ℝ) { (n).finer(x.net) }
} by {
    (intersection(to_closure_net(n).sets)).is_nonempty
    let x: ℝ satisfy { x ∈ intersection(to_closure_net(n).sets) }
    forall(b: Set[ℝ]) {
        if b ∈ x.net {
            let ε: ℝ satisfy { ε > 0 and b = x.ball(ε) }
            let a: Set[ℝ] satisfy {
                a ∈ n and is_bounded(a) and dist(a) < ε
            }
            a.closure ∈ to_closure(n.sets)
            a.closure ∈ to_closure_net(n).sets
            a.closure ∈ to_closure_net(n)
            x ∈ a.closure
            (a).is_nonempty
            (a.closure).is_nonempty
            is_bounded(a.closure)
            dist(a) = dist(a.closure)
            dist(a.closure) < ε
            forall(y: ℝ) {
                if y ∈ a {
                    y ∈ a.closure
                    x.distance(y) ∈ dist_set(a.closure)
                    x.distance(y) <= sup(dist_set(a.closure))
                    x.distance(y) <= dist(a.closure)
                    x.distance(y) < ε
                    y ∈ x.ball(ε)
                }
            }
            a ⊆ x.ball(ε)
            a ⊆ b
            a ∈ n and a ⊆ b
        }
    }
    (n).finer(x.net)
}

/// also called "Cauchy net/sequence converge"
theorem real_dist_vanish_net_converge(n: Net[ℝ]) {
    is_dist_vanish_net(n) implies exists(x: ℝ) { (n).finer(x.net) }
} by {
    let sub_n: Net[ℝ] satisfy {
        are_bounded(sub_n.sets) and is_dist_vanish_net(sub_n) and (sub_n).same_limit(n)
    }
    let x: ℝ satisfy {
        (sub_n).finer(x.net)
    }
    (n).finer(sub_n)
    (n).finer(x.net)
}

instance ℝ: Complete_Distance_Top
instance ℝ: Complete_Metric_Top

theorem converge_imp_bounded(f: ℕ -> ℝ) {
    converge(f) implies is_bounded(fn_image(f))
} by {
    let a: ℝ satisfy {
        converge_to(f, a)
    }
    let (n: ℕ) satisfy {
        forall(m: ℕ) {
            m > n implies (f(m) - a).abs < 1
        }
    }
    list_has_max(n.suc.range.map(f), 0)
    list_has_min(n.suc.range.map(f), 0)
    let u0 = max_list(n.suc.range.map(f), 0)
    let l0 = min_list(n.suc.range.map(f), 0)
    let u = u0.max(1 + a)
    let l = l0.min(-1 + a)
    fn_image(f).is_nonempty
    forall(r: ℝ) {
        if r ∈ fn_image(f) {
            let m: ℕ satisfy {
                r = f(m)
            }
            if m <= n {
                m ∈ n.suc.range
                f(m) ∈ n.suc.range.map(f)
                f(m) <= u0
                f(m) <= u
                l0 <= f(m)
                l <= f(m)
                l <= r and r <= u
            } else {
                m > n
                f(m) - a < 1
                f(m) < 1 + a
                1 + a <= u
                f(m) <= u
                -1 < f(m) - a
                -1 + a < f(m)
                l <= -1 + a
                l <= f(m)
                l <= r and r <= u
            }
            l <= r and r <= u
        }
    }
    l.is_set_lower_bound(fn_image(f))
    u.is_set_upper_bound(fn_image(f))
}

theorem increase_convergence_to_sup(f: ℕ -> ℝ) {
    is_increase(f) and converge(f) implies have_sup(fn_image(f)) and converge_to(f, sup(fn_image(f)))
} by {
    have_upper_bound(fn_image(f))
    fn_image(f).is_nonempty
    have_sup(fn_image(f))
    have_seq_upper_bound(f)
    converge_to(f, sup(fn_image(f)))
}

theorem decrease_convergence_to_inf(f: ℕ -> ℝ) {
    is_decrease(f) and converge(f) implies have_inf(fn_image(f)) and converge_to(f, inf(fn_image(f)))
} by {
    have_lower_bound(fn_image(f))
    fn_image(f).is_nonempty
    have_inf(fn_image(f))
    have_seq_lower_bound(f)
    converge_to(f, inf(fn_image(f)))
}

theorem real_converge_imp_top_converge(f: ℕ -> ℝ, a: ℝ) {
    converge_to(f, a) implies top_converge_to(seq_net, a, f)
} by {
    forall(ε: ℝ) { 
        if ε > 0 {
            let (n: ℕ) satisfy {
                tail_bound(f, a, n, ε)
            }
            let t = seq_tail(n.suc)
            t ∈ seq_net
            forall(x: ℝ) {
                if x ∈ t.image(f) {
                    let m: ℕ satisfy {
                        m ∈ t and x = f(m)
                    }
                    m ∈ seq_tail(n.suc)
                    m >= n.suc
                    m > n
                    (f(m) - a).abs < ε
                    a.distance(f(m)) < ε
                    f(m) ∈ a.ball(ε)
                    x ∈ a.ball(ε)
                }
            }
            t.image(f) ⊆ a.ball(ε)
            t ∈ seq_net and t.image(f) ⊆ a.ball(ε)
        } 
    }
    distance_space_converge_to_definition_expand_ball_imp_by(seq_net, a, f)
}

theorem top_converge_imp_real_converge(f: ℕ -> ℝ, a: ℝ) {
    top_converge_to(seq_net, a, f) implies converge_to(f, a)
} by {
    forall(ε: ℝ) {
        if ε > 0 {
            let t: Set[ℕ] satisfy {
                t ∈ seq_net and t.image(f) ⊆ a.ball(ε)
            }
            let n: ℕ satisfy {
                t = seq_tail(n)
            }
            forall(m: ℕ) {
                if m > n {
                    m ∈ seq_tail(n)
                    m ∈ t
                    f(m) ∈ a.ball(ε)
                    a.distance(f(m)) < ε
                    (f(m) - a).abs < ε
                }
            }
            tail_bound(f, a, n, ε)
        }
    }
}