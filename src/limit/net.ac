from finite_set import Set, List, list_to_set, intersection_of_list_recursion, intersection_of_list, sets_of_finite_intersection, is_set_of_finite_intersection
from set import intersection, elem_in_intersection_general
from order import Partial_Order, Linear_Order, is_acyclic, is_transitive, is_reflexive, is_antisymmetric, is_nonreflexive, lte_from, lt_from, lte_to_lt_partial_order, Partial_Order_Lte
from nat import ℕ
from list.list_base import flatten, max_list
numerals ℕ

// And now Acorn not support direct subtype and dependent type. Once they are support, we can make the set c: Set[Set[K]], c.is_chain in to type 

// Subtype make type and set almost the same thing, i.e. for a: Set[K], we have subtype { x: T | x ∈ a }

define no_empty[K](sets: Set[Set[K]]) -> Bool {
    forall(a: Set[K]) {
        a ∈ sets implies a != Set[K].empty_set
    }    
}

define directed[K](sets: Set[Set[K]]) -> Bool {
    forall(a1: Set[K], a2: Set[K]) {
        a1 ∈ sets and a2 ∈ sets implies exists(b: Set[K]) {
            b ∈ sets and b ⊆ a1 and b ⊆ a2
        }
    }    
}

theorem directed_helper[K](sets: Set[Set[K]]) {
    forall(a1: Set[K], a2: Set[K]) {
        a1 ∈ sets and a2 ∈ sets implies exists(b: Set[K]) {
            b ∈ sets and b ⊆ a1 and b ⊆ a2
        }
    } implies directed(sets) 
}

theorem directed_helper_ver_intersection[K](sets: Set[Set[K]]) {
    forall(a1: Set[K], a2: Set[K]) {
        a1 ∈ sets and a2 ∈ sets implies exists(b: Set[K]) {
            b ∈ sets and b ⊆ a1 ∩ a2
        }
    } implies directed(sets) 
} by {
    forall(a1: Set[K], a2: Set[K]) {
        if a1 ∈ sets and a2 ∈ sets {
            let (b: Set[K]) satisfy {
                b ∈ sets and b ⊆ a1 ∩ a2
            }
            b ∈ sets and b ⊆ a1 and b ⊆ a2
        }
    }
}

theorem directed_helper_imp_by[T](sets: Set[Set[T]]) {
    directed(sets) implies (
        forall(a1: Set[T], a2: Set[T]) {
            a1 ∈ sets and a2 ∈ sets implies exists(b: Set[T]) {
                b ∈ sets and b ⊆ a1 and b ⊆ a2
            }
        } 
    )
} 

theorem directed_helper_imp_by_ver_intersection[T](sets: Set[Set[T]]) {
    directed(sets) implies (
        forall(a1: Set[T], a2: Set[T]) {
            a1 ∈ sets and a2 ∈ sets implies exists(b: Set[T]) {
                b ∈ sets and b ⊆ a1 ∩ a2
            }
        } 
    )
} by {
    forall(a1: Set[T], a2: Set[T]) {
        if a1 ∈ sets and a2 ∈ sets { 
            let (b: Set[T]) satisfy {
                b ∈ sets and b ⊆ a1 and b ⊆ a2
            }
            b ∈ sets and b ⊆ a1 ∩ a2
        }
    } 
}

/// Topology doesn't seem to provide a sufficient motivation for using the concept of a net, but the definitions of measure and integral should.
define is_net[K](sets: Set[Set[K]]) -> Bool {
    no_empty(sets) and directed(sets)
}

structure Net[K] {
    sets: Set[Set[K]]
} constraint {
    is_net(sets)
} by {
    let x: K satisfy { true }
    let s = Set[K].singleton(x)
    let n = Set[Set[K]].singleton(s)
    forall(a: Set[K]) {
        if a ∈ n {
            a = s
            s != Set[K].empty_set
            a != Set[K].empty_set
        }
    }
    no_empty(n)
    forall(a1: Set[K], a2: Set[K]) {
        if a1 ∈ n and a2 ∈ n {
            a1 = s
            a2 = s
            let b = s
            b ∈ n
            b ⊆ a1 ∩ a2
            b ∈ n and b ⊆ a1 ∩ a2
        }
    }
    directed(n)
}

attributes Net[K] {
    define contains(self, s: Set[K]) -> Bool {
        self.sets.contains(s)
    }
}

theorem equivalent_of_contains[K](n: Net[K], s: Set[K]) {
    s ∈ n iff s ∈ n.sets
} 

theorem net_new_helper[K](n: Net[K], n_sets: Set[Set[K]], s: Set[K]) {
    is_net(n_sets) and n = Net[K].new(n_sets) implies (
        s ∈ n iff s ∈ n_sets
    )
} by {
    Net[K].new(n_sets).sets = n_sets
    n.sets = n_sets
    s ∈ n implies s ∈ n_sets
    s ∈ n_sets implies s ∈ n
}

theorem net_contains_imp_nonempty[K](n: Net[K], s: Set[K]) {
    s ∈ n implies (s).is_nonempty
} 

theorem net_contains_imp_directed[K](n: Net[K], a1: Set[K], a2: Set[K]) {
    a1 ∈ n and a2 ∈ n implies exists(b: Set[K]) {
        b ∈ n and b ⊆ a1 ∩ a2
    }
} by {
    is_net(n.sets)
    a1 ∈ n.sets
    a2 ∈ n.sets
    directed_helper_imp_by(n.sets)
    let (b: Set[K]) satisfy {
        b ∈ n.sets and b ⊆ a1 ∩ a2
    }
    b ∈ n
    b ∈ n and b ⊆ a1 ∩ a2
}

theorem two_intersection_nonempty_in_net[K](n: Net[K], a1: Set[K], a2: Set[K]) {
    a1 ∈ n and a2 ∈ n implies (a1 ∩ a2).is_nonempty
} by {
    let (b: Set[K]) satisfy {
        b ∈ n and b ⊆ a1 ∩ a2
    }    
    (b).is_nonempty
}

typeclass N: Directed extends Partial_Order {
    directed(a: N, b: N) {
        exists(c: N) {
            c <= a and c <= b
            // note that when it's not linear order, we can't just use c = a or c = b
        }
    }
}

// // to define finer we need two differnt Directed instance extends a same Partial_Order instance ... and dependent type? 
// attributes N: Directed {
//     define finer[M: Directed] -> Bool {
//         forall(b: M) {
//             exists(a) {
//                 a <= b
//             }
//         }
//     }

//     define same_limit(self, other: N) -> Bool {
//         self.finer(other) and other.finer(self)
//     }
// }

// Alternative, you can use "image of net" and then use finer
define is_directed_limit[K: Directed, L: Directed](f: K -> L) -> Bool {
    forall(b: L) {
        exists(a: K) {
            f(a) <= b
        }
    }
}

define have_common_pt[K](n: Set[Set[K]], x: K) -> Bool {
    forall(s: Set[K]) {
        s ∈ n implies x ∈ s
        // Alternative: use intersection to define
    }
}

attributes Net[K] {
    define have_common_pt(self, x: K) -> Bool {
        have_common_pt(self.sets, x)
    }
}

attributes Net[K] {
    define finer(self, other: Net[K]) -> Bool {
        forall(b: Set[K]) {
            b ∈ other implies exists(a: Set[K]) {
                a ∈ self and a ⊆ b
            }
        }
    }

    define same_limit(self, other: Net[K]) -> Bool {
        self.finer(other) and other.finer(self)
    }
}

theorem finer_helper[K](n1: Net[K], n2: Net[K]) {
    forall(b: Set[K]) {
        b ∈ n2 implies exists(a: Set[K]) {
            a ∈ n1 and a ⊆ b
        }
    } implies (n1).finer(n2)
}

theorem finer_imp_intersection_subset[K](n1: Net[K], n2: Net[K]) {
    (n1).finer(n2) implies intersection(n1.sets) ⊆ intersection(n2.sets)
} by {
    forall(x: K) {
        if x ∈ intersection(n1.sets) {
            forall(s2: Set[K]) {
                if s2 ∈ n2.sets {
                    s2 ∈ n2
                    let s1: Set[K] satisfy {
                        s1 ∈ n1 and s1 ⊆ s2
                    }
                    s1 ∈ n1.sets
                    x ∈ s1
                    x ∈ s2
                }
            }
            x ∈ intersection(n2.sets)
        }
    }
    intersection(n1.sets) ⊆ intersection(n2.sets)
}

theorem same_limit_imp_same_intersection[K](n1: Net[K], n2: Net[K]) {
    (n1).same_limit(n2) implies intersection(n1.sets) = intersection(n2.sets)
} by {
    intersection(n1.sets) ⊆ intersection(n2.sets)
    intersection(n1.sets) ⊇ intersection(n2.sets)
}

theorem finer_trans[K](n1: Net[K], n2: Net[K], n3: Net[K]) {
    (n1).finer(n2) and (n2).finer(n3) implies (n1).finer(n3)
} by {
    forall(a3: Set[K]) {
        if a3 ∈ n3 {
            let a2: Set[K] satisfy {
                a2 ∈ n2 and a2 ⊆ a3
            }
            let a1: Set[K] satisfy {
                a1 ∈ n1 and a1 ⊆ a2
            }
            a1 ∈ n1 and a1 ⊆ a3
        }
    }
}

// Alternative, you can use "image of net" and then use finer
define is_limit[K, L](source_net: Net[K], target_net: Net[L], f: K -> L) -> Bool {
    forall(b: Set[L]) {
        b ∈ target_net implies exists(a: Set[K]) {
            a ∈ source_net and a.image(f) ⊆ b
        }
    }
}

define elem_in_image_of_sets[K, L](n: Set[Set[K]], f: K -> L, b: Set[L]) -> Bool {
    exists(a: Set[K]) { 
        a ∈ n and b = a.image(f)
    }
}

define image_of_sets[K, L](n: Set[Set[K]], f: K -> L) -> Set[Set[L]] {
    Set[Set[L]].new(elem_in_image_of_sets(n, f))
}

theorem image_of_sets_preserve_no_empty[K, L](n: Set[Set[K]], f: K -> L) {
    no_empty(n) implies no_empty(image_of_sets(n, f))
} by {
    forall(b: Set[L]) {
        if b ∈ image_of_sets(n, f) {
            let (a: Set[K]) satisfy { 
                a ∈ n and b = a.image(f)
            }
            (a).is_nonempty
            (a.image(f)).is_nonempty
            (b).is_nonempty
        }
    }
}

theorem image_of_sets_preserve_directed[K, L](n: Set[Set[K]], f: K -> L) {
    directed(n) implies directed(image_of_sets(n, f))
} by {
    forall(b1: Set[L], b2: Set[L]) {
        if b1 ∈ image_of_sets(n, f) and b2 ∈ image_of_sets(n, f) {
            let a1: Set[K] satisfy { a1 ∈ n and b1 = a1.image(f) }
            elem_in_image_of_sets(n, f, b2)
            let a2: Set[K] satisfy { a2 ∈ n and b2 = a2.image(f) }
            directed_helper_imp_by(n)
            let a: Set[K] satisfy { a ∈ n and a ⊆ a1 ∩ a2 }
            a.image(f) ⊆ (a1 ∩ a2).image(f)
            (a1 ∩ a2).image(f) ⊆ a1.image(f) ∩ a2.image(f)
            let b = a.image(f)
            b ∈ image_of_sets(n, f)
            b ⊆ b1 ∩ b2
            b ∈ image_of_sets(n, f) and b ⊆ b1 ∩ b2
        }
    }
    directed_helper(image_of_sets(n, f))
}

theorem image_of_sets_preserve_nets[K, L](n: Set[Set[K]], f: K -> L) {
    is_net(n) implies is_net(image_of_sets(n, f))
}

define image_of_net[K, L](n: Net[K], f: K -> L) -> Net[L] {
    Net[L].new(image_of_sets(n.sets, f))
}

theorem image_of_net_expand[K, L](n: Net[K], f: K -> L) {
    image_of_net(n, f).sets = image_of_sets(n.sets, f)
}

theorem image_of_net_contains_helper[K, L](n: Net[K], f: K -> L, s: Set[K]) {
    s ∈ n implies s.image(f) ∈ image_of_net(n, f)
} by {
    s ∈ n.sets
    s.image(f) ∈ image_of_sets(n.sets, f)
    s.image(f) ∈ image_of_net(n, f).sets
    s.image(f) ∈ image_of_net(n, f)
}

theorem is_limit_imp_image_of_net_finer[K, L](source_net: Net[K], target_net: Net[L], f: K -> L) {
    is_limit(source_net, target_net, f) implies image_of_net(source_net, f).finer(target_net)
} by {
    forall(b: Set[L]) {
        if b ∈ target_net {
            let (a: Set[K]) satisfy {
                a ∈ source_net and a.image(f) ⊆ b
            }
            a.image(f) ∈ image_of_sets(source_net.sets, f)
            a.image(f) ∈ image_of_net(source_net, f).sets
            a.image(f) ∈ image_of_net(source_net, f)
            a.image(f) ∈ image_of_net(source_net, f) and a.image(f) ⊆ b
        } 
    }    
}

theorem image_of_net_finer_imp_is_limit[K, L](source_net: Net[K], target_net: Net[L], f: K -> L) {
    image_of_net(source_net, f).finer(target_net) implies is_limit(source_net, target_net, f)
} by {
    forall(b: Set[L]) {
        if b ∈ target_net {
            let a_image: Set[L] satisfy { 
                a_image ∈ image_of_net(source_net, f) and a_image ⊆ b
            }
            a_image ∈ image_of_sets(source_net.sets, f)
            elem_in_image_of_sets(source_net.sets, f, a_image)
            let a: Set[K] satisfy {
                a ∈ source_net and a_image = a.image(f)
            }
            a.image(f) ⊆ b
            a ∈ source_net and a.image(f) ⊆ b
        } 
    }    
}

theorem gte_trans(a: ℕ, b: ℕ, c: ℕ) { a >= b and b >= c implies a >= c } 

theorem gte_reflexive(a: ℕ) { a >= a }

theorem gte_antisymmetric(a: ℕ, b: ℕ) { a >= b and b >= a implies a = b }

theorem gte_partial_order {
    is_reflexive(ℕ.gte) and
    is_transitive(ℕ.gte) and
    is_antisymmetric(ℕ.gte)
} by {
    is_reflexive(ℕ.gte) 
    is_transitive(ℕ.gte) 
    is_antisymmetric(ℕ.gte)   
}

// // ℕ is linear order, and n <-> {n, n + 1, ...} one-one correspond, so we can directly use it as Directed, without using Net. But, will there be conflict on symbol `<=`? 
// instance ℕ: Partial_Order_Lte {
//     let lte = ℕ.gte
// }

// Using the linear order of ℕ

define seq_tail[K](shift: ℕ, f: ℕ -> K) -> (ℕ -> K) {
    function(n: ℕ) { f(shift + n) }
}

define elem_in_seq_tail[K](f: ℕ -> K, shift: ℕ, x: K) -> Bool {
    exists(n: ℕ) {
        x = seq_tail(shift, f)(n)
    }
}

theorem shift_gte_imp_subset[K](f: ℕ -> K, s1: ℕ, s2: ℕ) {
    s1 >= s2 implies Set[K].new(elem_in_seq_tail(f, s1)) ⊆ Set[K].new(elem_in_seq_tail(f, s2))
} by {
    forall(x: K) {
        if x ∈ Set[K].new(elem_in_seq_tail(f, s1)) {
            elem_in_seq_tail(f, s1, x)
            let n: ℕ satisfy { x = seq_tail(s1, f)(n) }

            let m: ℕ satisfy { s1 = s2 + m }
            f(s1 + n) = f(s2 + m + n)
            seq_tail(s1, f)(n) = seq_tail(s2, f)(m + n)
            elem_in_seq_tail(f, s2, x)

            x ∈ Set[K].new(elem_in_seq_tail(f, s2))
        }
    }
}

define elem_in_seq_to_net[K](f: ℕ -> K, a: Set[K]) -> Bool {
    exists(shift: ℕ) {
        a = Set[K].new(elem_in_seq_tail(f, shift))
    }
}

define seq_to_net[K](f: ℕ -> K) -> Set[Set[K]] {
    Set[Set[K]].new(elem_in_seq_to_net(f))
}

theorem seq_to_net_is_net[K](f: ℕ -> K) {
    is_net(seq_to_net(f))
} by {
    forall(a: Set[K]) {
        if a ∈ seq_to_net(f) {
            elem_in_seq_to_net(f)(a)
            let shift: ℕ satisfy { 
                a = Set[K].new(elem_in_seq_tail(f, shift))
            }
            let x: K satisfy {
                x = seq_tail(shift, f)(0)
            }
            x = f(shift)
            x ∈ a
            a != Set[K].empty_set
        }
    } 

    no_empty(seq_to_net(f))
    
    forall(a1: Set[K], a2: Set[K]) {
        if a1 ∈ seq_to_net(f) and a2 ∈ seq_to_net(f) {
            elem_in_seq_to_net(f)(a1) 
            elem_in_seq_to_net(f)(a2)
            let shift_1: ℕ satisfy {
                a1 = Set[K].new(elem_in_seq_tail(f, shift_1))
            }
            let shift_2: ℕ satisfy {
                a2 = Set[K].new(elem_in_seq_tail(f, shift_2))
            }
            let shift = shift_1.max(shift_2)
            let b = Set[K].new(elem_in_seq_tail(f, shift))
            shift_1 <= shift
            shift_2 <= shift
            b ⊆ a1
            b ⊆ a2
            b ⊆ a1 ∩ a2
            elem_in_seq_to_net(f)(b)
            b ∈ seq_to_net(f)
            b ∈ seq_to_net(f) and b ⊆ a1 ∩ a2
        }
    }
    directed_helper(seq_to_net(f))
    directed(seq_to_net(f))
}

theorem sets_of_finite_intersection_preserve_directed[K](n: Set[Set[K]], s1: Set[K], s2: Set[K]) {
    directed(n) implies directed(sets_of_finite_intersection(n))
}

// helper
define list_subset_sets[K](n: Set[Set[K]], l: List[Set[K]]) -> Bool {
    forall(s: Set[K]){ s ∈ l implies s ∈ n }
}

define subset_intersection_of_list[K](n: Set[Set[K]], l: List[Set[K]]) -> Bool {
    exists(t: Set[K]) { t ∈ n and t ⊆ intersection_of_list_recursion(l) }
}

/// Also, this prove, for net, directed ==> subset_finite_intersection. So indeed using two intersection or finite intersection to define net is equivalent
theorem sets_of_finite_intersection_preserve_net_no_empty_lemma[K](n: Set[Set[K]], list: List[Set[K]]) {
    is_net(n)
    and (n).is_nonempty
    and list_subset_sets(n, list)
    implies 
    subset_intersection_of_list(n, list) 
} by {

    define p(l: List[Set[K]]) -> Bool {
        list_subset_sets(n, l) implies subset_intersection_of_list(n, l) 
    }

    let not_empty_set: Set[K] satisfy { not_empty_set ∈ n }
    not_empty_set ⊆ intersection_of_list_recursion(List[Set[K]].nil)
    p(List[Set[K]].nil)
    forall(head: Set[K], tail: List[Set[K]]) {
        if p(tail) {
            intersection_of_list_recursion(List.cons(head, tail)) = head ∩ intersection_of_list_recursion(tail)

            if list_subset_sets(n, List.cons(head, tail)) {
                forall(s: Set[K]){ s ∈ List.cons(head, tail) implies s ∈ n }
                head ∈ List.cons(head, tail)
                head ∈ n

                forall(s: Set[K]) {
                    if s ∈ tail {
                        s ∈ List.cons(head, tail)
                        s ∈ n
                    }
                }
                list_subset_sets(n, tail)
                subset_intersection_of_list(n, tail)

                let t_tail: Set[K] satisfy { 
                    t_tail ∈ n and t_tail ⊆ intersection_of_list_recursion(tail)
                }
                
                let t: Set[K] satisfy {
                    t ∈ n and t ⊆ head ∩ t_tail
                }

                t ⊆ head ∩ intersection_of_list_recursion(tail)
                
                t ⊆ intersection_of_list_recursion(List.cons(head, tail))

                subset_intersection_of_list(n, List.cons(head, tail))
            }
            p(List.cons(head, tail))
        }
    }
    p(list)
}

theorem sets_of_finite_intersection_preserve_net_no_empty[K](n: Set[Set[K]], list: List[Set[K]]) {
    is_net(n) and (n).is_nonempty implies no_empty(sets_of_finite_intersection(n))
} by {
    forall(s: Set[K]) {
        if s ∈ sets_of_finite_intersection(n) {
            let c: Set[Set[K]] satisfy {
                c ⊆ n and c.is_finite and s = intersection(c)
            }

            let l: List[Set[K]] satisfy {
                c.have_exact_list(l)
            }

            intersection(c) = intersection_of_list_recursion(l)

            c.contains = l.contains
            list_subset_sets(n, l)
            subset_intersection_of_list(n, l)

            let (t: Set[K]) satisfy { t ∈ n and t ⊆ intersection_of_list_recursion(l) }
            t != Set[K].empty_set
            intersection_of_list_recursion(l) != Set[K].empty_set
            s != Set[K].empty_set
        }
    }
}

theorem sets_of_finite_intersection_preserve_net[K](n: Set[Set[K]]) {
    is_net(n) and (n).is_nonempty implies is_net(sets_of_finite_intersection(n))
}

theorem net_subset_finite_intersection[K](n: Set[Set[K]], c: Set[Set[K]]) {
    (n).is_nonempty and is_net(n) and c ⊆ n and c.is_finite implies exists(t: Set[K]) { t ∈ n and t ⊆ intersection(c) }
} by {
    let l: List[Set[K]] satisfy {
        c.have_exact_list(l)
    }
    list_subset_sets(n, l)
    let (t: Set[K]) satisfy { t ∈ n and t ⊆ intersection_of_list_recursion(l) }
    intersection_of_list_recursion(l) = intersection(c)
}

theorem net_from_sets_of_finite_intersection[K](n: Set[Set[K]]) {
    no_empty(sets_of_finite_intersection(n)) implies is_net(sets_of_finite_intersection(n))
} by {
    forall(a1: Set[K], a2: Set[K]) {
        if a1 ∈ sets_of_finite_intersection(n) and a2 ∈ sets_of_finite_intersection(n) {
            let a = a1 ∩ a2
            a ⊆ a1
            a ⊆ a2
            a ∈ sets_of_finite_intersection(n)
        }
    }
    directed(sets_of_finite_intersection(n))
}

define set_intersect_sets[K](n: Set[Set[K]], s: Set[K]) -> Bool {
    forall(t: Set[K]) {
        t ∈ n implies (s ∩ t).is_nonempty
    }
}

define elem_in_subnet_sets[K](n: Set[Set[K]], s: Set[K], sub: Set[K]) -> Bool {
    set_intersect_sets(n, s) and exists(t: Set[K]) {
        t ∈ n and sub = s ∩ t
    }
}

define subnet_sets[K](n: Set[Set[K]], s: Set[K]) -> Set[Set[K]] {
    Set[Set[K]].new(elem_in_subnet_sets(n, s))
}

theorem subnet_sets_is_net[K](n: Set[Set[K]], s: Set[K]) {
    is_net(n) and set_intersect_sets(n, s) implies is_net(subnet_sets(n, s))
} by {
    forall(sub: Set[K]) {
        if sub ∈ subnet_sets(n, s) {
            set_intersect_sets(n, s)
            let (t: Set[K]) satisfy {
                t ∈ n and sub = s ∩ t
            }
            (s ∩ t).is_nonempty
            (sub).is_nonempty
        }
    }
    no_empty(subnet_sets(n, s))

    forall(a1: Set[K], a2: Set[K]) {
        if a1 ∈ subnet_sets(n, s) and a2 ∈ subnet_sets(n, s) {
            elem_in_subnet_sets(n, s, a1)
            let (t1: Set[K]) satisfy {
                t1 ∈ n and a1 = s ∩ t1
            }
            elem_in_subnet_sets(n, s, a2)
            let (t2: Set[K]) satisfy {
                t2 ∈ n and a2 = s ∩ t2
            }
            let t: Set[K] satisfy {
                t ∈ n and t ⊆ t1 ∩ t2
            }
            a1 ∩ a2 = (s ∩ t1) ∩ (s ∩ t2)
            (s ∩ t1) ∩ (s ∩ t2) = (s ∩ s) ∩ t1 ∩ t2
            (s ∩ s) ∩ t1 ∩ t2 = s ∩ (t1 ∩ t2)
            a1 ∩ a2 = s ∩ (t1 ∩ t2)
            let a = s ∩ t
            a ∈ subnet_sets(n, s)
            s ∩ t ⊆ s ∩ (t1 ∩ t2)
            a ⊆ a1 ∩ a2
            a ∈ subnet_sets(n, s) and a ⊆ a1 ∩ a2
        }
    }
    directed_helper(subnet_sets(n, s))
    directed(subnet_sets(n, s))
}

define subnet[K](n: Net[K], s: Set[K]) -> Net[K] {
    if set_intersect_sets(n.sets, s) {
        Net[K].new(subnet_sets(n.sets, s))
    } else {
        n
    }
}

theorem two_intersection_in_subnet[K](n: Net[K], s: Set[K], t: Set[K]) {
    set_intersect_sets(n.sets, s) and t ∈ n implies s ∩ t ∈ subnet(n, s)
} by {
    elem_in_subnet_sets(n.sets, s, s ∩ t)
    s ∩ t ∈ subnet_sets(n.sets, s)
    s ∩ t ∈ subnet(n, s).sets
}

theorem subnet_sets_helper[K](n: Net[K], s: Set[K], sub: Set[K]) {
    set_intersect_sets(n.sets, s) and sub ∈ subnet(n, s) implies exists(t: Set[K]) {
        t ∈ n and sub = s ∩ t
    }
} by {
    sub ∈ subnet_sets(n.sets, s)
    elem_in_subnet_sets(n.sets, s, sub)
    let t: Set[K] satisfy {
        t ∈ n.sets and sub = s ∩ t
    }
    t ∈ n and sub = s ∩ t
}