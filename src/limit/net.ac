from finite_set import Set, List, list_to_set, intersection_of_list_recursion, intersection_of_list, sets_of_finite_intersection, is_set_of_finite_intersection
from set import intersection, elem_in_intersection_general
from order import Partial_Order, Linear_Order, is_acyclic, is_transitive, is_reflexive, is_antisymmetric, is_nonreflexive, lte_from, lt_from, lte_to_lt_partial_order, Partial_Order_Lte, lte_max
from nat import ℕ
from list.list_base import flatten, max_list
numerals ℕ

// Nets are a generalization of sequences used in topology to define limits
// A net consists of a directed family of nonempty sets

// And now Acorn not support direct subtype and dependent type. Once they are support, we can make the set c: Set[Set[K]], c.is_chain in to type 

// Subtype make type and set almost the same thing, i.e. for a: Set[K], we have subtype { x: T | x ∈ a }

// A collection of sets is no_empty if it contains no empty sets
define no_empty[K](sets: Set[Set[K]]) -> Bool {
    forall(a: Set[K]) {
        a ∈ sets implies a != Set[K].empty_set
    }    
}

// A collection of sets is directed if for any two sets, there exists a third set contained in both
define directed[K](sets: Set[Set[K]]) -> Bool {
    forall(a1: Set[K], a2: Set[K]) {
        a1 ∈ sets and a2 ∈ sets implies exists(b: Set[K]) {
            b ∈ sets and b ⊆ a1 and b ⊆ a2
        }
    }    
}

// Helper theorem: the condition in the definition of directed is equivalent to directed
theorem directed_helper[K](sets: Set[Set[K]]) {
    forall(a1: Set[K], a2: Set[K]) {
        a1 ∈ sets and a2 ∈ sets implies exists(b: Set[K]) {
            b ∈ sets and b ⊆ a1 and b ⊆ a2
        }
    } implies directed(sets) 
}

// Alternative helper using intersection: if for any two sets there's a set in their intersection, the collection is directed
theorem directed_helper_ver_intersection[K](sets: Set[Set[K]]) {
    forall(a1: Set[K], a2: Set[K]) {
        a1 ∈ sets and a2 ∈ sets implies exists(b: Set[K]) {
            b ∈ sets and b ⊆ a1 ∩ a2
        }
    } implies directed(sets) 
} by {
    forall(a1: Set[K], a2: Set[K]) {
        if a1 ∈ sets and a2 ∈ sets {
            let (b: Set[K]) satisfy {
                b ∈ sets and b ⊆ a1 ∩ a2
            }
            b ∈ sets and b ⊆ a1 and b ⊆ a2
        }
    }
}

// Converse: directed implies the existence of a set in the intersection for any two sets
theorem directed_helper_imp_by[T](sets: Set[Set[T]]) {
    directed(sets) implies (
        forall(a1: Set[T], a2: Set[T]) {
            a1 ∈ sets and a2 ∈ sets implies exists(b: Set[T]) {
                b ∈ sets and b ⊆ a1 and b ⊆ a2
            }
        } 
    )
} 

// Converse using intersection formulation
theorem directed_helper_imp_by_ver_intersection[T](sets: Set[Set[T]]) {
    directed(sets) implies (
        forall(a1: Set[T], a2: Set[T]) {
            a1 ∈ sets and a2 ∈ sets implies exists(b: Set[T]) {
                b ∈ sets and b ⊆ a1 ∩ a2
            }
        } 
    )
} by {
    forall(a1: Set[T], a2: Set[T]) {
        if a1 ∈ sets and a2 ∈ sets { 
            let (b: Set[T]) satisfy {
                b ∈ sets and b ⊆ a1 and b ⊆ a2
            }
            b ∈ sets and b ⊆ a1 ∩ a2
        }
    } 
}

/// Topology doesn't seem to provide a sufficient motivation for using the concept of a net, but the definitions of measure and integral should.
// A net is a nonempty directed collection of sets
define is_net[K](sets: Set[Set[K]]) -> Bool {
    no_empty(sets) and directed(sets)
}

// A Net structure encapsulates a collection of sets that is a net
structure Net[K] {
    sets: Set[Set[K]]
} constraint {
    is_net(sets)
} by {
    // Construct a singleton net as a witness: { {x} } where x is any element
    let x: K satisfy { true }
    let s = Set[K].singleton(x)
    let n = Set[Set[K]].singleton(s)
    forall(a: Set[K]) {
        if a ∈ n {
            a = s
            s != Set[K].empty_set
            a != Set[K].empty_set
        }
    }
    no_empty(n)
    forall(a1: Set[K], a2: Set[K]) {
        if a1 ∈ n and a2 ∈ n {
            a1 = s
            a2 = s
            let b = s
            b ∈ n
            b ⊆ a1 ∩ a2
            b ∈ n and b ⊆ a1 ∩ a2
        }
    }
    directed(n)
}

// Attribute: check if a set is contained in the net
attributes Net[K] {
    define contains(self, s: Set[K]) -> Bool {
        self.sets.contains(s)
    }
}

// Membership in a net is equivalent to membership in its underlying set of sets
theorem equivalent_of_contains[K](n: Net[K], s: Set[K]) {
    s ∈ n iff s ∈ n.sets
} 

// Helper for creating a new net: membership is preserved
theorem net_new_helper[K](n: Net[K], n_sets: Set[Set[K]], s: Set[K]) {
    is_net(n_sets) and n = Net[K].new(n_sets) implies (
        s ∈ n iff s ∈ n_sets
    )
} by {
    Net[K].new(n_sets).sets = n_sets
    n.sets = n_sets
    s ∈ n implies s ∈ n_sets
    s ∈ n_sets implies s ∈ n
}

// Any set in a net is nonempty
theorem net_contains_imp_nonempty[K](n: Net[K], s: Set[K]) {
    s ∈ n implies (s).is_nonempty
} 

// For any two sets in a net, there exists a third set in their intersection
theorem net_contains_imp_directed[K](n: Net[K], a1: Set[K], a2: Set[K]) {
    a1 ∈ n and a2 ∈ n implies exists(b: Set[K]) {
        b ∈ n and b ⊆ a1 ∩ a2
    }
} by {
    is_net(n.sets)
    a1 ∈ n.sets
    a2 ∈ n.sets
    directed_helper_imp_by(n.sets)
    let (b: Set[K]) satisfy {
        b ∈ n.sets and b ⊆ a1 ∩ a2
    }
    b ∈ n
    b ∈ n and b ⊆ a1 ∩ a2
}

// The intersection of any two sets in a net is nonempty
theorem two_intersection_nonempty_in_net[K](n: Net[K], a1: Set[K], a2: Set[K]) {
    a1 ∈ n and a2 ∈ n implies (a1 ∩ a2).is_nonempty
} by {
    let (b: Set[K]) satisfy {
        b ∈ n and b ⊆ a1 ∩ a2
    }    
    (b).is_nonempty
}

// A typeclass for directed sets extending partial orders: any two elements have a common lower bound
typeclass N: Directed extends Partial_Order {
    directed(a: N, b: N) {
        exists(c: N) {
            c <= a and c <= b
            // note that when it's not linear order, we can't just use c = a or c = b
        }
    }
}

// // to define finer we need two differnt Directed instance extends a same Partial_Order instance ... and dependent type?
// attributes N: Directed {
//     define finer[M: Directed] -> Bool {
//         forall(b: M) {
//             exists(a) {
//                 a <= b
//             }
//         }
//     }

//     define same_limit(self, other: N) -> Bool {
//         self.finer(other) and other.finer(self)
//     }
// }

// Alternative, you can use "image of net" and then use finer
define is_directed_limit[K: Directed, L: Directed](f: K -> L) -> Bool {
    forall(b: L) {
        exists(a: K) {
            f(a) <= b
        }
    }
}

// A point x is a common point of a collection of sets if it belongs to every set in the collection
define have_common_pt[K](n: Set[Set[K]], x: K) -> Bool {
    forall(s: Set[K]) {
        s ∈ n implies x ∈ s
        // Alternative: use intersection to define
    }
}

attributes Net[K] {
    define have_common_pt(self, x: K) -> Bool {
        have_common_pt(self.sets, x)
    }
}

// Net attributes for comparing nets
attributes Net[K] {
    // n1 is finer than n2 if for every set in n2, there's a subset in n1
    define finer(self, other: Net[K]) -> Bool {
        forall(b: Set[K]) {
            b ∈ other implies exists(a: Set[K]) {
                a ∈ self and a ⊆ b
            }
        }
    }

    // Two nets have the same limit if each is finer than the other (they are equivalent)
    define same_limit(self, other: Net[K]) -> Bool {
        self.finer(other) and other.finer(self)
    }
}

// Helper: the condition in the definition of finer is equivalent to finer
theorem finer_helper[K](n1: Net[K], n2: Net[K]) {
    forall(b: Set[K]) {
        b ∈ n2 implies exists(a: Set[K]) {
            a ∈ n1 and a ⊆ b
        }
    } implies (n1).finer(n2)
}

// If a net is finer than another, their intersection of all sets is contained in the other's intersection
theorem finer_imp_intersection_subset[K](n1: Net[K], n2: Net[K]) {
    (n1).finer(n2) implies intersection(n1.sets) ⊆ intersection(n2.sets)
} by {
    forall(x: K) {
        if x ∈ intersection(n1.sets) {
            forall(s2: Set[K]) {
                if s2 ∈ n2.sets {
                    s2 ∈ n2
                    let s1: Set[K] satisfy {
                        s1 ∈ n1 and s1 ⊆ s2
                    }
                    s1 ∈ n1.sets
                    x ∈ s1
                    x ∈ s2
                }
            }
            x ∈ intersection(n2.sets)
        }
    }
    intersection(n1.sets) ⊆ intersection(n2.sets)
}

// If two nets have the same limit, their intersections are equal
theorem same_limit_imp_same_intersection[K](n1: Net[K], n2: Net[K]) {
    (n1).same_limit(n2) implies intersection(n1.sets) = intersection(n2.sets)
} by {
    intersection(n1.sets) ⊆ intersection(n2.sets)
    intersection(n1.sets) ⊇ intersection(n2.sets)
}

// The finer relation is transitive
theorem finer_trans[K](n1: Net[K], n2: Net[K], n3: Net[K]) {
    (n1).finer(n2) and (n2).finer(n3) implies (n1).finer(n3)
} by {
    forall(a3: Set[K]) {
        if a3 ∈ n3 {
            let a2: Set[K] satisfy {
                a2 ∈ n2 and a2 ⊆ a3
            }
            let a1: Set[K] satisfy {
                a1 ∈ n1 and a1 ⊆ a2
            }
            a1 ∈ n1 and a1 ⊆ a3
        }
    }
}

// Alternative, you can use "image of net" and then use finer
define is_limit[K, L](source_net: Net[K], target_net: Net[L], f: K -> L) -> Bool {
    forall(b: Set[L]) {
        b ∈ target_net implies exists(a: Set[K]) {
            a ∈ source_net and a.image(f) ⊆ b
        }
    }
}

// A set b is in the image of sets if it's the image under f of some set in n
define elem_in_image_of_sets[K, L](n: Set[Set[K]], f: K -> L, b: Set[L]) -> Bool {
    exists(a: Set[K]) { 
        a ∈ n and b = a.image(f)
    }
}

// Construct the image of a collection of sets under a function f
define image_of_sets[K, L](n: Set[Set[K]], f: K -> L) -> Set[Set[L]] {
    Set[Set[L]].new(elem_in_image_of_sets(n, f))
}

// Taking images under f preserves the nonempty property
theorem image_of_sets_preserve_no_empty[K, L](n: Set[Set[K]], f: K -> L) {
    no_empty(n) implies no_empty(image_of_sets(n, f))
} by {
    forall(b: Set[L]) {
        if b ∈ image_of_sets(n, f) {
            let (a: Set[K]) satisfy { 
                a ∈ n and b = a.image(f)
            }
            (a).is_nonempty
            (a.image(f)).is_nonempty
            (b).is_nonempty
        }
    }
}

// Taking images under f preserves the directed property
theorem image_of_sets_preserve_directed[K, L](n: Set[Set[K]], f: K -> L) {
    directed(n) implies directed(image_of_sets(n, f))
} by {
    forall(b1: Set[L], b2: Set[L]) {
        if b1 ∈ image_of_sets(n, f) and b2 ∈ image_of_sets(n, f) {
            let a1: Set[K] satisfy { a1 ∈ n and b1 = a1.image(f) }
            elem_in_image_of_sets(n, f, b2)
            let a2: Set[K] satisfy { a2 ∈ n and b2 = a2.image(f) }
            directed_helper_imp_by(n)
            let a: Set[K] satisfy { a ∈ n and a ⊆ a1 ∩ a2 }
            a.image(f) ⊆ (a1 ∩ a2).image(f)
            (a1 ∩ a2).image(f) ⊆ a1.image(f) ∩ a2.image(f)
            let b = a.image(f)
            b ∈ image_of_sets(n, f)
            b ⊆ b1 ∩ b2
            b ∈ image_of_sets(n, f) and b ⊆ b1 ∩ b2
        }
    }
    directed_helper(image_of_sets(n, f))
}

// Taking images under f preserves the net property (both nonempty and directed)
theorem image_of_sets_preserve_nets[K, L](n: Set[Set[K]], f: K -> L) {
    is_net(n) implies is_net(image_of_sets(n, f))
}

// Construct the image of a net under a function f
define image_of_net[K, L](n: Net[K], f: K -> L) -> Net[L] {
    Net[L].new(image_of_sets(n.sets, f))
}

// Helper: the underlying sets of the image of a net is the image of its underlying sets
theorem image_of_net_expand[K, L](n: Net[K], f: K -> L) {
    image_of_net(n, f).sets = image_of_sets(n.sets, f)
}

// If s is in n, then its image under f is in the image of the net
theorem image_of_net_contains_helper[K, L](n: Net[K], f: K -> L, s: Set[K]) {
    s ∈ n implies s.image(f) ∈ image_of_net(n, f)
} by {
    s ∈ n.sets
    s.image(f) ∈ image_of_sets(n.sets, f)
    s.image(f) ∈ image_of_net(n, f).sets
    s.image(f) ∈ image_of_net(n, f)
}

// f is a limit from source_net to target_net iff the image of source_net under f is finer than target_net
theorem is_limit_imp_image_of_net_finer[K, L](source_net: Net[K], target_net: Net[L], f: K -> L) {
    is_limit(source_net, target_net, f) implies image_of_net(source_net, f).finer(target_net)
} by {
    forall(b: Set[L]) {
        if b ∈ target_net {
            let (a: Set[K]) satisfy {
                a ∈ source_net and a.image(f) ⊆ b
            }
            a.image(f) ∈ image_of_sets(source_net.sets, f)
            a.image(f) ∈ image_of_net(source_net, f).sets
            a.image(f) ∈ image_of_net(source_net, f)
            a.image(f) ∈ image_of_net(source_net, f) and a.image(f) ⊆ b
        } 
    }    
}

// Converse: if the image of source_net under f is finer than target_net, then f is a limit
theorem image_of_net_finer_imp_is_limit[K, L](source_net: Net[K], target_net: Net[L], f: K -> L) {
    image_of_net(source_net, f).finer(target_net) implies is_limit(source_net, target_net, f)
} by {
    forall(b: Set[L]) {
        if b ∈ target_net {
            let a_image: Set[L] satisfy { 
                a_image ∈ image_of_net(source_net, f) and a_image ⊆ b
            }
            a_image ∈ image_of_sets(source_net.sets, f)
            elem_in_image_of_sets(source_net.sets, f, a_image)
            let a: Set[K] satisfy {
                a ∈ source_net and a_image = a.image(f)
            }
            a.image(f) ⊆ b
            a ∈ source_net and a.image(f) ⊆ b
        } 
    }    
}

// Basic properties of the greater-than-or-equal relation on natural numbers
// Transitivity: if a >= b and b >= c, then a >= c
theorem gte_trans(a: ℕ, b: ℕ, c: ℕ) { a >= b and b >= c implies a >= c }
// Reflexivity: every number is >= itself
theorem gte_reflexive(a: ℕ) { a >= a }
// Antisymmetry: if a >= b and b >= a, then a = b
theorem gte_antisymmetric(a: ℕ, b: ℕ) { a >= b and b >= a implies a = b }

// The >= relation on ℕ is a partial order (reflexive, transitive, and antisymmetric)
theorem gte_partial_order {
    is_reflexive(ℕ.gte) and
    is_transitive(ℕ.gte) and
    is_antisymmetric(ℕ.gte)
} by {
    is_reflexive(ℕ.gte) 
    is_transitive(ℕ.gte) 
    is_antisymmetric(ℕ.gte)   
}

// // ℕ is linear order, and n <-> {n, n + 1, ...} one-one correspond, so we can directly use it as Directed, without using Net. But, will there be conflict on symbol `<=`? 
// instance ℕ: Partial_Order_Lte {
//     let lte = ℕ.gte
// }

// Using the linear order of ℕ

// Define the "tail" of a sequence starting from a given shift point: {shift, shift+1, shift+2, ...}
define elem_in_seq_tail(shift: ℕ, x: ℕ) -> Bool {
    exists(n: ℕ) {
        x = shift + n
    }
}

define seq_tail(shift: ℕ) -> Set[ℕ] {
    Set[ℕ].new(elem_in_seq_tail(shift))
}

// The tail set contains exactly those numbers >= the shift point
theorem seq_tail_iff_lte(shift: ℕ, x: ℕ) {
    x ∈ seq_tail(shift) iff x >= shift
} by {
    if x ∈ seq_tail(shift) {
        let n: ℕ satisfy {
            x = shift + n
        }
        x >= shift
    }
    if x >= shift {
        let n: ℕ satisfy {
            x = shift + n
        }
        x ∈ seq_tail(shift)
    }
}

// If shift_1 >= shift_2, then tail starting at shift_1 is a subset of tail starting at shift_2
theorem shift_gte_imp_subset(s1: ℕ, s2: ℕ) {
    s1 >= s2 implies seq_tail(s1) ⊆ seq_tail(s2)
} by {
    forall(x: ℕ) {
        if x ∈ seq_tail(s1) {
            x >= s1
            x >= s2
            x ∈ seq_tail(s2)
        }
    }
}

// Define the sequence net: a set of tails starting at various shift points
define elem_in_seq_net_sets(a: Set[ℕ]) -> Bool {
    exists(shift: ℕ) {
        a = seq_tail(shift)
    }
}

let seq_net_sets = Set[Set[ℕ]].new(elem_in_seq_net_sets)

// Prove that the sequence net is indeed a net (nonempty and directed)
theorem seq_net_sets_is_net {
    is_net(seq_net_sets)
} by {
    forall(a: Set[ℕ]) {
        if a ∈ seq_net_sets {
            elem_in_seq_net_sets(a)
            let shift: ℕ satisfy { 
                a = seq_tail(shift)
            }
            shift = shift + 0
            shift ∈ a
            a != Set[ℕ].empty_set
        }
    } 

    no_empty(seq_net_sets)
    
    forall(a1: Set[ℕ], a2: Set[ℕ]) {
        if a1 ∈ seq_net_sets and a2 ∈ seq_net_sets {
            elem_in_seq_net_sets(a1) 
            elem_in_seq_net_sets(a2)
            let shift_1: ℕ satisfy {
                a1 = seq_tail(shift_1)
            }
            let shift_2: ℕ satisfy {
                a2 = seq_tail(shift_2)
            }
            let shift = shift_1.max(shift_2)
            let b = seq_tail(shift)
            lte_max(shift_1, shift_2)
            shift_1 <= shift
            shift_2 <= shift
            b ⊆ a1
            b ⊆ a2
            elem_in_seq_net_sets(b)
            b ∈ seq_net_sets
            b ∈ seq_net_sets and b ⊆ a1 and b ⊆ a2
        }
    }
    directed_helper(seq_net_sets)
    directed(seq_net_sets)
}

let seq_net = Net[ℕ].new(seq_net_sets)

// Taking finite intersections of sets from a directed set preserves the directed property
theorem sets_of_finite_intersection_preserve_directed[K](n: Set[Set[K]], s1: Set[K], s2: Set[K]) {
    directed(n) implies directed(sets_of_finite_intersection(n))
}

// Helper: all sets in the list are members of n
define list_subset_sets[K](n: Set[Set[K]], l: List[Set[K]]) -> Bool {
    forall(s: Set[K]){ s ∈ l implies s ∈ n }
}

// Helper: there exists a set in n that is a subset of the intersection of the list
define subset_intersection_of_list[K](n: Set[Set[K]], l: List[Set[K]]) -> Bool {
    exists(t: Set[K]) { t ∈ n and t ⊆ intersection_of_list_recursion(l) }
}

// Main lemma: if n is a net, then for any finite list of sets from n, there's a set in n contained in their intersection
theorem sets_of_finite_intersection_preserve_net_no_empty_lemma[K](n: Set[Set[K]], list: List[Set[K]]) {
    is_net(n)
    and (n).is_nonempty
    and list_subset_sets(n, list)
    implies 
    subset_intersection_of_list(n, list) 
} by {

    define p(l: List[Set[K]]) -> Bool {
        list_subset_sets(n, l) implies subset_intersection_of_list(n, l) 
    }

    let not_empty_set: Set[K] satisfy { not_empty_set ∈ n }
    not_empty_set ⊆ intersection_of_list_recursion(List[Set[K]].nil)
    p(List[Set[K]].nil)
    forall(head: Set[K], tail: List[Set[K]]) {
        if p(tail) {
            intersection_of_list_recursion(List.cons(head, tail)) = head ∩ intersection_of_list_recursion(tail)

            if list_subset_sets(n, List.cons(head, tail)) {
                forall(s: Set[K]){ s ∈ List.cons(head, tail) implies s ∈ n }
                head ∈ List.cons(head, tail)
                head ∈ n

                forall(s: Set[K]) {
                    if s ∈ tail {
                        s ∈ List.cons(head, tail)
                        s ∈ n
                    }
                }
                list_subset_sets(n, tail)
                subset_intersection_of_list(n, tail)

                let t_tail: Set[K] satisfy { 
                    t_tail ∈ n and t_tail ⊆ intersection_of_list_recursion(tail)
                }
                
                let t: Set[K] satisfy {
                    t ∈ n and t ⊆ head ∩ t_tail
                }

                t ⊆ head ∩ intersection_of_list_recursion(tail)
                
                t ⊆ intersection_of_list_recursion(List.cons(head, tail))

                subset_intersection_of_list(n, List.cons(head, tail))
            }
            p(List.cons(head, tail))
        }
    }
    p(list)
}

// Taking finite intersections of a net preserves the nonempty property
theorem sets_of_finite_intersection_preserve_net_no_empty[K](n: Set[Set[K]], list: List[Set[K]]) {
    is_net(n) and (n).is_nonempty implies no_empty(sets_of_finite_intersection(n))
} by {
    forall(s: Set[K]) {
        if s ∈ sets_of_finite_intersection(n) {
            let c: Set[Set[K]] satisfy {
                c ⊆ n and c.is_finite and s = intersection(c)
            }

            let l: List[Set[K]] satisfy {
                c.have_exact_list(l)
            }

            intersection(c) = intersection_of_list_recursion(l)

            c.contains = l.contains
            list_subset_sets(n, l)
            subset_intersection_of_list(n, l)

            let (t: Set[K]) satisfy { t ∈ n and t ⊆ intersection_of_list_recursion(l) }
            t != Set[K].empty_set
            intersection_of_list_recursion(l) != Set[K].empty_set
            s != Set[K].empty_set
        }
    }
}

// Taking finite intersections of a nonempty net preserves the net property (both nonempty and directed)
theorem sets_of_finite_intersection_preserve_net[K](n: Set[Set[K]]) {
    is_net(n) and (n).is_nonempty implies is_net(sets_of_finite_intersection(n))
}

// For any finite subset of a net, there exists a set in the net contained in their intersection
theorem net_subset_finite_intersection[K](n: Set[Set[K]], c: Set[Set[K]]) {
    (n).is_nonempty and is_net(n) and c ⊆ n and c.is_finite implies exists(t: Set[K]) { t ∈ n and t ⊆ intersection(c) }
} by {
    let l: List[Set[K]] satisfy {
        c.have_exact_list(l)
    }
    list_subset_sets(n, l)
    let (t: Set[K]) satisfy { t ∈ n and t ⊆ intersection_of_list_recursion(l) }
    intersection_of_list_recursion(l) = intersection(c)
}

// If the set of finite intersections is nonempty, then it forms a net
theorem net_from_sets_of_finite_intersection[K](n: Set[Set[K]]) {
    no_empty(sets_of_finite_intersection(n)) implies is_net(sets_of_finite_intersection(n))
} by {
    forall(a1: Set[K], a2: Set[K]) {
        if a1 ∈ sets_of_finite_intersection(n) and a2 ∈ sets_of_finite_intersection(n) {
            let a = a1 ∩ a2
            a ⊆ a1
            a ⊆ a2
            a ∈ sets_of_finite_intersection(n)
        }
    }
    directed(sets_of_finite_intersection(n))
}

// A set s intersects all sets in n (i.e., their intersection with s is always nonempty)
define set_intersect_sets[K](n: Set[Set[K]], s: Set[K]) -> Bool {
    forall(t: Set[K]) {
        t ∈ n implies (s ∩ t).is_nonempty
    }
}

// A set sub belongs to the subnet if it's the intersection of s with some set from n
define elem_in_subnet_sets[K](n: Set[Set[K]], s: Set[K], sub: Set[K]) -> Bool {
    set_intersect_sets(n, s) and exists(t: Set[K]) {
        t ∈ n and sub = s ∩ t
    }
}

// The subnet of n with respect to s consists of all intersections of s with sets from n
define subnet_sets[K](n: Set[Set[K]], s: Set[K]) -> Set[Set[K]] {
    Set[Set[K]].new(elem_in_subnet_sets(n, s))
}

// If s intersects all sets in n, then the subnet with respect to s is itself a net
theorem subnet_sets_is_net[K](n: Set[Set[K]], s: Set[K]) {
    is_net(n) and set_intersect_sets(n, s) implies is_net(subnet_sets(n, s))
} by {
    forall(sub: Set[K]) {
        if sub ∈ subnet_sets(n, s) {
            set_intersect_sets(n, s)
            let (t: Set[K]) satisfy {
                t ∈ n and sub = s ∩ t
            }
            (s ∩ t).is_nonempty
            (sub).is_nonempty
        }
    }
    no_empty(subnet_sets(n, s))

    forall(a1: Set[K], a2: Set[K]) {
        if a1 ∈ subnet_sets(n, s) and a2 ∈ subnet_sets(n, s) {
            elem_in_subnet_sets(n, s, a1)
            let (t1: Set[K]) satisfy {
                t1 ∈ n and a1 = s ∩ t1
            }
            elem_in_subnet_sets(n, s, a2)
            let (t2: Set[K]) satisfy {
                t2 ∈ n and a2 = s ∩ t2
            }
            let t: Set[K] satisfy {
                t ∈ n and t ⊆ t1 ∩ t2
            }
            a1 ∩ a2 = (s ∩ t1) ∩ (s ∩ t2)
            (s ∩ t1) ∩ (s ∩ t2) = (s ∩ s) ∩ t1 ∩ t2
            (s ∩ s) ∩ t1 ∩ t2 = s ∩ (t1 ∩ t2)
            a1 ∩ a2 = s ∩ (t1 ∩ t2)
            let a = s ∩ t
            a ∈ subnet_sets(n, s)
            s ∩ t ⊆ s ∩ (t1 ∩ t2)
            a ⊆ a1 ∩ a2
            a ∈ subnet_sets(n, s) and a ⊆ a1 ∩ a2
        }
    }
    directed_helper(subnet_sets(n, s))
    directed(subnet_sets(n, s))
}

// Construct a subnet from a net n with respect to a set s; if s doesn't intersect all sets, return n unchanged
define subnet[K](n: Net[K], s: Set[K]) -> Net[K] {
    if set_intersect_sets(n.sets, s) {
        Net[K].new(subnet_sets(n.sets, s))
    } else {
        n
    }
}

// If s intersects all sets in n, then the intersection of s with any set t from n is in the subnet
theorem two_intersection_in_subnet[K](n: Net[K], s: Set[K], t: Set[K]) {
    set_intersect_sets(n.sets, s) and t ∈ n implies s ∩ t ∈ subnet(n, s)
} by {
    elem_in_subnet_sets(n.sets, s, s ∩ t)
    s ∩ t ∈ subnet_sets(n.sets, s)
    s ∩ t ∈ subnet(n, s).sets
}

// Helper: any set in the subnet can be expressed as the intersection of s with some set from n
theorem subnet_sets_helper[K](n: Net[K], s: Set[K], sub: Set[K]) {
    set_intersect_sets(n.sets, s) and sub ∈ subnet(n, s) implies exists(t: Set[K]) {
        t ∈ n and sub = s ∩ t
    }
} by {
    sub ∈ subnet_sets(n.sets, s)
    elem_in_subnet_sets(n.sets, s, sub)
    let t: Set[K] satisfy {
        t ∈ n.sets and sub = s ∩ t
    }
    t ∈ n and sub = s ∩ t
}

// Future: define a net using a directed set with a partial order, by mapping each element y to the set of elements less than or equal to y
// we want to define a net by directed on a set ... i.e. let s: Set[K] and lte: s × s --> Bool be directed, then use correspondence y ∈ s <--> p(y) = { x ∈ s satisfy x <= y } so that y1 <= y2 <==> p(y1) ⊆ p(y2)