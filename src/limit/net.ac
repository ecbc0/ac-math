from finite_set import Set, List, list_to_set, intersection_of_list_recursion, intersection_of_list
from set import intersection, elem_in_intersection_general, is_nonempty
from order import Partial_Order, Linear_Order, is_acyclic, is_transitive, is_reflexive, is_antisymmetric, is_nonreflexive, lte_from, lt_from, lte_to_lt_partial_order, Partial_Order_Lte
from nat import ℕ
from list.list_base import flatten, max_list
numerals ℕ

// And now Acorn not support direct subtype and dependent type. Once they are support, we can make the set c: Set[Set[K]], c.is_chain in to type 

// Subtype make type and set almost the same thing, i.e. for a: Set[K], we have subtype { x: T | x ∈ a }

define no_empty[K](sets: Set[Set[K]]) -> Bool {
    forall(a: Set[K]) {
        a ∈ sets implies a != Set[K].empty_set
    }    
}

define subset_two_intersection[K](sets: Set[Set[K]]) -> Bool {
    forall(a1: Set[K], a2: Set[K]) {
        a1 ∈ sets and a2 ∈ sets implies exists(b: Set[K]) {
            b ∈ sets and b ⊆ a1 ∩ a2
        }
    }    
}

theorem subset_two_intersection_helper[K](sets: Set[Set[K]]) {
    forall(a1: Set[K], a2: Set[K]) {
        a1 ∈ sets and a2 ∈ sets implies exists(b: Set[K]) {
            b ∈ sets and b ⊆ a1 ∩ a2
        }
    } implies subset_two_intersection(sets) 
}

theorem subset_two_intersection_helper_imp_by_ver_logic[T](sets: Set[Set[T]]) {
    subset_two_intersection(sets) implies (
        forall(a1: Set[T], a2: Set[T]) {
            a1 ∈ sets and a2 ∈ sets implies exists(b: Set[T]) {
                b ∈ sets and b ⊆ a1 and b ⊆ a2
            }
        } 
    )
} by {
    forall(a1: Set[T], a2: Set[T]) {
        if a1 ∈ sets and a2 ∈ sets { 
            let (b: Set[T]) satisfy {
                b ∈ sets and b ⊆ a1 ∩ a2
            }
            b ∈ sets and b ⊆ a1 and b ⊆ a2
        }
    } 
}

theorem subset_two_intersection_helper_imp_by[T](sets: Set[Set[T]]) {
    subset_two_intersection(sets) implies (
        forall(a1: Set[T], a2: Set[T]) {
            a1 ∈ sets and a2 ∈ sets implies exists(b: Set[T]) {
                b ∈ sets and b ⊆ a1 ∩ a2
            }
        } 
    )
} 

/// Topology doesn't seem to provide a sufficient motivation for using the concept of a net, but the definitions of measure and integral should.
define is_net[K](sets: Set[Set[K]]) -> Bool {
    no_empty(sets) and subset_two_intersection(sets)
}

structure Set_Net[K] {
    sets: Set[Set[K]]
} constraint {
    is_net(sets)
} by {
    let x: K satisfy { true }
    let s = Set[K].singleton(x)
    let n = Set[Set[K]].singleton(s)
    forall(a: Set[K]) {
        if a ∈ n {
            a = s
            s != Set[K].empty_set
            a != Set[K].empty_set
        }
    }
    no_empty(n)
    forall(a1: Set[K], a2: Set[K]) {
        if a1 ∈ n and a2 ∈ n {
            a1 = s
            a2 = s
            let b = s
            b ∈ n
            b ⊆ a1 ∩ a2
            b ∈ n and b ⊆ a1 ∩ a2
        }
    }
    subset_two_intersection(n)
}

typeclass N: Net extends Partial_Order {
    directed(a: N, b: N) {
        exists(c: N) {
            c <= a and c <= b
            // note that when it's not linear order, we can't just use c = a or c = b
        }
    }
}

// // to define finer we need two differnt Net instance extends a same Partial_Order instance ... and dependent type? 
// attributes N: Net {
//     define finer[M: Net] -> Bool {
//         forall(b: M) {
//             exists(a) {
//                 a <= b
//             }
//         }
//     }

//     define same_limit(self, other: N) -> Bool {
//         self.finer(other) and other.finer(self)
//     }
// }

// Alternative, you can use "image of net" and then use finer
define is_net_limit[K: Net, L: Net](f: K -> L) -> Bool {
    forall(b: L) {
        exists(a: K) {
            f(a) <= b
        }
    }
}

define have_common_pt[K](n: Set[Set[K]], x: K) -> Bool {
    forall(s: Set[K]) {
        s ∈ n implies x ∈ s
        // Alternative: use intersection to define
    }
}

attributes Set_Net[K] {
    define have_common_pt(self, x: K) -> Bool {
        have_common_pt(self.sets, x)
    }
}

attributes Set_Net[K] {
    define finer(self, other: Set_Net[K]) -> Bool {
        forall(b: Set[K]) {
            b ∈ other.sets implies exists(a: Set[K]) {
                a ∈ self.sets and a ⊆ b
            }
        }
    }

    define same_limit(self, other: Set_Net[K]) -> Bool {
        self.finer(other) and other.finer(self)
    }
}

// Alternative, you can use "image of net" and then use finer
define is_limit[K, L](source_net: Set_Net[K], target_net: Set_Net[L], f: K -> L) -> Bool {
    forall(b: Set[L]) {
        b ∈ target_net.sets implies exists(a: Set[K]) {
            a ∈ source_net.sets and a.image(f) ⊆ b
        }
    }
}

define elem_in_image_of_sets[K, L](n: Set[Set[K]], f: K -> L, b: Set[L]) -> Bool {
    exists(a: Set[K]) { 
        a ∈ n and b = a.image(f)
    }
}

define image_of_sets[K, L](n: Set[Set[K]], f: K -> L) -> Set[Set[L]] {
    Set[Set[L]].new(elem_in_image_of_sets(n, f))
}

theorem image_of_sets_preserve_no_empty[K, L](n: Set[Set[K]], f: K -> L) {
    no_empty(n) implies no_empty(image_of_sets(n, f))
} by {
    forall(b: Set[L]) {
        if b ∈ image_of_sets(n, f) {
            let (a: Set[K]) satisfy { 
                a ∈ n and b = a.image(f)
            }
            is_nonempty(a)
            is_nonempty(a.image(f))
            is_nonempty(b)
        }
    }
}

theorem image_of_sets_preserve_subset_two_intersection[K, L](n: Set[Set[K]], f: K -> L) {
    subset_two_intersection(n) implies subset_two_intersection(image_of_sets(n, f))
} by {
    forall(b1: Set[L], b2: Set[L]) {
        if b1 ∈ image_of_sets(n, f) and b2 ∈ image_of_sets(n, f) {
            let a1: Set[K] satisfy { a1 ∈ n and b1 = a1.image(f) }
            elem_in_image_of_sets(n, f, b2)
            let a2: Set[K] satisfy { a2 ∈ n and b2 = a2.image(f) }
            subset_two_intersection_helper_imp_by(n)
            let a: Set[K] satisfy { a ∈ n and a ⊆ a1 ∩ a2 }
            a.image(f) ⊆ (a1 ∩ a2).image(f)
            (a1 ∩ a2).image(f) ⊆ a1.image(f) ∩ a2.image(f)
            let b = a.image(f)
            b ∈ image_of_sets(n, f)
            b ⊆ b1 ∩ b2
            b ∈ image_of_sets(n, f) and b ⊆ b1 ∩ b2
        }
    }
    subset_two_intersection_helper(image_of_sets(n, f))
}

theorem image_of_sets_preserve_nets[K, L](n: Set[Set[K]], f: K -> L) {
    is_net(n) implies is_net(image_of_sets(n, f))
}

define image_of_net[K, L](n: Set_Net[K], f: K -> L) -> Set_Net[L] {
    Set_Net[L].new(image_of_sets(n.sets, f))
}

theorem image_of_net_expand[K, L](n: Set_Net[K], f: K -> L) {
    image_of_net(n, f).sets = image_of_sets(n.sets, f)
}

theorem is_limit_imp_image_of_net_finer[K, L](source_net: Set_Net[K], target_net: Set_Net[L], f: K -> L) {
    is_limit(source_net, target_net, f) implies image_of_net(source_net, f).finer(target_net)
} by {
    forall(b: Set[L]) {
        if b ∈ target_net.sets {
            let (a: Set[K]) satisfy {
                a ∈ source_net.sets and a.image(f) ⊆ b
            }
            a.image(f) ∈ image_of_sets(source_net.sets, f)
            a.image(f) ∈ image_of_net(source_net, f).sets
            a.image(f) ∈ image_of_net(source_net, f).sets and a.image(f) ⊆ b
        } 
    }    
}

theorem image_of_net_finer_imp_is_limit[K, L](source_net: Set_Net[K], target_net: Set_Net[L], f: K -> L) {
    image_of_net(source_net, f).finer(target_net) implies is_limit(source_net, target_net, f)
} by {
    forall(b: Set[L]) {
        if b ∈ target_net.sets {
            let a_image: Set[L] satisfy { 
                a_image ∈ image_of_net(source_net, f).sets and a_image ⊆ b
            }
            a_image ∈ image_of_sets(source_net.sets, f)
            elem_in_image_of_sets(source_net.sets, f, a_image)
            let a: Set[K] satisfy {
                a ∈ source_net.sets and a_image = a.image(f)
            }
            a.image(f) ⊆ b
            a ∈ source_net.sets and a.image(f) ⊆ b
        } 
    }    
}

theorem gte_trans(a: ℕ, b: ℕ, c: ℕ) { a >= b and b >= c implies a >= c } 

theorem gte_reflexive(a: ℕ) { a >= a }

theorem gte_antisymmetric(a: ℕ, b: ℕ) { a >= b and b >= a implies a = b }

theorem gte_partial_order {
    is_reflexive(ℕ.gte) and
    is_transitive(ℕ.gte) and
    is_antisymmetric(ℕ.gte)
} by {
    is_reflexive(ℕ.gte) 
    is_transitive(ℕ.gte) 
    is_antisymmetric(ℕ.gte)   
}

// // ℕ is linear order, so we can directly use it, without using set_net. But, will there be conflict on symbol `<=`? 
// instance ℕ: Partial_Order_Lte {
//     let lte = ℕ.gte
// }

// Using the linear order of ℕ

define seq_tail[K](shift: ℕ, f: ℕ -> K) -> (ℕ -> K) {
    function(n: ℕ) { f(shift + n) }
}

define elem_in_seq_tail[K](f: ℕ -> K, shift: ℕ, x: K) -> Bool {
    exists(n: ℕ) {
        x = seq_tail(shift, f)(n)
    }
}

theorem shift_gte_imp_subset[K](f: ℕ -> K, s1: ℕ, s2: ℕ) {
    s1 >= s2 implies Set[K].new(elem_in_seq_tail(f, s1)) ⊆ Set[K].new(elem_in_seq_tail(f, s2))
} by {
    forall(x: K) {
        if x ∈ Set[K].new(elem_in_seq_tail(f, s1)) {
            elem_in_seq_tail(f, s1, x)
            let n: ℕ satisfy { x = seq_tail(s1, f)(n) }

            let m: ℕ satisfy { s1 = s2 + m }
            f(s1 + n) = f(s2 + m + n)
            seq_tail(s1, f)(n) = seq_tail(s2, f)(m + n)
            elem_in_seq_tail(f, s2, x)

            x ∈ Set[K].new(elem_in_seq_tail(f, s2))
        }
    }
}

define elem_in_seq_to_net[K](f: ℕ -> K, a: Set[K]) -> Bool {
    exists(shift: ℕ) {
        a = Set[K].new(elem_in_seq_tail(f, shift))
    }
}

define seq_to_net[K](f: ℕ -> K) -> Set[Set[K]] {
    Set[Set[K]].new(elem_in_seq_to_net(f))
}

theorem seq_to_net_is_net[K](f: ℕ -> K) {
    is_net(seq_to_net(f))
} by {
    forall(a: Set[K]) {
        if a ∈ seq_to_net(f) {
            elem_in_seq_to_net(f)(a)
            let shift: ℕ satisfy { 
                a = Set[K].new(elem_in_seq_tail(f, shift))
            }
            let x: K satisfy {
                x = seq_tail(shift, f)(0)
            }
            x = f(shift)
            x ∈ a
            a != Set[K].empty_set
        }
    } 

    no_empty(seq_to_net(f))
    
    forall(a1: Set[K], a2: Set[K]) {
        if a1 ∈ seq_to_net(f) and a2 ∈ seq_to_net(f) {
            elem_in_seq_to_net(f)(a1) 
            elem_in_seq_to_net(f)(a2)
            let shift_1: ℕ satisfy {
                a1 = Set[K].new(elem_in_seq_tail(f, shift_1))
            }
            let shift_2: ℕ satisfy {
                a2 = Set[K].new(elem_in_seq_tail(f, shift_2))
            }
            let shift = shift_1.max(shift_2)
            let b = Set[K].new(elem_in_seq_tail(f, shift))
            shift_1 <= shift
            shift_2 <= shift
            b ⊆ a1
            b ⊆ a2
            b ⊆ a1 ∩ a2
            elem_in_seq_to_net(f)(b)
            b ∈ seq_to_net(f)
            b ∈ seq_to_net(f) and b ⊆ a1 ∩ a2
        }
    }
    subset_two_intersection_helper(seq_to_net(f))
    subset_two_intersection(seq_to_net(f))
}

define is_set_of_finite_intersection[K](n: Set[Set[K]], s: Set[K]) -> Bool {
    exists(c: Set[Set[K]]) {
        c ⊆ n and c.is_finite and s = intersection(c)
    }
}

define sets_of_finite_intersection[K](n: Set[Set[K]]) -> Set[Set[K]] {
    Set[Set[K]].new(is_set_of_finite_intersection(n))
}

theorem sets_of_finite_intersection_preserve_two_intersection[K](n: Set[Set[K]], s1: Set[K], s2: Set[K]) {
    s1 ∈ sets_of_finite_intersection(n) and s2 ∈ sets_of_finite_intersection(n) implies s1 ∩ s2 ∈ sets_of_finite_intersection(n)
} by {
    let c1: Set[Set[K]] satisfy {
        c1 ⊆ n and c1.is_finite and s1 = intersection(c1)
    }
    is_set_of_finite_intersection(n, s2)
    let c2: Set[Set[K]] satisfy {
        c2 ⊆ n and c2.is_finite and s2 = intersection(c2)
    }

    let c = c1 ∪ c2
    c1 ∪ c2 ⊆ n
    c ⊆ n
    c.is_finite
    c1 ⊆ c
    c2 ⊆ c
    intersection(c) ⊆ intersection(c1)
    intersection(c) ⊆ intersection(c2)
    intersection(c) ⊆ s1 ∩ s2

    forall(x: K) {
        if x ∈ s1 ∩ s2 {
            x ∈ s1
            x ∈ s2
            x ∈ intersection(c1)
            x ∈ intersection(c2)
            forall(s: Set[K]) {
                if s ∈ c {
                    if s ∈ c1 {
                        x ∈ s
                    }
                    if s ∈ c2 {
                        x ∈ s
                    }
                    x ∈ s
                }
            }
            elem_in_intersection_general(c, x)
            x ∈ intersection(c)
        }
    }
    s1 ∩ s2 ⊆ intersection(c)

    s1 ∩ s2 = intersection(c)

    s1 ∩ s2 ∈ sets_of_finite_intersection(n)
}

theorem sets_of_finite_intersection_preserve_subset_two_intersection[K](n: Set[Set[K]], s1: Set[K], s2: Set[K]) {
    subset_two_intersection(n) implies subset_two_intersection(sets_of_finite_intersection(n))
}

// helper
define list_subset_sets[K](n: Set[Set[K]], l: List[Set[K]]) -> Bool {
    forall(s: Set[K]){ s ∈ l implies s ∈ n }
}

define subset_intersection_of_list[K](n: Set[Set[K]], l: List[Set[K]]) -> Bool {
    exists(t: Set[K]) { t ∈ n and t ⊆ intersection_of_list_recursion(l) }
}

/// Also, this prove, for net, subset_two_intersection ==> subset_finite_intersection. So indeed using two intersection or finite intersection to define net is equivalent
theorem sets_of_finite_intersection_preserve_net_no_empty_lemma[K](n: Set[Set[K]], list: List[Set[K]]) {
    is_net(n)
    and is_nonempty(n)
    and list_subset_sets(n, list)
    implies 
    subset_intersection_of_list(n, list) 
} by {

    define p(l: List[Set[K]]) -> Bool {
        list_subset_sets(n, l) implies subset_intersection_of_list(n, l) 
    }

    let not_empty_set: Set[K] satisfy { not_empty_set ∈ n }
    not_empty_set ⊆ intersection_of_list_recursion(List[Set[K]].nil)
    p(List[Set[K]].nil)
    forall(head: Set[K], tail: List[Set[K]]) {
        if p(tail) {
            intersection_of_list_recursion(List.cons(head, tail)) = head ∩ intersection_of_list_recursion(tail)

            if list_subset_sets(n, List.cons(head, tail)) {
                forall(s: Set[K]){ s ∈ List.cons(head, tail) implies s ∈ n }
                head ∈ List.cons(head, tail)
                head ∈ n

                forall(s: Set[K]) {
                    if s ∈ tail {
                        s ∈ List.cons(head, tail)
                        s ∈ n
                    }
                }
                list_subset_sets(n, tail)
                subset_intersection_of_list(n, tail)

                let t_tail: Set[K] satisfy { 
                    t_tail ∈ n and t_tail ⊆ intersection_of_list_recursion(tail)
                }
                
                let t: Set[K] satisfy {
                    t ∈ n and t ⊆ head ∩ t_tail
                }

                t ⊆ head ∩ intersection_of_list_recursion(tail)
                
                t ⊆ intersection_of_list_recursion(List.cons(head, tail))

                subset_intersection_of_list(n, List.cons(head, tail))
            }
            p(List.cons(head, tail))
        }
    }
    p(list)
}

theorem sets_of_finite_intersection_preserve_net_no_empty[K](n: Set[Set[K]], list: List[Set[K]]) {
    is_net(n) and is_nonempty(n) implies no_empty(sets_of_finite_intersection(n))
} by {
    forall(s: Set[K]) {
        if s ∈ sets_of_finite_intersection(n) {
            let c: Set[Set[K]] satisfy {
                c ⊆ n and c.is_finite and s = intersection(c)
            }

            let l: List[Set[K]] satisfy {
                c.have_exact_list(l)
            }

            intersection(c) = intersection_of_list_recursion(l)

            c.contains = l.contains
            list_subset_sets(n, l)
            subset_intersection_of_list(n, l)

            let (t: Set[K]) satisfy { t ∈ n and t ⊆ intersection_of_list_recursion(l) }
            t != Set[K].empty_set
            intersection_of_list_recursion(l) != Set[K].empty_set
            s != Set[K].empty_set
        }
    }
}

theorem sets_of_finite_intersection_preserve_net[K](n: Set[Set[K]]) {
    is_net(n) and is_nonempty (n) implies is_net(sets_of_finite_intersection(n))
}

theorem net_subset_finite_intersection[K](n: Set[Set[K]], c: Set[Set[K]]) {
    is_nonempty(n) and is_net(n) and c ⊆ n and c.is_finite implies exists(t: Set[K]) { t ∈ n and t ⊆ intersection(c) }
} by {
    let l: List[Set[K]] satisfy {
        c.have_exact_list(l)
    }
    list_subset_sets(n, l)
    let (t: Set[K]) satisfy { t ∈ n and t ⊆ intersection_of_list_recursion(l) }
    intersection_of_list_recursion(l) = intersection(c)
}

theorem sets_of_finite_intersection_superset[K](n: Set[Set[K]]) {
    sets_of_finite_intersection(n) ⊇ n
} by {
    forall(s: Set[K]) {
        if s ∈ n {
            let l = List[Set[K]].singleton(s)
            intersection_of_list(l) = s
            intersection(list_to_set(l)) = intersection_of_list(l) 
            forall(t: Set[K]) {
                if t = s {
                    t ∈ l
                    t ∈ list_to_set(l)
                    list_to_set(l).contains(t) = Set[Set[K]].singleton(s).contains(t)
                } else {
                    t ∉ l
                    t ∉ list_to_set(l)
                    list_to_set(l).contains(t) = Set[Set[K]].singleton(s).contains(t)
                }
                list_to_set(l).contains(t) = Set[Set[K]].singleton(s).contains(t)
            }
            list_to_set(l).contains = Set[Set[K]].singleton(s).contains
            list_to_set(l) = Set[Set[K]].singleton(s)
            list_to_set(l) ⊆ n
            list_to_set(l).have_super_list(l)
            list_to_set(l).is_finite
            intersection(list_to_set(l)) = s
            s ∈ sets_of_finite_intersection(n)
        }
    }
}

theorem sets_of_finite_intersection_preserve_intersection[K](n: Set[Set[K]]) {
    intersection(sets_of_finite_intersection(n)) = intersection(n)
} by {
    sets_of_finite_intersection(n) ⊇ n
    intersection(sets_of_finite_intersection(n)) ⊆ intersection(n)

    forall(x: K) {
        if x ∈ intersection(n) {
            forall(s: Set[K]) {
                if s ∈ sets_of_finite_intersection(n) {
                    let c: Set[Set[K]] satisfy {
                        c ⊆ n and c.is_finite and s = intersection(c)
                    }
                    intersection(n) ⊆ intersection(c)
                    x ∈ s
                }
            }
            x ∈ intersection(sets_of_finite_intersection(n))
        }
    }
    intersection(sets_of_finite_intersection(n)) ⊇ intersection(n)
}

theorem net_from_sets_of_finite_intersection[K](n: Set[Set[K]]) {
    no_empty(sets_of_finite_intersection(n)) implies is_net(sets_of_finite_intersection(n))
} by {
    forall(a1: Set[K], a2: Set[K]) {
        if a1 ∈ sets_of_finite_intersection(n) and a2 ∈ sets_of_finite_intersection(n) {
            let a = a1 ∩ a2
            a ⊆ a1
            a ⊆ a2
            a ∈ sets_of_finite_intersection(n)
        }
    }
    subset_two_intersection(sets_of_finite_intersection(n))
}

define set_intersect_sets[K](n: Set[Set[K]], s: Set[K]) -> Bool {
    forall(t: Set[K]) {
        t ∈ n implies is_nonempty(s ∩ t)
    }
}

define elem_in_net_intersect_set[K](n: Set[Set[K]], s: Set[K], sub: Set[K]) -> Bool {
    set_intersect_sets(n, s) and exists(t: Set[K]) {
        t ∈ n and sub = s ∩ t
    }
}

define net_intersect_set[K](n: Set[Set[K]], s: Set[K]) -> Set[Set[K]] {
    Set[Set[K]].new(elem_in_net_intersect_set(n, s))
}

theorem net_intersect_set_is_net[K](n: Set[Set[K]], s: Set[K]) {
    is_net(n) and set_intersect_sets(n, s) implies is_net(net_intersect_set(n, s))
} by {
    forall(sub: Set[K]) {
        if sub ∈ net_intersect_set(n, s) {
            set_intersect_sets(n, s)
            let (t: Set[K]) satisfy {
                t ∈ n and sub = s ∩ t
            }
            is_nonempty(s ∩ t)
            is_nonempty(sub)
        }
    }
    no_empty(net_intersect_set(n, s))

    forall(a1: Set[K], a2: Set[K]) {
        if a1 ∈ net_intersect_set(n, s) and a2 ∈ net_intersect_set(n, s) {
            let (t1: Set[K]) satisfy {
                t1 ∈ n and a1 = s ∩ t1
            }
            elem_in_net_intersect_set(n, s, a2)
            let (t2: Set[K]) satisfy {
                t2 ∈ n and a2 = s ∩ t2
            }
            let t: Set[K] satisfy {
                t ∈ n and t ⊆ t1 ∩ t2
            }
            a1 ∩ a2 = (s ∩ t1) ∩ (s ∩ t2)
            (s ∩ t1) ∩ (s ∩ t2) = (s ∩ s) ∩ t1 ∩ t2
            (s ∩ s) ∩ t1 ∩ t2 = s ∩ (t1 ∩ t2)
            a1 ∩ a2 = s ∩ (t1 ∩ t2)
            let a = s ∩ t
            a ∈ net_intersect_set(n, s)
            s ∩ t ⊆ s ∩ (t1 ∩ t2)
            a ⊆ a1 ∩ a2
            a ∈ net_intersect_set(n, s) and a ⊆ a1 ∩ a2
        }
    }
    subset_two_intersection_helper(net_intersect_set(n, s))
    subset_two_intersection(net_intersect_set(n, s))
}