from set import Set, empty
from order import Partial_Order, Linear_Order, is_acyclic, is_transitive, is_reflexive, is_antisymmetric, is_nonreflexive, lte_from, lt_from, lte_to_lt_partial_order
from nat import ℕ
numerals ℕ

theorem subset_eq_is_transitive[K] {
    is_transitive(Set[K].subset_eq)
}

theorem subset_eq_is_reflexive[K] {
    is_reflexive(Set[K].subset_eq) 
}

theorem subset_eq_is_antisymmetric[K] {
    is_antisymmetric(Set[K].subset_eq)
}

theorem subset_eq_is_lte_from_subset[K] {
    Set[K].subset_eq = lte_from(Set[K].subset)
} by {
    forall(a: Set[K], b: Set[K]) {
        Set[K].subset_eq(a, b) implies lte_from(Set[K].subset)(a, b)

        Set[K].subset_eq(a, b) = lte_from(Set[K].subset)(a, b)
    }
}

theorem subset_is_lt_from_subset_eq[K] {
    Set[K].subset = lt_from(Set[K].subset_eq)
} by {
    forall(a: Set[K], b: Set[K]) {
        Set[K].subset(a, b) implies lt_from(Set[K].subset_eq)(a, b)
        Set[K].subset(a, b) = lt_from(Set[K].subset_eq)(a, b)
    }
}

theorem subset_is_partial_order[K] {
    is_acyclic(Set[K].subset) and 
    is_transitive(Set[K].subset)
} by {
    lte_to_lt_partial_order[Set[K]](Set[K].subset)
    is_transitive(Set[K].subset_eq)
    is_reflexive(Set[K].subset_eq)
    is_antisymmetric(Set[K].subset_eq)
}

let comparable[P] = Partial_Order.comparable[P]

// See #25, now Acorn not support generic types in instances of typeclasses

// instance Set[K]: Partial_Order {
//     let lt = Set[K].subset
// }

// And now Acorn not support direct subtype and dependent type. Once they are support, we can make the set c: Set[Set[K]], c.is_chain in to type 

// Subtype make type and set almost the same thing, i.e. for a: Set[K], we have subtype { x: T | x ∈ a }

// // expected param 0 to have typeclass None
// attributes Set[P: Partial_Order] {
//     define is_chain(self) -> Bool {
//         forall(a: P, b: P) {
//             a ∈ self and b ∈ self implies comparable(a, b)
//         }
//     }
// }

// Alternative? But instance cannot use type parameter, which make this unusable, even if you not use attributes but just use define with type parameter that have typeclass
attributes P: Partial_Order {
    let is_subset_chain = function(set: Set[P]) {
        forall(a: P, b: P) {
            a ∈ set and b ∈ set implies comparable(a, b)
        }
    }
}

// // #25
// structure Set_Chain[K] {
//     contains: Set[K] -> Bool
// } constraint {
//     contains.is_subset_chain
// }

// To reuse, I should use typeclass or subtype, but Acorn now does not support them well. Note that using general set is not enough, for example, you may want to use subsets with certain properties, but not just use general set

define no_empty[K](sets: Set[Set[K]]) -> Bool {
    forall(a: Set[K]) {
        a ∈ sets implies a != Set[K].empty_set
    }    
}

define subset_two_intersection[K](sets: Set[Set[K]]) -> Bool {
    forall(a1: Set[K], a2: Set[K]) {
        a1 ∈ sets and a2 ∈ sets implies exists(b: Set[K]) {
            b ∈ sets and b ⊆ a1 ∩ a2
        }
    }    
}

theorem subset_two_intersection_helper[K](sets: Set[Set[K]]) {
    forall(a1: Set[K], a2: Set[K]) {
        a1 ∈ sets and a2 ∈ sets implies exists(b: Set[K]) {
            b ∈ sets and b ⊆ a1 ∩ a2
        }
    } implies subset_two_intersection(sets) 
}

define is_set_net[K](sets: Set[Set[K]]) -> Bool {
    no_empty(sets) and subset_two_intersection(sets)
}

structure Set_Net[K] {
    sets: Set[Set[K]]
} constraint {
    is_set_net(sets)
} by {
    let x: K satisfy { true }
    let s = Set[K].singleton(x)
    let n = Set[Set[K]].singleton(s)
    forall(a: Set[K]) {
        if a ∈ n {
            a = s
            s != empty
            a != empty
        }
    }
    no_empty(n)
    forall(a1: Set[K], a2: Set[K]) {
        if a1 ∈ n and a2 ∈ n {
            a1 = s
            a2 = s
            let b = s
            b ∈ n
            b ⊆ a1 ∩ a2
            b ∈ n and b ⊆ a1 ∩ a2
        }
    }
    subset_two_intersection(n)
}

typeclass N: Net extends Partial_Order {
    directed(a: N, b: N) {
        exists(c: N) {
            c <= a and c <= b
            // note that when it's not linear order, we can't just use c = a or c = b
        }
    }
}

attributes N: Net {
    define finer(self, other: N) -> Bool {
        forall(b: N) {
            exists(a: N) {
                a <= b
            }
        }
    }

    define same_limit(self, other: N) -> Bool {
        self.finer(other) and other.finer(self)
    }
}

// Alternative, you can use "image of net" and then use finer
define is_limit[K: Net, L: Net](source_net: K, target_net: L, f: K -> L) -> Bool {
    forall(b: L) {
        exists(a: K) {
            f(a) <= b
        }
    }
}

attributes Set_Net[K] {
    define have_common_pt(self, x: K) -> Bool {
        forall(a: Set[K]) {
            a ∈ self.sets implies x ∈ a
            // Alternative: use intersection to define
        }
    }
}

// Using the linear order of ℕ. I think that it's no easy to generalize the definition of shift to general linear order in Acorn now, until the support of subtype

define seq_tail[K](shift: ℕ, f: ℕ -> K) -> (ℕ -> K) {
    function(n: ℕ) { f(shift + n) }
}

define elem_in_seq_tail[K](f: ℕ -> K, shift: ℕ, x: K) -> Bool {
    exists(n: ℕ) {
        x = seq_tail(shift, f)(n)
    }
}

theorem shift_gte_imp_subset[K](f: ℕ -> K, s1: ℕ, s2: ℕ) {
    s1 >= s2 implies Set[K].new(elem_in_seq_tail(f, s1)) ⊆ Set[K].new(elem_in_seq_tail(f, s2))
} by {
    forall(x: K) {
        if x ∈ Set[K].new(elem_in_seq_tail(f, s1)) {
            elem_in_seq_tail(f, s1, x)
            let n: ℕ satisfy { x = seq_tail(s1, f)(n) }

            let m: ℕ satisfy { s1 = s2 + m }
            f(s1 + n) = f(s2 + m + n)
            seq_tail(s1, f)(n) = seq_tail(s2, f)(m + n)
            elem_in_seq_tail(f, s2, x)

            x ∈ Set[K].new(elem_in_seq_tail(f, s2))
        }
    }
}

define elem_in_seq_to_net[K](f: ℕ -> K, a: Set[K]) -> Bool {
    exists(shift: ℕ) {
        a = Set[K].new(elem_in_seq_tail(f, shift))
    }
}

define seq_to_net[K](f: ℕ -> K) -> Set[Set[K]] {
    Set[Set[K]].new(elem_in_seq_to_net(f))
}

theorem seq_to_net_is_set_net[K](f: ℕ -> K) {
    is_set_net(seq_to_net(f))
} by {
    forall(a: Set[K]) {
        if a ∈ seq_to_net(f) {
            elem_in_seq_to_net(f)(a)
            let shift: ℕ satisfy { 
                a = Set[K].new(elem_in_seq_tail(f, shift))
            }
            let x: K satisfy {
                x = seq_tail(shift, f)(0)
            }
            x = f(shift)
            x ∈ a
            a != Set[K].empty_set
        }
    } 

    no_empty(seq_to_net(f))
    
    forall(a1: Set[K], a2: Set[K]) {
        if a1 ∈ seq_to_net(f) and a2 ∈ seq_to_net(f) {
            elem_in_seq_to_net(f)(a1) 
            elem_in_seq_to_net(f)(a2)
            let shift_1: ℕ satisfy {
                a1 = Set[K].new(elem_in_seq_tail(f, shift_1))
            }
            let shift_2: ℕ satisfy {
                a2 = Set[K].new(elem_in_seq_tail(f, shift_2))
            }
            let shift = shift_1.max(shift_2)
            let b = Set[K].new(elem_in_seq_tail(f, shift))
            shift_1 <= shift
            shift_2 <= shift
            b ⊆ a1
            b ⊆ a2
            b ⊆ a1 ∩ a2
            elem_in_seq_to_net(f)(b)
            b ∈ seq_to_net(f)
            b ∈ seq_to_net(f) and b ⊆ a1 ∩ a2
        }
    }
    subset_two_intersection_helper(seq_to_net(f))
    subset_two_intersection(seq_to_net(f))
}

// // For Interval_Chain on ℝ, we avoid Set_Chain by first use Interval_Net inherit Set[Set[ℝ]], then Interval_Chain inherit Interval_Net. The same for other "topology"
// structure Set_Chain[K] {
//     contains: Set[K] -> Bool
// } constraint {
//     Set[Set[K]].new(contains).is_chain
// }