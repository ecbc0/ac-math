from finite_set import Set, List, list_to_set, intersection_of_list_recursion
from set import intersection, elem_in_intersection_general, is_nonempty
from order import Partial_Order, Linear_Order, is_acyclic, is_transitive, is_reflexive, is_antisymmetric, is_nonreflexive, lte_from, lt_from, lte_to_lt_partial_order, Partial_Order_Lte
from nat import ℕ
from list.list_base import flatten, max_list
numerals ℕ

// And now Acorn not support direct subtype and dependent type. Once they are support, we can make the set c: Set[Set[K]], c.is_chain in to type 

// Subtype make type and set almost the same thing, i.e. for a: Set[K], we have subtype { x: T | x ∈ a }

define no_empty[K](sets: Set[Set[K]]) -> Bool {
    forall(a: Set[K]) {
        a ∈ sets implies a != Set[K].empty_set
    }    
}

define subset_two_intersection[K](sets: Set[Set[K]]) -> Bool {
    forall(a1: Set[K], a2: Set[K]) {
        a1 ∈ sets and a2 ∈ sets implies exists(b: Set[K]) {
            b ∈ sets and b ⊆ a1 ∩ a2
        }
    }    
}

theorem subset_two_intersection_helper[K](sets: Set[Set[K]]) {
    forall(a1: Set[K], a2: Set[K]) {
        a1 ∈ sets and a2 ∈ sets implies exists(b: Set[K]) {
            b ∈ sets and b ⊆ a1 ∩ a2
        }
    } implies subset_two_intersection(sets) 
}

define is_net[K](sets: Set[Set[K]]) -> Bool {
    no_empty(sets) and subset_two_intersection(sets)
}

structure Set_Net[K] {
    sets: Set[Set[K]]
} constraint {
    is_net(sets)
} by {
    let x: K satisfy { true }
    let s = Set[K].singleton(x)
    let n = Set[Set[K]].singleton(s)
    forall(a: Set[K]) {
        if a ∈ n {
            a = s
            s != Set[K].empty_set
            a != Set[K].empty_set
        }
    }
    no_empty(n)
    forall(a1: Set[K], a2: Set[K]) {
        if a1 ∈ n and a2 ∈ n {
            a1 = s
            a2 = s
            let b = s
            b ∈ n
            b ⊆ a1 ∩ a2
            b ∈ n and b ⊆ a1 ∩ a2
        }
    }
    subset_two_intersection(n)
}

typeclass N: Net extends Partial_Order {
    directed(a: N, b: N) {
        exists(c: N) {
            c <= a and c <= b
            // note that when it's not linear order, we can't just use c = a or c = b
        }
    }
}

attributes N: Net {
    define finer(self, other: N) -> Bool {
        forall(b: N) {
            exists(a: N) {
                a <= b
            }
        }
    }

    define same_limit(self, other: N) -> Bool {
        self.finer(other) and other.finer(self)
    }
}

// Alternative, you can use "image of net" and then use finer
define is_limit[K: Net, L: Net](source_net: K, target_net: L, f: K -> L) -> Bool {
    forall(b: L) {
        exists(a: K) {
            f(a) <= b
        }
    }
}

attributes Set_Net[K] {
    define have_common_pt(self, x: K) -> Bool {
        forall(a: Set[K]) {
            a ∈ self.sets implies x ∈ a
            // Alternative: use intersection to define
        }
    }
}

theorem gte_trans(a: ℕ, b: ℕ, c: ℕ) { a >= b and b >= c implies a >= c } 

theorem gte_reflexive(a: ℕ) { a >= a }

theorem gte_antisymmetric(a: ℕ, b: ℕ) { a >= b and b >= a implies a = b }

theorem gte_partial_order {
    is_reflexive(ℕ.gte) and
    is_transitive(ℕ.gte) and
    is_antisymmetric(ℕ.gte)
} by {
    is_reflexive(ℕ.gte) 
    is_transitive(ℕ.gte) 
    is_antisymmetric(ℕ.gte)   
}

// // ℕ is linear order, so we can directly use it, without using set_net. But, will there be conflict on symbol `<=`? 
// instance ℕ: Partial_Order_Lte {
//     let lte = ℕ.gte
// }

// Using the linear order of ℕ

define seq_tail[K](shift: ℕ, f: ℕ -> K) -> (ℕ -> K) {
    function(n: ℕ) { f(shift + n) }
}

define elem_in_seq_tail[K](f: ℕ -> K, shift: ℕ, x: K) -> Bool {
    exists(n: ℕ) {
        x = seq_tail(shift, f)(n)
    }
}

theorem shift_gte_imp_subset[K](f: ℕ -> K, s1: ℕ, s2: ℕ) {
    s1 >= s2 implies Set[K].new(elem_in_seq_tail(f, s1)) ⊆ Set[K].new(elem_in_seq_tail(f, s2))
} by {
    forall(x: K) {
        if x ∈ Set[K].new(elem_in_seq_tail(f, s1)) {
            elem_in_seq_tail(f, s1, x)
            let n: ℕ satisfy { x = seq_tail(s1, f)(n) }

            let m: ℕ satisfy { s1 = s2 + m }
            f(s1 + n) = f(s2 + m + n)
            seq_tail(s1, f)(n) = seq_tail(s2, f)(m + n)
            elem_in_seq_tail(f, s2, x)

            x ∈ Set[K].new(elem_in_seq_tail(f, s2))
        }
    }
}

define elem_in_seq_to_net[K](f: ℕ -> K, a: Set[K]) -> Bool {
    exists(shift: ℕ) {
        a = Set[K].new(elem_in_seq_tail(f, shift))
    }
}

define seq_to_net[K](f: ℕ -> K) -> Set[Set[K]] {
    Set[Set[K]].new(elem_in_seq_to_net(f))
}

theorem seq_to_net_is_net[K](f: ℕ -> K) {
    is_net(seq_to_net(f))
} by {
    forall(a: Set[K]) {
        if a ∈ seq_to_net(f) {
            elem_in_seq_to_net(f)(a)
            let shift: ℕ satisfy { 
                a = Set[K].new(elem_in_seq_tail(f, shift))
            }
            let x: K satisfy {
                x = seq_tail(shift, f)(0)
            }
            x = f(shift)
            x ∈ a
            a != Set[K].empty_set
        }
    } 

    no_empty(seq_to_net(f))
    
    forall(a1: Set[K], a2: Set[K]) {
        if a1 ∈ seq_to_net(f) and a2 ∈ seq_to_net(f) {
            elem_in_seq_to_net(f)(a1) 
            elem_in_seq_to_net(f)(a2)
            let shift_1: ℕ satisfy {
                a1 = Set[K].new(elem_in_seq_tail(f, shift_1))
            }
            let shift_2: ℕ satisfy {
                a2 = Set[K].new(elem_in_seq_tail(f, shift_2))
            }
            let shift = shift_1.max(shift_2)
            let b = Set[K].new(elem_in_seq_tail(f, shift))
            shift_1 <= shift
            shift_2 <= shift
            b ⊆ a1
            b ⊆ a2
            b ⊆ a1 ∩ a2
            elem_in_seq_to_net(f)(b)
            b ∈ seq_to_net(f)
            b ∈ seq_to_net(f) and b ⊆ a1 ∩ a2
        }
    }
    subset_two_intersection_helper(seq_to_net(f))
    subset_two_intersection(seq_to_net(f))
}

define is_set_of_finite_intersection[K](n: Set[Set[K]], s: Set[K]) -> Bool {
    exists(c: Set[Set[K]]) {
        c ⊆ n and c.is_finite and s = intersection(c)
    }
}

define sets_of_finite_intersection[K](n: Set[Set[K]]) -> Set[Set[K]] {
    Set[Set[K]].new(is_set_of_finite_intersection(n))
}

theorem sets_of_finite_intersection_preserve_two_intersection[K](n: Set[Set[K]], s1: Set[K], s2: Set[K]) {
    s1 ∈ sets_of_finite_intersection(n) and s2 ∈ sets_of_finite_intersection(n) implies s1 ∩ s2 ∈ sets_of_finite_intersection(n)
} by {
    let c1: Set[Set[K]] satisfy {
        c1 ⊆ n and c1.is_finite and s1 = intersection(c1)
    }
    is_set_of_finite_intersection(n, s2)
    let c2: Set[Set[K]] satisfy {
        c2 ⊆ n and c2.is_finite and s2 = intersection(c2)
    }

    let c = c1 ∪ c2
    c1 ∪ c2 ⊆ n
    c ⊆ n
    c.is_finite
    c1 ⊆ c
    c2 ⊆ c
    intersection(c) ⊆ intersection(c1)
    intersection(c) ⊆ intersection(c2)
    intersection(c) ⊆ s1 ∩ s2

    forall(x: K) {
        if x ∈ s1 ∩ s2 {
            x ∈ s1
            x ∈ s2
            x ∈ intersection(c1)
            x ∈ intersection(c2)
            forall(s: Set[K]) {
                if s ∈ c {
                    if s ∈ c1 {
                        x ∈ s
                    }
                    if s ∈ c2 {
                        x ∈ s
                    }
                    x ∈ s
                }
            }
            elem_in_intersection_general(c, x)
            x ∈ intersection(c)
        }
    }
    s1 ∩ s2 ⊆ intersection(c)

    s1 ∩ s2 = intersection(c)

    s1 ∩ s2 ∈ sets_of_finite_intersection(n)
}

theorem sets_of_finite_intersection_preserve_subset_two_intersection[K](n: Set[Set[K]], s1: Set[K], s2: Set[K]) {
    subset_two_intersection(n) implies subset_two_intersection(sets_of_finite_intersection(n))
}

// helper
define list_subset_sets[K](n: Set[Set[K]], l: List[Set[K]]) -> Bool {
    forall(s: Set[K]){ s ∈ l implies s ∈ n }
}

define subset_intersection_of_list[K](n: Set[Set[K]], l: List[Set[K]]) -> Bool {
    exists(t: Set[K]) { t ∈ n and t ⊆ intersection_of_list_recursion(l) }
}

/// Also, this prove, for net, subset_two_intersection ==> subset_finite_intersection. So indeed using two intersection or finite intersection to define net is equivalent
theorem sets_of_finite_intersection_preserve_net_no_empty_lemma[K](n: Set[Set[K]], list: List[Set[K]]) {
    is_net(n)
    and is_nonempty(n)
    and list_subset_sets(n, list)
    implies 
    subset_intersection_of_list(n, list) 
} by {

    define p(l: List[Set[K]]) -> Bool {
        list_subset_sets(n, l) implies subset_intersection_of_list(n, l) 
    }

    let not_empty_set: Set[K] satisfy { not_empty_set ∈ n }
    not_empty_set ⊆ intersection_of_list_recursion(List[Set[K]].nil)
    p(List[Set[K]].nil)
    forall(head: Set[K], tail: List[Set[K]]) {
        if p(tail) {
            intersection_of_list_recursion(List.cons(head, tail)) = head ∩ intersection_of_list_recursion(tail)

            if list_subset_sets(n, List.cons(head, tail)) {
                forall(s: Set[K]){ s ∈ List.cons(head, tail) implies s ∈ n }
                head ∈ List.cons(head, tail)
                head ∈ n

                forall(s: Set[K]) {
                    if s ∈ tail {
                        s ∈ List.cons(head, tail)
                        s ∈ n
                    }
                }
                list_subset_sets(n, tail)
                subset_intersection_of_list(n, tail)

                let t_tail: Set[K] satisfy { 
                    t_tail ∈ n and t_tail ⊆ intersection_of_list_recursion(tail)
                }
                
                let t: Set[K] satisfy {
                    t ∈ n and t ⊆ head ∩ t_tail
                }

                t ⊆ head ∩ intersection_of_list_recursion(tail)
                
                t ⊆ intersection_of_list_recursion(List.cons(head, tail))

                subset_intersection_of_list(n, List.cons(head, tail))
            }
            p(List.cons(head, tail))
        }
    }
    p(list)
}

theorem sets_of_finite_intersection_preserve_net_no_empty[K](n: Set[Set[K]], list: List[Set[K]]) {
    is_net(n) and is_nonempty(n) implies no_empty(sets_of_finite_intersection(n))
} by {
    forall(s: Set[K]) {
        if s ∈ sets_of_finite_intersection(n) {
            let c: Set[Set[K]] satisfy {
                c ⊆ n and c.is_finite and s = intersection(c)
            }

            let l: List[Set[K]] satisfy {
                c.have_exact_list(l)
            }

            intersection(c) = intersection_of_list_recursion(l)

            c.contains = l.contains
            list_subset_sets(n, l)
            subset_intersection_of_list(n, l)

            let (t: Set[K]) satisfy { t ∈ n and t ⊆ intersection_of_list_recursion(l) }
            t != Set[K].empty_set
            intersection_of_list_recursion(l) != Set[K].empty_set
            s != Set[K].empty_set
        }
    }
}

theorem sets_of_finite_intersection_preserve_net[K](n: Set[Set[K]]) {
    is_net(n) and is_nonempty (n) implies is_net(sets_of_finite_intersection(n))
}