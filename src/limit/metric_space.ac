from real import ℝ
from real.real_completeness import inf, sup, have_lower_bound, have_upper_bound, directly_closely_gt_inf_directly, have_inf, have_sup
numerals ℝ
from set import Set, intersection, is_nonempty
from limit.net import Net, no_empty, subset_two_intersection, is_net, subset_two_intersection_helper, subset_two_intersection_helper_imp_by_ver_logic, is_limit, image_of_net, net_contains_imp_subset_two_intersection
from top.top_base import Point_Net_System, Topology, converge_to
from util import id_map
from top.compact import common_limit_pt, to_closure, to_closure_net

/// A metric space is a set equipped with a distance function that satisfies specific axioms.
/// The distance function must be non-negative, symmetric, and satisfy the triangle inequality.
typeclass M: Distance_Space {
    /// Every metric space must have a distance function
    distance: (M, M) -> ℝ

    /// Rule: the distance from a point to itself is zero
    self_distance_is_zero(x: M) {
        x.distance(x) = 0
    }

    /// Rule: distance must be symmetric
    symmetric(x: M, y: M) {
        x.distance(y) = y.distance(x)
    }

    /// Rule: distance must satisfy the triangle inequality  
    /// Considering example like 1/2 norm space, we should use d(x, z) <= k(d(x, y) + d(y, z)). The best k for p norm in finite dimension (>= 2) vector space is k = 2^(1/p - 1). But for simplicity, temporarily I will just use k = 1, this exclude cases of 0 < p < 1
    triangle(x: M, y: M, z: M) {
        x.distance(z) <= x.distance(y) + y.distance(z)
    }
}

theorem distance_non_negative[M: Distance_Space](x: M, y: M) {
    x.distance(y) >= 0
} by {
    x.distance(x) <= x.distance(y) + y.distance(x)
    0 <= x.distance(y) + x.distance(y)
    if x.distance(y) < 0 {
        x.distance(y) + x.distance(y) < 0
        false
    }
    0 <= x.distance(y)
}

typeclass M: Metric_Space extends Distance_Space {
    /// Rule: distance zero means the points are equal  
    /// Cannot use in measure and integral without quotient measure zero, and quotient may introduce incovenience to code writting
    dist_zero_imp_eq(x: M, y: M) {
        x.distance(y) = 0 implies x = y
    }
}

/// The discrete metric assigns distance 0 to identical elements and distance 1 to distinct elements.
define discrete[T](x: T, y: T) -> ℝ {
    if x = y {
        0
    } else {
        1
    }
}

theorem zero_lte_discrete[T](x: T, y: T) {
    0 <= discrete(x, y)
} by {
    if x = y {
        0 <= discrete(x, y)
    } else {
        0 <= discrete(x, y)
    }
}

theorem discrete_self_distance_is_zero[T](x: T) {
    discrete(x, x) = 0
}

theorem discrete_dist_zero_imp_eq[T](x: T, y: T) {
    discrete(x, y) = 0 implies x = y
}

theorem discrete_symmetric[T](x: T, y: T) {
    discrete(x, y) = discrete(y, x)
} by {
    if x = y {
        discrete(x, y) = discrete(y, x)
    } else {
        discrete(x, y) = discrete(y, x)
    }
}

theorem discrete_triangle[T](x: T, y: T, z: T) {
    discrete(x, z) <= discrete(x, y) + discrete(y, z)
} by {
    if x = y {
        discrete(x, z) <= discrete(x, y) + discrete(y, z)
    } else {
        discrete(x, y) = 1
        0 <= discrete(y, z)
        if x = z {
            discrete(x, z) <= discrete(x, y) + discrete(y, z)
        } else {
            discrete(x, z) <= discrete(x, y) + discrete(y, z)
        }
    }
}

/// A simple enumeration type used as an example of a metric space with the discrete metric.
inductive Color {
    /// Red means nothing. It's just different from green and blue.
    red

    /// Green is not red or blue.
    green

    /// Blue is not red or green.
    blue
}

instance Color: Distance_Space {
    let distance: (Color, Color) -> ℝ = discrete
}

theorem color_dist_zero_imp_eq(x: Color, y: Color) {
    x.distance(y) = 0 implies x = y
} by {
    discrete(x, y) = 0 implies x = y
}

instance Color: Metric_Space 

define elem_in_ball[M: Distance_Space](x: M, r: ℝ, y: M) -> Bool {
    x.distance(y) < r
}

attributes M: Distance_Space {
    define ball(self, radius: ℝ) -> Set[M] {
        Set[M].new(elem_in_ball(self, radius))
    }
}

theorem self_in_ball[M: Distance_Space](x: M, r: ℝ) {
    r > 0 implies x ∈ x.ball(r)
}

define elem_in_ball_net[M: Distance_Space](x: M, s: Set[M]) -> Bool {
    exists(r: ℝ) {
        r > 0 and s = x.ball(r)
    }
}

attributes M: Distance_Space {
    define ball_net(self) -> Set[Set[M]] {
        Set[Set[M]].new(elem_in_ball_net(self))
    }
}

theorem radius_lt_imp_subset[M: Distance_Space](x: M, r1: ℝ, r2: ℝ) {
    r1 > 0 and r1 <= r2 implies x.ball(r1) ⊆ x.ball(r2) 
} by {
    forall(y: M) {
        if y ∈ x.ball(r1) {
            x.distance(y) < r1
            x.distance(y) < r2
            y ∈ x.ball(r2)
        }
    }
}

theorem ball_net_is_net[M: Distance_Space](x: M) {
    is_net(x.ball_net)
} by {
    forall(s: Set[M]) {
        if s ∈ x.ball_net {
            let r: ℝ satisfy {
                r > 0 and s = x.ball(r)
            }
            x ∈ s
            s != Set[M].empty_set
        }
    }
    no_empty(x.ball_net)
    forall(a1: Set[M], a2: Set[M]) {
        if a1 ∈ x.ball_net and a2 ∈ x.ball_net {
            let r1: ℝ satisfy {
                r1 > 0 and a1 = x.ball(r1)
            }
            elem_in_ball_net(x, a2)
            let r2: ℝ satisfy {
                r2 > 0 and a2 = x.ball(r2)
            }
            let r: ℝ satisfy {
                r = r1.min(r2)
            }
            r <= r1
            r <= r2
            r > 0
            x.ball(r) ⊆ x.ball(r1)
            x.ball(r) ⊆ a1
            x.ball(r) ⊆ x.ball(r2)
            x.ball(r) ⊆ a2
            x.ball(r) ⊆ a1 ∩ a2
            x.ball(r) ∈ x.ball_net
            x.ball(r) ∈ x.ball_net and x.ball(r) ⊆ a1 ∩ a2
        }
    }
    subset_two_intersection_helper(x.ball_net)
    subset_two_intersection(x.ball_net)
}

theorem point_net[M: Distance_Space](x: M) {
    Net.new(x.ball_net).have_common_pt(x)
} by {
    forall(s: Set[M]) {
        if s ∈ Net.new(x.ball_net) {
            s ∈ Net.new(x.ball_net).sets
            s ∈ x.ball_net
            let r: ℝ satisfy {
                r > 0 and s = x.ball(r)
            }
            x.distance(x) = 0
            x.distance(x) < r
            x ∈ s
        }
    }
}

typeclass M: Distance_Net_System extends Distance_Space, Point_Net_System {
    net_from_ball(x: M) {
        M.net(x) = Net.new(M.ball_net(x))
    }
}

theorem ball_in_net[M: Distance_Net_System](x: M, r: ℝ) {
    r > 0 implies x.ball(r) ∈ x.net
} by {
    x.net.sets = x.ball_net
    x.ball(r) ∈ x.net.sets
}

theorem choose_ball[M: Distance_Net_System](s: Set[M], x: M) {
    s ∈ x.net implies exists(r: ℝ) {
        r > 0 and s = x.ball(r)
    }
} by {
    s ∈ x.net.sets
    x.net.sets = x.ball_net
}

define elem_in_dist_set[M: Distance_Space](s: Set[M], r: ℝ) -> Bool {
    exists(x: M, y: M) {
        x ∈ s and y ∈ s and r = x.distance(y)
    }
}

define dist_set[M: Distance_Space](s: Set[M]) -> Set[ℝ] {
    Set[ℝ].new(elem_in_dist_set(s))
}

define dist[M: Distance_Space](s: Set[M]) -> ℝ {
    sup(dist_set(s))
}

theorem dist_set_gte_zero[M: Distance_Space](s: Set[M]) {
    forall(r: ℝ) {
        r ∈ dist_set(s) implies r >= 0
    }
} by {
    forall(r: ℝ) {
        if r ∈ dist_set(s) {
            let (x: M, y: M) satisfy {
                x ∈ s and y ∈ s and x.distance(y) = r
            }
            r >= 0
        } 
    }
}

theorem no_empty_imp_dist_set_contains_zero[M: Distance_Space](s: Set[M]) {
    is_nonempty(s) implies 0 ∈ dist_set(s)
} by {
    let x: M satisfy { x ∈ s }
    0 = x.distance(x)
}

theorem dist_set_have_lower_bound[M: Distance_Space](s: Set[M]) {
    is_nonempty(s) implies 0.is_set_lower_bound(dist_set(s))
}

theorem dist_set_have_inf[M: Distance_Space](s: Set[M]) {
    is_nonempty(s) implies have_inf(dist_set(s))
}

theorem no_empty_imp_dist_set_non_empty[M: Distance_Space](s: Set[M]) {
    is_nonempty(s) implies is_nonempty(dist_set(s))
} 

theorem dist_gte_zero[M: Distance_Space](s: Set[M]) {
    have_sup(dist_set(s)) implies dist(s) >= 0
} by {
    let r: ℝ satisfy {
        r ∈ dist_set(s)
    }
    r <= dist(s)
    r >= 0 
}

theorem subset_to_dist_set_subset[M: Distance_Space](s1: Set[M], s2: Set[M]) {
    s1 ⊆ s2 implies dist_set(s1) ⊆ dist_set(s2)
} by {
    forall(r: ℝ) {
        if r ∈ dist_set(s1) {
            elem_in_dist_set(s1, r)
            let (x: M, y: M) satisfy {
                x ∈ s1 and y ∈ s1 and x.distance(y) = r
            }
            x ∈ s2
            y ∈ s2
            r ∈ dist_set(s2)
        }
    }
}

theorem subset_to_dist_lte[M: Distance_Space](s1: Set[M], s2: Set[M]) {
    s1 ⊆ s2 and have_sup(dist_set(s1)) and have_sup(dist_set(s2)) implies dist(s1) <= dist(s2)
} by {
    forall(r: ℝ) {
        if r ∈ dist_set(s1) {
            elem_in_dist_set(s1, r)
            let (x: M, y: M) satisfy {
                x ∈ s1 and y ∈ s1 and x.distance(y) = r
            }
            x ∈ s2
            y ∈ s2
            r ∈ dist_set(s2)
        }
    }
    dist_set(s1) ⊆ dist_set(s2)
}

theorem dist_control_helper[M: Distance_Space](s: Set[M], r: ℝ) {
    is_nonempty(s) and r > 0 and forall(x: M, y: M) {
        x ∈ s and y ∈ s implies x.distance(y) < r
    } implies have_sup(dist_set(s)) and dist(s) <= r
} by {
    forall(d: ℝ) {
        if d ∈ dist_set(s) {
            elem_in_dist_set(s, d)
            let (x: M, y: M) satisfy {
                x ∈ s and y ∈ s and d = x.distance(y)
            }
            d < r
        }
    }
    r.is_set_upper_bound(dist_set(s))
    have_sup(dist_set(s))
    sup(dist_set(s)) <= r
    dist(s) <= r
}

define elem_in_distance_from[M: Distance_Space](s: Set[M], x: M, r: ℝ) -> Bool {
    exists(y: M) {
        y ∈ s and x.distance(y) = r
    }
}

define distance_from[M: Distance_Space](s: Set[M], x: M) -> Set[ℝ] {
    Set[ℝ].new(elem_in_distance_from(s, x))
}

theorem distance_from_gte_zero[M: Distance_Space](s: Set[M], x: M) {
    forall(r: ℝ) {
        r ∈ distance_from(s, x) implies r >= 0
    }
}

theorem distance_from_have_lower_bound[M: Distance_Space](s: Set[M], x: M) {
    have_lower_bound(distance_from(s, x))
} by {
    0.is_set_lower_bound(distance_from(s, x))
}

theorem non_empty_imp_distance_from_non_empty[M: Distance_Space](s: Set[M], x: M) {
    is_nonempty(s) implies is_nonempty(distance_from(s, x))
} by {
    let y: M satisfy {
        y ∈ s
    }
    x.distance(y) ∈ distance_from(s, x)
}

theorem non_empty_imp_have_inf[M: Distance_Space](s: Set[M], x: M) {
    is_nonempty(s) implies have_inf(distance_from(s, x))
}

theorem distance_from_inf_gte_zero[M: Distance_Space](s: Set[M], x: M) {
    inf(distance_from(s, x)) >= 0
} by {
    0.is_set_lower_bound(distance_from(s, x))
}

theorem subset_to_distance_from_subset[M: Distance_Space](s1: Set[M], s2: Set[M], x: M) {
    s1 ⊆ s2 implies distance_from(s1, x) ⊆ distance_from(s2, x)
} by {
    forall(r: ℝ) {
        if r ∈ distance_from(s1, x) {
            let y: M satisfy {
                y ∈ s1 and x.distance(y) = r
            }
            y ∈ s2
            r ∈ distance_from(s2, x)
        }
    }
}

theorem interior_have_non_zero_distance_from_inf[M: Distance_Net_System](a: Set[M], x: M) {
    x ∈ a.interior and is_nonempty(a.c) implies inf(distance_from(a.c, x)) > 0
} by {
    have_inf(distance_from(a.c, x))
    let s: Set[M] satisfy {
        s ∈ x.net and s ⊆ a
    }
    let r: ℝ satisfy {
        r > 0 and s = x.ball(r)
    }
    if inf(distance_from(a.c, x)) = 0 {
        inf(distance_from(a.c, x)) < r
        directly_closely_gt_inf_directly(distance_from(a.c, x), r)
        let ε: ℝ satisfy {
            ε ∈ distance_from(a.c, x) and ε < r
        }
        elem_in_distance_from(a.c, x, ε)
        let y: M satisfy {
            y ∈ a.c and x.distance(y) = ε
        }
        ε < r
        y ∈ x.ball(r)
        y ∈ a
        false
    }
    inf(distance_from(a.c, x)) != 0
    inf(distance_from(a.c, x)) >= 0
    inf(distance_from(a.c, x)) > 0
}

theorem distance_lt_inf_distance_from_compl_imp_in[M: Distance_Net_System](a: Set[M], x: M, y: M) {
    x.distance(y) < inf(distance_from(a.c, x)) implies y ∈ a
} by {
    if not y ∈ a {
        y ∈ a.c
        x.distance(y) ∈ distance_from(a.c, x)
        x.distance(y) >= inf(distance_from(a.c, x))
        false
    }
}

theorem not_in_imp_distance_gte_inf_distance_from_compl[M: Distance_Net_System](a: Set[M], x: M, y: M) {
    y ∉ a implies x.distance(y) >= inf(distance_from(a.c, x))
}

theorem ball_is_open_lemma[M: Distance_Net_System](x: M, r: ℝ) {
    r > 0 implies x.ball(r).interior = x.ball(r)
} by {
    forall(y: M) {
        if y ∈ x.ball(r) {
            x.distance(y) < r
            let r1 = r - x.distance(y)
            r1 > 0
            forall(z: M) {
                if z ∈ y.ball(r1) {
                    y.distance(z) < r1
                    x.distance(z) <= x.distance(y) + y.distance(z)
                    x.distance(y) + y.distance(z) < x.distance(y) + r1
                    x.distance(z) < x.distance(y) + r1
                    x.distance(y) + r1 = r
                    x.distance(z) < r
                    z ∈ x.ball(r)
                }
            }
            y.ball(r1) ⊆ x.ball(r)
            y.ball(r1) ∈ y.net
            y ∈ x.ball(r).interior
        }
    }
    x.ball(r).interior ⊇ x.ball(r)
    x.ball(r).interior ⊆ x.ball(r)
}

theorem net_limit_split_of_interior_boundary[M: Distance_Net_System](a: Set[M], x: M) {
    x ∈ a.interior implies exists(b: Set[M]) {
        b ∈ x.net and b ⊆ a.interior
    }
} by {
    if x ∈ a.interior {
        let b: Set[M] satisfy { 
            b ∈ x.net and b ⊆ a 
        }
        b ∈ x.ball_net
        let r: ℝ satisfy {
            r > 0 and b = x.ball(r)
        }
        b ⊆ a
        b.interior ⊆ a.interior
        b.interior = b
        b ∈ x.net and b ⊆ a.interior
    }
}

define is_bounded[M: Distance_Space](s: Set[M]) -> Bool {
    have_sup(dist_set(s))
}

define are_bounded[M: Distance_Space](n: Set[Set[M]]) -> Bool {
    forall(s: Set[M]) {
        s ∈ n implies is_bounded(s)
    }
}

theorem ball_is_bounded[M: Distance_Space](x: M, r: ℝ) {
    r > 0 implies is_bounded(x.ball(r))
} by {
    forall(y: M, z: M) {
        if y ∈ x.ball(r) and z ∈ x.ball(r) {
            x.distance(y) < r
            x.distance(z) < r
            y.distance(z) <= x.distance(y) + x.distance(z)
            y.distance(z) < r + r
        }
    }
    r + r > 0
    is_nonempty(x.ball(r))
    have_sup(dist_set(x.ball(r)))
}

typeclass Distance_Top extends Distance_Net_System, Topology
typeclass Metric_Top extends Distance_Top, Metric_Space

theorem ball_is_open[M: Distance_Top](x: M, r: ℝ) {
    r > 0 implies x.ball(r).is_open
}

/// also called Cauchy net
define is_dist_vanish_net[M: Distance_Space](n: Net[M]) -> Bool {
    are_bounded(n.sets) and forall(ε: ℝ) {
        ε > 0 implies exists(s: Set[M]) {
            s ∈ n and dist(s) < ε
        }
    }
}

define elme_in_zero_dist_class[M: Distance_Space](x: M, y: M) -> Bool {
    x.distance(y) = 0
}

attributes M: Distance_Space {
    define zero_dist_class(self) -> Set[M] {
        Set[M].new(elme_in_zero_dist_class(self))
    }
}

theorem zero_dist_class_is_zero_dist_class[M: Distance_Space](x: M, y: M, z: M) {
    y ∈ x.zero_dist_class and z ∈ x.zero_dist_class implies y.distance(z) = 0
} by {
    y.distance(z) <= x.distance(y) + x.distance(z)
    x.distance(y) = 0 
    x.distance(z) = 0
    y.distance(z) <= 0
    y.distance(z) = 0
}

theorem distance_space_finer_definition_expand_ball_imp[M: Distance_Top](n: Net[M], x: M) {
    n.finer(x.net) implies (
        forall(ε: ℝ) { 
            ε > 0 implies exists(a: Set[M]) { 
                a ∈ n and a ⊆ x.ball(ε) 
            } 
        }
    )
} by {
    forall(ε: ℝ) {
        if ε > 0 {
            x.ball(ε) ∈ x.net
            n.finer(x.net)
            let a: Set[M] satisfy {
                a ∈ n and a ⊆ x.ball(ε)
            }
        }
    }
}

theorem distance_space_finer_definition_expand_ball_imp_by[M: Distance_Top](n: Net[M], x: M) {
    forall(ε: ℝ) { 
        ε > 0 implies exists(a: Set[M]) { 
            a ∈ n and a ⊆ x.ball(ε) 
        } 
    } implies n.finer(x.net) 
} by {
    forall(b: Set[M]) {
        if b ∈ x.net {
            let ε: ℝ satisfy {
                ε > 0 and b = x.ball(ε)
            }
            let (a: Set[M]) satisfy { 
                a ∈ n and a ⊆ x.ball(ε)
            }
            a ∈ n and a ⊆ b
        }
    }
    n.finer(x.net) 
}

theorem distance_space_converge_to_definition_expand_ball_imp[K, M: Distance_Top](source_net: Net[K], target: M, f: K -> M) {
    converge_to(source_net, target, f) implies (
        forall(ε: ℝ) { 
            ε > 0 implies exists(a: Set[K]) { 
                a ∈ source_net and a.image(f) ⊆ target.ball(ε) 
            } 
        }
    )
} by {
    forall(ε: ℝ) {
        if ε > 0 {
            target.ball(ε) ∈ target.net
            is_limit(source_net, target.net, f)
            let a: Set[K] satisfy {
                a ∈ source_net and a.image(f) ⊆ target.ball(ε)
            }
        }
    }
}

theorem distance_space_converge_to_definition_expand_ball_imp_by[K, M: Distance_Top](source_net: Net[K], target: M, f: K -> M) {
    forall(ε: ℝ) { 
        ε > 0 implies exists(a: Set[K]) { 
            a ∈ source_net and a.image(f) ⊆ target.ball(ε) 
        } 
    } implies converge_to(source_net, target, f) 
} by {
    forall(b: Set[M]) {
        if b ∈ target.net {
            let ε: ℝ satisfy {
                ε > 0 and b = target.ball(ε)
            }
            let (a: Set[K]) satisfy { 
                a ∈ source_net and a.image(f) ⊆ target.ball(ε)
            }
            a ∈ source_net and a.image(f) ⊆ b
        }
    }
    is_limit(source_net, target.net, f)
}

theorem dist_vanish_net_if_finer[M: Distance_Top](n: Net[M], x: M, y: M) {
    is_dist_vanish_net(n) and n.finer(x.net) and n.finer(y.net) implies x.distance(y) = 0
} by {
    forall(ε: ℝ) {
        if ε > 0 {
            ε/2 > 0
            let (ax: Set[M]) satisfy {
                ax ∈ n and ax ⊆ x.ball(ε/2)
            }
            distance_space_finer_definition_expand_ball_imp(n, y)
            let (ay: Set[M]) satisfy {
                ay ∈ n and ay ⊆ y.ball(ε/2)
            }
            is_net(n.sets)
            subset_two_intersection(n.sets)
            subset_two_intersection_helper_imp_by_ver_logic(n.sets)
            ax ∈ n and ay ∈ n
            net_contains_imp_subset_two_intersection(n, ax, ay)
            let a: Set[M] satisfy {
                a ∈ n and a ⊆ ax and a ⊆ ay
            }
            is_nonempty(a)
            let z: M satisfy { z ∈ a }
            z ∈ x.ball(ε/2)
            z ∈ y.ball(ε/2)
            x.distance(z) < ε/2
            y.distance(z) < ε/2
            x.distance(y) <= x.distance(z) + y.distance(z)
            x.distance(z) + y.distance(z) < ε/2 + ε/2
            ε/2 + ε/2 = ε
            x.distance(y) < ε
        }
    }
    x.distance(y) <= 0
    x.distance(y) = 0    
}

theorem dist_vanish_net_if_converge[K, M: Distance_Top](n: Net[K], x: M, y: M, f: K -> M) {
    is_dist_vanish_net(image_of_net(n, f)) and converge_to(n, x, f) and converge_to(n, y, f) implies x.distance(y) = 0
} 

/// also called "converge net/sequence is Cauchy net/sequence"
theorem finer_imp_dist_vanish_net[M: Distance_Top](n: Net[M], x: M) {
    are_bounded(n.sets) and n.finer(x.net) implies is_dist_vanish_net(n)
} by {
    forall(ε: ℝ) {
        if ε > 0 {
            let r: ℝ satisfy { 0 < r and r < ε }
            r/2 > 0
            distance_space_finer_definition_expand_ball_imp(n, x)
            let (s: Set[M]) satisfy {
                s ∈ n and s ⊆ x.ball(r/2)
            }
            forall(y: M, z: M) {
                if y ∈ s and z ∈ s {
                    y ∈ x.ball(r/2)
                    z ∈ x.ball(r/2)
                    x.distance(y) < r/2
                    x.distance(z) < r/2
                    y.distance(z) <= x.distance(y) + x.distance(z)
                    x.distance(y) + x.distance(z) < r/2 + r/2
                    y.distance(z) < r
                }
            }
            is_nonempty(s)
            dist_control_helper(s, r)
            have_sup(dist_set(s))
            dist(s) <= r
            dist(s) < ε
            s ∈ n and dist(s) < ε
        }
    }
}

theorem converge_to_imp_dist_vanish_net[K, M: Distance_Top](n: Net[K], x: M, f: K -> M) {
    are_bounded(image_of_net(n, f).sets) and converge_to(n, x, f) implies is_dist_vanish_net(image_of_net(n, f))
} 

define dist_vanish_net_finer[M: Distance_Top](n: Net[M]) -> Bool {
    is_dist_vanish_net(n) implies exists(x: M) { n.finer(x.net) }
}

typeclass M: Complete_Distance_Top extends Distance_Top {
    /// also called "Cauchy net/sequence converge"
    complete(n: Net[M]) {
        dist_vanish_net_finer[M](n)
    }
}

typeclass M: Complete_Metric_Top extends Complete_Distance_Top, Metric_Space

theorem closure_preserve_bounded[M: Distance_Top](s: Set[M]) {
    is_nonempty(s) and is_bounded(s) implies is_bounded(s.closure) and dist(s.closure) = dist(s)
} by {
    have_sup(dist_set(s))
    forall(r: ℝ) {
        if r ∈ dist_set(s.closure) {
            forall(ε: ℝ) {
                if ε > 0 {
                    ε/2 > 0
                    elem_in_dist_set(s.closure, r)
                    let (x: M, y: M) satisfy {
                        x ∈ s.closure and y ∈ s.closure and r = x.distance(y)
                    }
                    let ux = x.ball(ε/2)
                    let uy = y.ball(ε/2)
                    ux ∈ x.net
                    uy ∈ y.net
                    is_nonempty(ux ∩ s)
                    is_nonempty(uy ∩ s)
                    let x0: M satisfy { x0 ∈ ux ∩ s }
                    let y0: M satisfy { y0 ∈ uy ∩ s }
                    x0 ∈ x.ball(ε/2)
                    y0 ∈ y.ball(ε/2)
                    x.distance(x0) < ε/2
                    y.distance(y0) < ε/2
                    x0 ∈ s
                    y0 ∈ s
                    x0.distance(y0) ∈ dist_set(s)
                    x0.distance(y0) <= sup(dist_set(s))
                    x.distance(y) <= x.distance(x0) + y.distance(x0)
                    y.distance(x0) <= y.distance(y0) + x0.distance(y0)
                    x.distance(x0) + y.distance(x0) <= x.distance(x0) + (y.distance(y0) + x0.distance(y0))
                    y.distance(y0) + x0.distance(y0) < ε/2 + sup(dist_set(s))
                    x.distance(x0) + (y.distance(y0) + x0.distance(y0)) < ε/2 + (ε/2 + sup(dist_set(s)))
                    x.distance(y) <= x.distance(x0) + (y.distance(y0) + x0.distance(y0))
                    x.distance(y) < ε/2 + (ε/2 + sup(dist_set(s)))
                    x.distance(y) < ε + sup(dist_set(s))
                    r < ε + sup(dist_set(s))
                }
            }
            r <= sup(dist_set(s))
        }
    }
    sup(dist_set(s)).is_set_upper_bound(dist_set(s.closure))
    is_nonempty(s.closure)
    have_sup(dist_set(s.closure))
    is_bounded(s.closure)
    sup(dist_set(s.closure)) <= sup(dist_set(s))
    s ⊆ s.closure
    sup(dist_set(s.closure)) >= sup(dist_set(s))
    sup(dist_set(s.closure)) = sup(dist_set(s))
    dist(s.closure) = dist(s)
}

theorem to_closure_preserve_are_bounded[M: Distance_Top](n: Set[Set[M]]) {
    no_empty(n) and are_bounded(n) implies are_bounded(to_closure(n))
} by {
    forall(s: Set[M]) {
        if s ∈ to_closure(n) {
            let s0: Set[M] satisfy { s0 ∈ n and s = s0.closure }
            is_nonempty(s0)
            is_bounded(s0)
            is_bounded(s0.closure)
            is_bounded(s)
        }
    }
}

theorem to_closure_preserve_dist_vanish_net[M: Distance_Top](n: Net[M]) {
    is_dist_vanish_net(n) implies is_dist_vanish_net(to_closure_net(n))
} by {
    are_bounded(n.sets)
    are_bounded(to_closure(n.sets))
    are_bounded(to_closure_net(n).sets)
    forall(ε: ℝ) {
        if ε > 0 {
            let s: Set[M] satisfy {
                s ∈ n and dist(s) < ε
            }
            is_nonempty(s)
            is_bounded(s)
            dist(s) = dist(s.closure)
            s.closure ∈ to_closure(n.sets)
            s.closure ∈ to_closure_net(n).sets
            dist(s.closure) < ε
            s.closure ∈ to_closure_net(n).sets and dist(s.closure) < ε
        }
    }
}