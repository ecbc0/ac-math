from top.top_base import Topology, Set, are_closed, are_open, is_net, intersection, union, limit_pt
from set import compl_of_sets
from limit.net import sets_of_finite_intersection, no_empty, directed, directed_helper, net_subset_finite_intersection, set_intersect_sets, Net
from finite_set import sets_of_finite_union, is_set_of_finite_intersection

define common_limit_pt[X: Topology](n: Set[Set[X]], x: X) -> Bool {
    forall(u: Set[X]) {
        u ∈ x.net implies set_intersect_sets(n, u)
    }
}

// Alternative: use function from net space to topology space instead of using Net or is_net in topology (they are equivalent by "image_net", but need an "extra" source_net)

define is_compact[X: Topology](s: Set[X]) -> Bool {
    forall(n: Set[Set[X]]) {
        (n).is_nonempty and is_net(n) and set_intersect_sets(n, s) implies exists(x: X) {
            x ∈ s and common_limit_pt(n, x)
        }
    }
}

define elem_in_to_closure[X: Topology](n: Set[Set[X]], s_cl: Set[X]) -> Bool {
    exists(s: Set[X]) {
        s ∈ n and s_cl = s.closure
    }
}

define to_closure[X: Topology](n: Set[Set[X]]) -> Set[Set[X]] {
    Set[Set[X]].new(elem_in_to_closure(n))
}

theorem to_closure_preserve_nonempty[X: Topology](n: Set[Set[X]]) {
    (n).is_nonempty implies (to_closure(n)).is_nonempty
} 

theorem to_closure_preserve_net[X: Topology](n: Set[Set[X]]) {
    is_net(n) implies is_net(to_closure(n))
} by {
    forall(s: Set[X]) {
        if s ∈ to_closure(n) {
            let t: Set[X] satisfy {
                t ∈ n and s = t.closure
            }
            (t).is_nonempty
            (s).is_nonempty
        }
    }
    no_empty(to_closure(n))

    forall(a1: Set[X], a2: Set[X]) {
        if a1 ∈ to_closure(n) and a2 ∈ to_closure(n) {
            let s1: Set[X] satisfy {
                s1 ∈ n and a1 = s1.closure
            }
            elem_in_to_closure(n, a2)
            let s2: Set[X] satisfy {
                s2 ∈ n and a2 = s2.closure
            }
            let s: Set[X] satisfy {
                s ∈ n and s ⊆ s1 ∩ s2
            }
            s1 ⊆ s1.closure
            s2 ⊆ s2.closure
            s1 ∩ s2 ⊆ s1.closure ∩ s2.closure
            s ⊆ s1.closure ∩ s2.closure
            s.closure ⊆ (s1.closure ∩ s2.closure).closure
            (s1.closure ∩ s2.closure).is_closed
            (s1.closure ∩ s2.closure).closure = s1.closure ∩ s2.closure
            s.closure ∈ to_closure(n)
            s.closure ⊆ a1 ∩ a2
            s.closure ∈ to_closure(n) and s.closure ⊆ a1 and s.closure ⊆ a2 
        }
    }
    directed_helper(to_closure(n))
    directed(to_closure(n))
}

define to_closure_net[X: Topology](n: Net[X]) -> Net[X] {
    Net[X].new(to_closure(n.sets))
}

theorem to_closure_net_set[X: Topology](n: Net[X]) {
    to_closure_net(n).sets = to_closure(n.sets)
} by {
    to_closure_net(n) = Net[X].new(to_closure(n.sets))
}

theorem to_closure_are_closed[X: Topology](n: Set[Set[X]]) {
    are_closed(to_closure(n))
} by {
    forall(s: Set[X]) {
        if s ∈ to_closure(n) {
            s.is_closed
        }
    }
}

theorem to_closure_preserve_set_intersect_sets[X: Topology](n: Set[Set[X]], s: Set[X]) {
    set_intersect_sets(n, s) implies set_intersect_sets(to_closure(n), s)
} by {
    forall(t: Set[X]) {
        if t ∈ to_closure(n) {
            let t0: Set[X] satisfy { t0 ∈ n and t = t0.closure }
            (s ∩ t0).is_nonempty
            t0 ⊆ t
            s ∩ t0 ⊆ s ∩ t
            (s ∩ t).is_nonempty
        }
    }
}

define is_compact_intersection[X: Topology](s: Set[X]) -> Bool {
    forall(n: Set[Set[X]]) {
        (n).is_nonempty and is_net(n) and are_closed(n) and set_intersect_sets(n, s) implies (s ∩ intersection(n)).is_nonempty
    }
}

theorem is_compact_imp_is_compact_intersection[X: Topology](s: Set[X]) {
    is_compact(s) implies is_compact_intersection(s)
} by {
    forall(n: Set[Set[X]]) {
        if (n).is_nonempty and is_net(n) and are_closed(n) and set_intersect_sets(n, s) {
            let (x: X) satisfy {
                x ∈ s and common_limit_pt(n, x)
            } 
            forall(a: Set[X]) {
                if a ∈ n {
                    forall(u: Set[X]) {
                        if u ∈ x.net {
                            (u ∩ a).is_nonempty 
                        }
                    }
                    limit_pt(a, x)
                    a.is_closed
                    x ∈ a
                }
            }
            x ∈ intersection(n)
            x ∈ s and x ∈ intersection(n)
            x ∈ s ∩ intersection(n)
            (s ∩ intersection(n)).is_nonempty
        }
    }    
}

theorem is_compact_intersection_imp_is_compact[X: Topology](s: Set[X]) {
    is_compact_intersection(s) implies is_compact(s)
} by {
    forall(n: Set[Set[X]]) {
        if (n).is_nonempty and is_net(n) and set_intersect_sets(n, s) {
            (to_closure(n)).is_nonempty
            is_net(to_closure(n))
            are_closed(to_closure(n))
            set_intersect_sets(to_closure(n), s)
            (s ∩ intersection(to_closure(n))).is_nonempty
            let x: X satisfy { x ∈ s ∩ intersection(to_closure(n)) }
            x ∈ s
            forall(u: Set[X]) {
                if u ∈ x.net {
                    forall(a: Set[X]) {
                        if a ∈ n {
                            a.closure ∈ to_closure(n)
                            x ∈ a.closure
                            (u ∩ a).is_nonempty 
                        }
                    }
                    set_intersect_sets(n, u)
                } 
            }
            common_limit_pt(n, x)
            x ∈ s and common_limit_pt(n, x)
        } 
    }
}

define is_compact_finite_intersection[X: Topology](s: Set[X]) -> Bool {
    forall(n: Set[Set[X]]) {
        (n).is_nonempty and are_closed(n) and set_intersect_sets(sets_of_finite_intersection(n), s) implies (s ∩ intersection(n)).is_nonempty
    }
}

theorem is_compact_intersection_imp_is_compact_finite_intersection[X: Topology](s: Set[X]) {
    is_compact_intersection(s) implies is_compact_finite_intersection(s)
} by {
    forall(n: Set[Set[X]]) {
        if are_closed(n) and set_intersect_sets(sets_of_finite_intersection(n), s) {
            forall(t: Set[X]) {
                if t ∈ sets_of_finite_intersection(n) {
                    (s ∩ t).is_nonempty
                    s ∩ t ⊆ t
                    (t).is_nonempty
                }
            }
            no_empty(sets_of_finite_intersection(n))
            forall(t: Set[X]) {
                if t ∈ sets_of_finite_intersection(n) {
                    let c: Set[Set[X]] satisfy {
                        c ⊆ n and c.is_finite and t = intersection(c)
                    }
                    are_closed(c)
                    intersection(c).is_closed
                    t.is_closed
                }
            }
            are_closed(sets_of_finite_intersection(n))
            is_net(sets_of_finite_intersection(n))
            (s ∩ intersection(sets_of_finite_intersection(n))).is_nonempty
            intersection(sets_of_finite_intersection(n)) = intersection(n)
            (s ∩ intersection(n)).is_nonempty
        }
    }
}

theorem is_compact_finite_intersection_imp_is_compact_intersection[X: Topology](s: Set[X]) {
    is_compact_finite_intersection(s) implies is_compact_intersection(s) 
} by {
    forall(n: Set[Set[X]]) {
        if (n).is_nonempty and is_net(n) and are_closed(n) and set_intersect_sets(n, s) {
            forall(t: Set[X]) {
                if t ∈ sets_of_finite_intersection(n) {
                    is_set_of_finite_intersection(n, t)
                    let c: Set[Set[X]] satisfy {
                        c ⊆ n and c.is_finite and t = intersection(c)
                    }
                    (n).is_nonempty and is_net(n) and c ⊆ n and c.is_finite
                    net_subset_finite_intersection(n, c)
                    let u: Set[X] satisfy {
                        u ∈ n and u ⊆ intersection(c)
                    }
                    u ⊆ t
                    s ∩ u != Set[X].empty_set
                    s ∩ u ⊆ s ∩ t
                    s ∩ t != Set[X].empty_set
                }
            }
            set_intersect_sets(sets_of_finite_intersection(n), s)
            (s ∩ intersection(sets_of_finite_intersection(n))).is_nonempty
            intersection(n) = intersection(sets_of_finite_intersection(n))
            (s ∩ intersection(n)).is_nonempty
        }
    }    
}

define set_cover_by_one_of_sets[K](s: Set[K], n: Set[Set[K]]) -> Bool {
    exists(t: Set[K]) {
        t ∈ n and s ⊆ t
    }
}

define is_compact_finite_open_cover[X: Topology](s: Set[X]) -> Bool {
    forall(n: Set[Set[X]]) {
        (n).is_nonempty and are_open(n) and s ⊆ union(n) implies set_cover_by_one_of_sets(s, sets_of_finite_union(n))
    }
}

theorem is_compact_finite_intersection_imp_is_compact_finite_open_cover[X: Topology](s: Set[X]) {
    is_compact_finite_intersection(s) implies is_compact_finite_open_cover(s)
} by {
    forall(n: Set[Set[X]]) {
        if (n).is_nonempty and are_open(n) and s ⊆ union(n) {
            (n).is_nonempty
            let sc: Set[X] satisfy { sc ∈ n }
            sc.c ∈ compl_of_sets(n)
            (compl_of_sets(n)).is_nonempty
            are_closed(compl_of_sets(n))
            s ∩ union(n).c = Set[X].empty_set
            s ∩ intersection(compl_of_sets(n)) = Set[X].empty_set
            not (s ∩ intersection(compl_of_sets(n))).is_nonempty
            not set_intersect_sets(sets_of_finite_intersection(compl_of_sets(n)), s)
            let t: Set[X] satisfy {
                t ∈ sets_of_finite_intersection(compl_of_sets(n)) and not (t ∩ s).is_nonempty
            }
            sets_of_finite_intersection(compl_of_sets(n)) = compl_of_sets(sets_of_finite_union(n))
            t ∩ s = Set[X].empty_set
            s ⊆ t.c
            t ∈ compl_of_sets(sets_of_finite_union(n))
            t.c ∈ sets_of_finite_union(n)
            set_cover_by_one_of_sets(s, sets_of_finite_union(n))
        }
    }    
}

theorem is_compact_finite_open_cover_imp_is_compact_finite_intersection[X: Topology](s: Set[X]) {
    is_compact_finite_open_cover(s) implies is_compact_finite_intersection(s)
} by {
    forall(n: Set[Set[X]]) {
        if (n).is_nonempty and are_closed(n) and set_intersect_sets(sets_of_finite_intersection(n), s) {
            (n).is_nonempty
            let sc: Set[X] satisfy { sc ∈ n }
            sc.c ∈ compl_of_sets(n)
            (compl_of_sets(n)).is_nonempty
            are_open(compl_of_sets(n))
            forall(t: Set[X]) {
                if t ∈ sets_of_finite_union(compl_of_sets(n)) {
                    t ∈ compl_of_sets(sets_of_finite_intersection(n))
                    t.c ∈ sets_of_finite_intersection(n)
                    s ∩ t.c != Set[X].empty_set
                    not s ⊆ t
                }
            }
            not set_cover_by_one_of_sets(s, sets_of_finite_union(compl_of_sets(n)))
            not s ⊆ union(compl_of_sets(n))
            s ∩ union(compl_of_sets(n)).c != Set[X].empty_set
            union(compl_of_sets(n)).c = intersection(n)
            s ∩ intersection(n) != Set[X].empty_set
        }
    }    
}