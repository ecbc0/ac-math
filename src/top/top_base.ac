from limit.net import Net, Set, is_limit
from set import empty, universe

typeclass X: Point_Net_System {
    net: X -> Net[X]

    point_net(x: X) {
        X.net(x).have_common_pt(x)
    }
}

define elem_in_interior[X: Point_Net_System](a: Set[X], x: X) -> Bool {
    exists(b: Set[X]) {
        b ∈ X.net(x) and b ⊆ a
    }
} 

define elem_in_exterior[X: Point_Net_System](a: Set[X], x: X) -> Bool {
    exists(b: Set[X]) {
        b ∈ X.net(x) and b ⊆ a.c
    }
} 

define elem_in_boundary[X: Point_Net_System](a: Set[X], x: X) -> Bool {
    forall(b: Set[X]) {
        b ∈ X.net(x) implies a ∩ b != empty[X] and a.c ∩ b != empty[X]
    }
} 

attributes Set[X: Point_Net_System] {
    define interior(self) -> Set[X] {
        Set[X].new(elem_in_interior(self))
    }

    define exterior(self) -> Set[X] {
        Set[X].new(elem_in_exterior(self))
    }

    define boundary(self) -> Set[X] {
        Set[X].new(elem_in_boundary(self))
    }
}

theorem boundary_helper[X: Point_Net_System](a: Set[X], x: X) {
    forall(b: Set[X]) {
        b ∈ X.net(x) implies a ∩ b != empty[X] and a.c ∩ b != empty[X]
    } implies x ∈ a.boundary    
}

theorem boundary_is_not_interior_or_exterior[X: Point_Net_System](a: Set[X]) {
    a.boundary = (a.interior ∪ a.exterior).c
} by {
    forall(x: X) {
        if x ∈ a.boundary {
            if x ∈ a.interior {
                let b: Set[X] satisfy {
                    b ∈ x.net and b ⊆ a
                }
                false
            }
            if x ∈ a.exterior {
                let b: Set[X] satisfy {
                    b ∈ x.net and b ⊆ a.c
                }
                false
            }
            x ∉ (a.interior ∪ a.exterior)
            x ∈ (a.interior ∪ a.exterior).c
        }
    }
    a.boundary ⊆ (a.interior ∪ a.exterior).c
    forall(x: X) {
        if x ∈ (a.interior ∪ a.exterior).c {
            x ∈ a.interior.c ∩ a.exterior.c
            x ∈ a.interior.c
            x ∈ a.exterior.c
            not x ∈ a.interior
            not x ∈ a.exterior
            forall(b: Set[X]) {
                if b ∈ x.net {
                    not b ⊆ a
                    not b ⊆ a.c
                    a ∩ b != empty[X]
                    a.c ∩ b != empty[X]
                }
            }
            boundary_helper(a, x)
            x ∈ a.boundary
        }        
    }
    a.boundary ⊇ (a.interior ∪ a.exterior).c
}

theorem interior_subset[X: Point_Net_System](a: Set[X]) {
    a.interior ⊆ a
} by {
    forall(x: X) {
        if x ∈ a.interior {
            let (b: Set[X]) satisfy {
                    b ∈ X.net(x) and b ⊆ a
            }
            x ∈ b
            x ∈ a
        }
    }
}

theorem exterior_subset[X: Point_Net_System](a: Set[X]) {
    a.exterior ⊆ a.c
} by {
    forall(x: X) {
        if x ∈ a.exterior {
            let (b: Set[X]) satisfy {
                    b ∈ X.net(x) and b ⊆ a.c
            }
            x ∈ b
            x ∈ a.c
        }
    }
}

theorem interior_exterior_separate[X: Point_Net_System](a: Set[X]) {
    a.interior ∩ a.exterior = empty[X]
} by {
    a.interior ⊆ a
    a.exterior ⊆ a.c
    a ∩ a.c = empty[X]
    a.interior ∩ a.exterior ⊆ a ∩ a.c
}

typeclass X: Topology extends Point_Net_System {
    net_limit_split_of_interior_exterior(a: Set[X], x: X) {
        (
            x ∈ a.interior implies exists(b: Set[X]) {
                b ∈ x.net and b ⊆ a.interior
            }
        ) and (
            x ∈ a.exterior implies exists(b: Set[X]) {
                b ∈ x.net and b ⊆ a.exterior
            }
        )
    }
}

define limit_pt[X: Topology](a: Set[X], x: X) -> Bool {
    forall(b: Set[X]) {
        b ∈ x.net implies a ∩ b != empty[X]
    }
}

theorem contains_imp_limit_pt[X: Topology](a: Set[X], x: X) {
    x ∈ a implies limit_pt(a, x)
}

// expected param 0 to have typeclass None
attributes Set[X: Topology] {
    define closure(self) -> Set[X] {
        Set[X].new(limit_pt(self))
    }    
}

theorem subset_closure[X: Topology](a: Set[X]) {
    a ⊆ a.closure
} by {
    forall(x: X) {
        x ∈ a implies limit_pt(a, x)
        x ∈ a implies x ∈ a.closure
    }
}

theorem closure_is_not_exterior[X: Topology](a: Set[X]) {
    a.closure = a.exterior.c
} by {
    forall(x: X) {
        if x ∈ a.closure {
            if x ∈ a.exterior {
                let b: Set[X] satisfy {
                    b ∈ x.net and b ⊆ a.c
                }
                a ∩ b = empty[X]
                false
            }
            x ∈ a.exterior.c
        }
    }
    a.closure ⊆ a.exterior.c

    forall(x: X) {
        if x ∈ a.exterior.c {
            not x ∈ a.exterior
            forall(b: Set[X]) {
                b ∈ x.net implies not b ⊆ a.c
                b ∈ x.net implies a ∩ b != empty[X]
            }
            x ∈ a.closure
        }
    }
}

theorem closure_is_interior_or_boundary[X: Topology](a: Set[X]) {
    a.closure = a.interior ∪ a.boundary
} by {
    a.closure = a.exterior.c

    a.boundary = (a.interior ∪ a.exterior).c
    
    universe[X] = a.boundary ∪ (a.interior ∪ a.exterior)

    universe[X] = (a.boundary ∪ a.interior) ∪ a.exterior

    a.boundary ∩ a.exterior = empty[X]

    (a.boundary ∪ a.interior) ∩ a.exterior = empty[X]

    a.exterior.c = a.boundary ∪ a.interior
}

attributes Set[X: Topology] {
    define is_closed(self) -> Bool {
        self.closure = self
    }
}

theorem closure_is_closed[X: Topology](a: Set[X]) {
    a.closure.is_closed
} by {
    forall(x: X) {
        if x ∈ a.closure {
            x ∈ a.closure.closure

            a.closure.contains(x) = a.closure.closure.contains(x)
        } else {
            x ∉ a.closure
            x ∈ a.exterior
            let b: Set[X] satisfy {
                b ∈ x.net and b ⊆ a.exterior
            }
            b ∩ a.closure = empty[X]
            x ∉ a.closure.closure

            a.closure.contains(x) = a.closure.closure.contains(x)
        }
    }
}

theorem closure_preserve_subset[X: Topology](a: Set[X], b: Set[X]) {
    a ⊆ b implies a.closure ⊆ b.closure
} by {
    forall(x: X) {
        if x ∈ a.closure {
            forall(c: Set[X]) {
                if c ∈ x.net {
                    a ∩ c != empty[X]
                    b ∩ c != empty[X]
                }
            }
            x ∈ b.closure
        }
    }
}

theorem closure_is_smallest_closed_superset[X: Topology](a: Set[X], b: Set[X]) {
    a ⊆ b and b.is_closed implies a.closure ⊆ b
} 

theorem boundary_is_compl_boundary[X: Topology](a: Set[X]) {
    a.c.boundary = a.boundary
} by {
    forall(x: X) {
        x ∈ a.c.boundary implies x ∈ a.boundary
        if x ∈ a.boundary {
            forall(b: Set[X]) {
                b ∈ x.net implies a ∩ b != empty[X] and a.c ∩ b != empty[X]

                b ∈ x.net implies a.c ∩ b != empty[X] and a.c.c ∩ b != empty[X]
            }
            x ∈ a.c.boundary
        } 
        x ∈ a.c.boundary iff x ∈ a.boundary
    }
}

theorem interior_is_compl_exterior[X: Topology](a: Set[X]) {
    a.c.exterior = a.interior
} by {
    forall(x: X) {
        if x ∈ a.c.exterior {
            let b: Set[X] satisfy {
                b ∈ x.net and b ⊆ a.c.c
            }
            b ⊆ a
            x ∈ a.interior
        }
    }

    a.c.exterior ⊆ a.interior

    forall(x: X) {
        if x ∈ a.interior {
            let b: Set[X] satisfy {
                b ∈ x.net and b ⊆ a
            }
            b ⊆ a.c.c
            x ∈ a.c.exterior
        }
    }

    a.c.exterior ⊇ a.interior
}

theorem exterior_is_compl_interior[X: Topology](a: Set[X]) {
    a.c.interior = a.exterior
}

theorem compl_closure_is_exterior_or_boundary[X: Topology](a: Set[X]) {
    a.c.closure = a.exterior ∪ a.boundary
}

attributes Set[X: Topology] {
    define is_open(self) -> Bool {
        self.interior = self
    }
}

theorem open_imp_compl_closed[X: Topology](a: Set[X]) {
    a.is_open implies a.c.is_closed
} 

theorem closed_imp_compl_open[X: Topology](a: Set[X]) {
    a.is_closed implies a.c.is_open
} 

theorem open_iff_compl_closed[X: Topology](a: Set[X]) {
    a.is_open iff a.c.is_closed
} by {
    a.is_open implies a.c.is_closed
}

theorem closed_iff_compl_open[X: Topology](a: Set[X]) {
    a.is_closed iff a.c.is_open
} 

theorem interior_is_open[X: Topology](a: Set[X]) {
    a.interior.is_open
}

theorem exterior_is_open[X: Topology](a: Set[X]) {
    a.exterior.is_open
}

theorem interior_preserve_subset[X: Topology](a: Set[X], b: Set[X]) {
    a ⊆ b implies a.interior ⊆ b.interior
} by {
    forall(x: X) {
        if x ∈ a.interior {
            let s: Set[X] satisfy {
                s ∈ x.net and s ⊆ a
            }
            s ⊆ b
            x ∈ b.interior
        }
    }
}

theorem interior_is_largest_open_subset[X: Topology](a: Set[X], b: Set[X]) {
    b ⊆ a and b.is_open implies b ⊆ a.interior
}

theorem empty_is_open[X: Topology](a: Set[X]) {
    a.is_empty implies a.is_open
}

from set import union, intersection

theorem union_preserve_open[X: Topology](c: Set[Set[X]]) {
    forall(s: Set[X]) {
        s ∈ c implies s.is_open
    } implies union(c).is_open
} by {
    forall(x: X) {
        if x ∈ union(c) {
            let s: Set[X] satisfy {
                x ∈ s and s ∈ c and s.is_open
            }
            s.interior = s
            let b: Set[X] satisfy {
                b ∈ x.net and b ⊆ s
            }
            b ⊆ union(c)
            x ∈ union(c).interior
        }
    }
    union(c) ⊆ union(c).interior
    union(c) = union(c).interior
    union(c).is_open
}

from limit.net import is_net, subset_two_intersection

theorem two_intersection_preserve_open[X: Topology](a: Set[X], b: Set[X]) {
    a.is_open and b.is_open implies (a ∩ b).is_open
} by {
    forall(x: X) {
        if x ∈ a ∩ b {
            x ∈ a
            a.interior = a
            let sa: Set[X] satisfy {
                sa ∈ x.net and sa ⊆ a
            }
            x ∈ b
            b.interior = b
            let sb: Set[X] satisfy {
                sb ∈ x.net and sb ⊆ b
            }
            is_net(x.net.contains)
            subset_two_intersection(x.net.contains)
            let s: Set[X] satisfy {
                s ∈ x.net and s ⊆ sa ∩ sb
            }
            sa ∩ sb ⊆ a ∩ b
            x ∈ (a ∩ b).interior
        }
    }
    (a ∩ b) ⊆ (a ∩ b).interior
    (a ∩ b) = (a ∩ b).interior
    (a ∩ b).is_open    
}

from set import union_index

theorem union_index_preserve_open[I, X: Topology](f: I -> Set[X]) {
    forall(i: I) {
        f(i).is_open
    } implies union_index(f).is_open
} by {
    forall(x: X) {
        if x ∈ union_index(f) {
            let i: I satisfy {
                x ∈ f(i) and f(i).is_open
            }
            f(i).interior = f(i)
            let b: Set[X] satisfy {
                b ∈ x.net and b ⊆ f(i)
            }
            b ⊆ union_index(f)
            x ∈ union_index(f).interior
        }
    }
    union_index(f) ⊆ union_index(f).interior
    union_index(f) = union_index(f).interior
    union_index(f).is_open
}

define is_continuous[X: Topology, Y: Topology](f: X -> Y) -> Bool {
    forall(v: Set[Y]) {
        v.is_open implies forall(x: X) { 
            f(x) ∈ v implies exists(u: Set[X]) {
                u.is_open and x ∈ u and u.image(f) ⊆ v
            }
        }
    }
}

theorem continuous_imp_inv_image_preserve_open[X: Topology, Y: Topology](f: X -> Y) {
    is_continuous(f) implies forall(v: Set[Y]) {
        v.is_open implies v.inv_image(f).is_open
    } 
} by {
    forall(v: Set[Y]) {
        if v.is_open {
            let open_cover(x: X) -> u: Set[X] satisfy {
                if f(x) ∈ v {
                    u.is_open and x ∈ u and u.image(f) ⊆ v
                } else {
                    u = empty[X]
                }
            }
            forall(x: X) { 
                open_cover(x) ⊆ v.inv_image(f) 
            }
            union_index(open_cover) ⊆ v.inv_image(f)
            forall(x: X) {
                if x ∈ v.inv_image(f) {
                    f(x) ∈ v
                    x ∈ open_cover(x)
                    x ∈ union_index(open_cover)
                }
            }
            v.inv_image(f) ⊆ union_index(open_cover)
            union_index(open_cover) = v.inv_image(f)
            union_index(open_cover).is_open
            v.inv_image(f).is_open
        }
    } 
}

theorem inv_image_preserve_open_imp_continuous[X: Topology, Y: Topology](f: X -> Y) {
    forall(v: Set[Y]) {
        v.is_open implies v.inv_image(f).is_open
    } implies is_continuous(f) 
} 

theorem continuous_imp_inv_image_preserve_closed[X: Topology, Y: Topology](f: X -> Y) {
    is_continuous(f) implies forall(b: Set[Y]) {
        b.is_closed implies b.inv_image(f).is_closed
    } 
}

theorem inv_image_preserve_closed_imp_continuous[X: Topology, Y: Topology](f: X -> Y) {
    forall(b: Set[Y]) {
        b.is_closed implies b.inv_image(f).is_closed
    } implies is_continuous(f) 
}

theorem continuous_imp_inv_image_closure_subset_closure_inv_image[X: Topology, Y: Topology](f: X -> Y, b: Set[Y]) {
    is_continuous(f) implies b.inv_image(f).closure ⊆ b.closure.inv_image(f)
} by {
    b ⊆ b.closure
    b.inv_image(f) ⊆ b.closure.inv_image(f)
    b.closure.inv_image(f).is_closed
}

theorem continuous_imp_interior_inv_image_subset_inv_image_interior[X: Topology, Y: Topology](f: X -> Y, v: Set[Y]) {
    is_continuous(f) implies v.interior.inv_image(f) ⊆ v.inv_image(f).interior
} by {
    v.interior ⊆ v
    v.interior.inv_image(f) ⊆ v.inv_image(f)
    v.interior.inv_image(f).is_open
}

// Topology from open set version to net version: supplement all finite intersections to the open sets to get a net at each point. The open sets can be recovered using the construction method of open sets for nets.