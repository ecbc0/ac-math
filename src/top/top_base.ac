from limit.net import Net, Set, is_limit
from set import empty, universe, union, intersection, compl_of_sets, union_index, is_nonempty
from limit.net import is_net, subset_two_intersection
from finite_set import list_to_set, List

typeclass X: Point_Net_System {
    net: X -> Net[X]

    point_net(x: X) {
        X.net(x).have_common_pt(x)
    }
}

theorem contains_common_pt[X: Point_Net_System](x: X, s: Set[X]) {
    s ∈ x.net implies x ∈ s
}

define elem_in_interior[X: Point_Net_System](a: Set[X], x: X) -> Bool {
    exists(b: Set[X]) {
        b ∈ X.net(x) and b ⊆ a
    }
} 

define elem_in_exterior[X: Point_Net_System](a: Set[X], x: X) -> Bool {
    exists(b: Set[X]) {
        b ∈ X.net(x) and b ⊆ a.c
    }
} 

define elem_in_boundary[X: Point_Net_System](a: Set[X], x: X) -> Bool {
    forall(b: Set[X]) {
        b ∈ X.net(x) implies a ∩ b != empty[X] and a.c ∩ b != empty[X]
    }
} 

attributes Set[X: Point_Net_System] {
    define interior(self) -> Set[X] {
        Set[X].new(elem_in_interior(self))
    }

    define exterior(self) -> Set[X] {
        Set[X].new(elem_in_exterior(self))
    }

    define boundary(self) -> Set[X] {
        Set[X].new(elem_in_boundary(self))
    }
}

theorem boundary_helper[X: Point_Net_System](a: Set[X], x: X) {
    forall(b: Set[X]) {
        b ∈ X.net(x) implies a ∩ b != empty[X] and a.c ∩ b != empty[X]
    } implies x ∈ a.boundary    
}

theorem boundary_is_not_interior_or_exterior[X: Point_Net_System](a: Set[X]) {
    a.boundary = (a.interior ∪ a.exterior).c
} by {
    forall(x: X) {
        if x ∈ a.boundary {
            if x ∈ a.interior {
                let b: Set[X] satisfy {
                    b ∈ x.net and b ⊆ a
                }
                false
            }
            if x ∈ a.exterior {
                let b: Set[X] satisfy {
                    b ∈ x.net and b ⊆ a.c
                }
                false
            }
            x ∉ (a.interior ∪ a.exterior)
            x ∈ (a.interior ∪ a.exterior).c
        }
    }
    a.boundary ⊆ (a.interior ∪ a.exterior).c
    forall(x: X) {
        if x ∈ (a.interior ∪ a.exterior).c {
            x ∈ a.interior.c ∩ a.exterior.c
            x ∈ a.interior.c
            x ∈ a.exterior.c
            not x ∈ a.interior
            not x ∈ a.exterior
            forall(b: Set[X]) {
                if b ∈ x.net {
                    not b ⊆ a
                    not b ⊆ a.c
                    a ∩ b != empty[X]
                    a.c ∩ b != empty[X]
                }
            }
            boundary_helper(a, x)
            x ∈ a.boundary
        }        
    }
    a.boundary ⊇ (a.interior ∪ a.exterior).c
}

theorem interior_subset[X: Point_Net_System](a: Set[X]) {
    a.interior ⊆ a
} by {
    forall(x: X) {
        if x ∈ a.interior {
            let (b: Set[X]) satisfy {
                b ∈ X.net(x) and b ⊆ a
            }
            x ∈ b
            x ∈ a
        }
    }
}

theorem exterior_subset[X: Point_Net_System](a: Set[X]) {
    a.exterior ⊆ a.c
} by {
    forall(x: X) {
        if x ∈ a.exterior {
            let (b: Set[X]) satisfy {
                    b ∈ X.net(x) and b ⊆ a.c
            }
            x ∈ b
            x ∈ a.c
        }
    }
}

theorem interior_exterior_separate[X: Point_Net_System](a: Set[X]) {
    a.interior ∩ a.exterior = empty[X]
} by {
    a.interior ⊆ a
    a.exterior ⊆ a.c
    a ∩ a.c = empty[X]
    a.interior ∩ a.exterior ⊆ a ∩ a.c
}

theorem boundary_is_compl_boundary[X: Point_Net_System](a: Set[X]) {
    a.c.boundary = a.boundary
} by {
    forall(x: X) {
        if x ∈ a.c.boundary {
            forall(b: Set[X]) {
                b ∈ x.net implies a.c ∩ b != empty[X] and a.c.c ∩ b != empty[X]
                b ∈ x.net implies a ∩ b != empty[X] and a.c ∩ b != empty[X]
            }
            x ∈ a.boundary            
        }
        if x ∈ a.boundary {
            forall(b: Set[X]) {
                b ∈ x.net implies a ∩ b != empty[X] and a.c ∩ b != empty[X]

                b ∈ x.net implies a.c ∩ b != empty[X] and a.c.c ∩ b != empty[X]
            }
            x ∈ a.c.boundary
        } 
        x ∈ a.c.boundary iff x ∈ a.boundary
    }
}

theorem interior_is_compl_exterior[X: Point_Net_System](a: Set[X]) {
    a.c.exterior = a.interior
} by {
    forall(x: X) {
        if x ∈ a.c.exterior {
            let b: Set[X] satisfy {
                b ∈ x.net and b ⊆ a.c.c
            }
            b ⊆ a
            x ∈ a.interior
        }
    }

    a.c.exterior ⊆ a.interior

    forall(x: X) {
        if x ∈ a.interior {
            let b: Set[X] satisfy {
                b ∈ x.net and b ⊆ a
            }
            b ⊆ a.c.c
            x ∈ a.c.exterior
        }
    }

    a.c.exterior ⊇ a.interior
}

theorem exterior_is_compl_interior[X: Point_Net_System](a: Set[X]) {
    a.c.interior = a.exterior
}

// For the proof of ℝ as instance of Topology, use distance function and infimum, to show that if x ∈ a.interior then exist δ > 0 s.t. forall(y: ℝ) { |x - y| < δ ==> y ∈ a.interior }
typeclass X: Topology extends Point_Net_System {
    net_limit_split_of_interior_boundary(a: Set[X], x: X) {
        x ∈ a.interior implies exists(b: Set[X]) {
            b ∈ x.net and b ⊆ a.interior
        }
    }
}

theorem net_limit_split_of_exterior_boundary[X: Topology](a: Set[X], x: X) {
    x ∈ a.exterior implies exists(b: Set[X]) {
        b ∈ x.net and b ⊆ a.exterior
    }
}

define limit_pt[X: Topology](a: Set[X], x: X) -> Bool {
    forall(b: Set[X]) {
        b ∈ x.net implies a ∩ b != empty[X]
    }
}

theorem contains_imp_limit_pt[X: Topology](a: Set[X], x: X) {
    x ∈ a implies limit_pt(a, x)
} by {
    forall(b: Set[X]) {
        if b ∈ x.net {
            x ∈ b
            x ∈ a ∩ b
            a ∩ b != empty[X]
        }
    }    
}

// expected param 0 to have typeclass None
attributes Set[X: Topology] {
    define closure(self) -> Set[X] {
        Set[X].new(limit_pt(self))
    }    
}

theorem closure_contains_limit_pt[X: Topology](a: Set[X], x: X) {
    limit_pt(a, x) implies x ∈ a.closure
}

theorem subset_closure[X: Topology](a: Set[X]) {
    a ⊆ a.closure
} by {
    forall(x: X) {
        x ∈ a implies limit_pt(a, x)
        x ∈ a implies x ∈ a.closure
    }
}

theorem closure_preserve_nonempty[X: Topology](a: Set[X], b: Set[X]) {
    is_nonempty(a) implies is_nonempty(a.closure)
} by {
    a ⊆ a.closure
}

theorem closure_is_not_exterior[X: Topology](a: Set[X]) {
    a.closure = a.exterior.c
} by {
    forall(x: X) {
        if x ∈ a.closure {
            if x ∈ a.exterior {
                let b: Set[X] satisfy {
                    b ∈ x.net and b ⊆ a.c
                }
                a ∩ b = empty[X]
                false
            }
            x ∈ a.exterior.c
        }
    }
    a.closure ⊆ a.exterior.c

    forall(x: X) {
        if x ∈ a.exterior.c {
            not x ∈ a.exterior
            forall(b: Set[X]) {
                b ∈ x.net implies not b ⊆ a.c
                b ∈ x.net implies a ∩ b != empty[X]
            }
            x ∈ a.closure
        }
    }
}

theorem closure_is_interior_or_boundary[X: Topology](a: Set[X]) {
    a.closure = a.interior ∪ a.boundary
} by {
    a.closure = a.exterior.c

    a.boundary = (a.interior ∪ a.exterior).c
    
    universe[X] = a.boundary ∪ (a.interior ∪ a.exterior)

    universe[X] = (a.boundary ∪ a.interior) ∪ a.exterior

    a.boundary ∩ a.exterior = empty[X]

    (a.boundary ∪ a.interior) ∩ a.exterior = empty[X]

    a.exterior.c = a.boundary ∪ a.interior
}

attributes Set[X: Topology] {
    define is_closed(self) -> Bool {
        self.closure = self
    }
}

theorem closure_is_closed[X: Topology](a: Set[X]) {
    a.closure.is_closed
} by {
    forall(x: X) {
        if x ∈ a.closure {
            x ∈ a.closure.closure

            a.closure.contains(x) = a.closure.closure.contains(x)
        } else {
            x ∉ a.closure
            x ∈ a.exterior
            let b: Set[X] satisfy {
                b ∈ x.net and b ⊆ a.exterior
            }
            b ∩ a.closure = empty[X]
            x ∉ a.closure.closure

            a.closure.contains(x) = a.closure.closure.contains(x)
        }
    }
}

theorem closed_contains_limit_pt[X: Topology](a: Set[X], x: X) {
    limit_pt(a, x) and a.is_closed implies x ∈ a
}

theorem closure_preserve_subset[X: Topology](a: Set[X], b: Set[X]) {
    a ⊆ b implies a.closure ⊆ b.closure
} by {
    forall(x: X) {
        if x ∈ a.closure {
            forall(c: Set[X]) {
                if c ∈ x.net {
                    a ∩ c != empty[X]
                    b ∩ c != empty[X]
                }
            }
            x ∈ b.closure
        }
    }
}

theorem closure_is_smallest_closed_superset[X: Topology](a: Set[X], b: Set[X]) {
    a ⊆ b and b.is_closed implies a.closure ⊆ b
} 

theorem compl_closure_is_exterior_or_boundary[X: Topology](a: Set[X]) {
    a.c.closure = a.exterior ∪ a.boundary
}

attributes Set[X: Topology] {
    define is_open(self) -> Bool {
        self.interior = self
    }
}

theorem open_imp_compl_closed[X: Topology](a: Set[X]) {
    a.is_open implies a.c.is_closed
} 

theorem closed_imp_compl_open[X: Topology](a: Set[X]) {
    a.is_closed implies a.c.is_open
} 

theorem open_iff_compl_closed[X: Topology](a: Set[X]) {
    a.is_open iff a.c.is_closed
} by {
    a.is_open implies a.c.is_closed
}

theorem closed_iff_compl_open[X: Topology](a: Set[X]) {
    a.is_closed iff a.c.is_open
} 

theorem interior_is_open[X: Topology](a: Set[X]) {
    a.interior.is_open
}

theorem exterior_is_open[X: Topology](a: Set[X]) {
    a.exterior.is_open
}

theorem interior_preserve_subset[X: Topology](a: Set[X], b: Set[X]) {
    a ⊆ b implies a.interior ⊆ b.interior
} by {
    forall(x: X) {
        if x ∈ a.interior {
            let s: Set[X] satisfy {
                s ∈ x.net and s ⊆ a
            }
            s ⊆ b
            x ∈ b.interior
        }
    }
}

theorem interior_is_largest_open_subset[X: Topology](a: Set[X], b: Set[X]) {
    b ⊆ a and b.is_open implies b ⊆ a.interior
}

theorem empty_is_open[X: Topology](a: Set[X]) {
    a.is_empty implies a.is_open
}

define are_open[X: Topology](n: Set[Set[X]]) -> Bool {
    forall(s: Set[X]) {
        s ∈ n implies s.is_open
    }
}

theorem union_preserve_open[X: Topology](c: Set[Set[X]]) {
    are_open(c) implies union(c).is_open
} by {
    forall(x: X) {
        if x ∈ union(c) {
            let s: Set[X] satisfy {
                x ∈ s and s ∈ c and s.is_open
            }
            s.interior = s
            elem_in_interior(s, x)
            let b: Set[X] satisfy {
                b ∈ x.net and b ⊆ s
            }
            b ⊆ union(c)
            x ∈ union(c).interior
        }
    }
    union(c) ⊆ union(c).interior
    union(c) = union(c).interior
    union(c).is_open
}

define are_closed[X: Topology](n: Set[Set[X]]) -> Bool {
    forall(s: Set[X]) {
        s ∈ n implies s.is_closed
    }
}

theorem are_closed_compl[X: Topology](n: Set[Set[X]]) {
    are_closed(n) implies are_open(compl_of_sets(n))
} by {
    forall(s: Set[X]) {
        if s ∈ compl_of_sets(n) {
            s.c ∈ n
            s.c.is_closed
            s.is_open
        }
    }    
}

theorem are_open_compl[X: Topology](n: Set[Set[X]]) {
    are_open(n) implies are_closed(compl_of_sets(n))
}

theorem intersection_preserve_closed[X: Topology](c: Set[Set[X]]) {
    are_closed(c) implies intersection(c).is_closed
} by {
    forall(s: Set[X]) {
        if s ∈ compl_of_sets(c) {
            s.c ∈ c
            s.c.is_closed
            s.is_open
        }
    }
    union(compl_of_sets(c)).is_open
    union(compl_of_sets(c)).c.is_closed
    union(compl_of_sets(c)).c = intersection(compl_of_sets(compl_of_sets(c)))
    intersection(compl_of_sets(compl_of_sets(c))) = intersection(c)
    intersection(c).is_closed
}

theorem two_intersection_preserve_closed[X: Topology](a1: Set[X], a2: Set[X]) {
    a1.is_closed and a2.is_closed implies (a1 ∩ a2).is_closed
} by {
    a1 ∩ a2 = intersection(list_to_set(List.cons(a1, List.singleton(a2))))
    forall(s: Set[X]) {
        if s ∈ list_to_set(List.cons(a1, List.singleton(a2))) {
            s.is_closed
        }
    }
    are_closed(list_to_set(List.cons(a1, List.singleton(a2))))
}

theorem two_intersection_preserve_open[X: Topology](a: Set[X], b: Set[X]) {
    a.is_open and b.is_open implies (a ∩ b).is_open
} by {
    forall(x: X) {
        if x ∈ a ∩ b {
            x ∈ a
            a.interior = a
            x ∈ a.interior
            let sa: Set[X] satisfy {
                sa ∈ x.net and sa ⊆ a
            }
            x ∈ b
            b.interior = b
            x ∈ b.interior
            let sb: Set[X] satisfy {
                sb ∈ x.net and sb ⊆ b
            }
            is_net(x.net.sets)
            subset_two_intersection(x.net.sets)
            let s: Set[X] satisfy {
                s ∈ x.net and s ⊆ sa ∩ sb
            }
            sa ∩ sb ⊆ a ∩ b
            x ∈ (a ∩ b).interior
        }
    }
    (a ∩ b) ⊆ (a ∩ b).interior
    (a ∩ b) = (a ∩ b).interior
    (a ∩ b).is_open    
}

theorem union_index_preserve_open[I, X: Topology](f: I -> Set[X]) {
    forall(i: I) {
        f(i).is_open
    } implies union_index(f).is_open
} by {
    forall(x: X) {
        if x ∈ union_index(f) {
            let i: I satisfy {
                x ∈ f(i) and f(i).is_open
            }
            f(i).interior = f(i)
            elem_in_interior(f(i), x)
            let b: Set[X] satisfy {
                b ∈ x.net and b ⊆ f(i)
            }
            b ⊆ union_index(f)
            x ∈ union_index(f).interior
        }
    }
    union_index(f) ⊆ union_index(f).interior
    union_index(f) = union_index(f).interior
    union_index(f).is_open
}

define is_continuous[X: Topology, Y: Topology](f: X -> Y) -> Bool {
    forall(v: Set[Y]) {
        v.is_open implies forall(x: X) { 
            f(x) ∈ v implies exists(u: Set[X]) {
                u.is_open and x ∈ u and u.image(f) ⊆ v
            }
        }
    }
}

theorem continuous_imp_inv_image_preserve_open[X: Topology, Y: Topology](f: X -> Y) {
    is_continuous(f) implies forall(v: Set[Y]) {
        v.is_open implies v.inv_image(f).is_open
    } 
} by {
    forall(v: Set[Y]) {
        if v.is_open {
            let open_cover(x: X) -> u: Set[X] satisfy {
                if f(x) ∈ v {
                    u.is_open and x ∈ u and u.image(f) ⊆ v
                } else {
                    u = empty[X]
                }
            }
            forall(x: X) { 
                open_cover(x).image(f) ⊆ v
                open_cover(x) ⊆ v.inv_image(f) 
            }
            union_index(open_cover) ⊆ v.inv_image(f)
            forall(x: X) {
                if x ∈ v.inv_image(f) {
                    f(x) ∈ v
                    x ∈ open_cover(x)
                    x ∈ union_index(open_cover)
                }
            }
            v.inv_image(f) ⊆ union_index(open_cover)
            union_index(open_cover) = v.inv_image(f)
            union_index(open_cover).is_open
            v.inv_image(f).is_open
        }
    } 
}

theorem inv_image_preserve_open_imp_continuous[X: Topology, Y: Topology](f: X -> Y) {
    forall(v: Set[Y]) {
        v.is_open implies v.inv_image(f).is_open
    } implies is_continuous(f) 
} 

theorem continuous_imp_inv_image_preserve_closed[X: Topology, Y: Topology](f: X -> Y) {
    is_continuous(f) implies forall(b: Set[Y]) {
        b.is_closed implies b.inv_image(f).is_closed
    } 
}

theorem inv_image_preserve_closed_imp_continuous[X: Topology, Y: Topology](f: X -> Y) {
    forall(b: Set[Y]) {
        b.is_closed implies b.inv_image(f).is_closed
    } implies is_continuous(f) 
}

theorem continuous_imp_inv_image_closure_subset_closure_inv_image[X: Topology, Y: Topology](f: X -> Y, b: Set[Y]) {
    is_continuous(f) implies b.inv_image(f).closure ⊆ b.closure.inv_image(f)
} by {
    b ⊆ b.closure
    b.inv_image(f) ⊆ b.closure.inv_image(f)
    b.closure.inv_image(f).is_closed
}

theorem continuous_imp_interior_inv_image_subset_inv_image_interior[X: Topology, Y: Topology](f: X -> Y, v: Set[Y]) {
    is_continuous(f) implies v.interior.inv_image(f) ⊆ v.inv_image(f).interior
} by {
    v.interior ⊆ v
    v.interior.inv_image(f) ⊆ v.inv_image(f)
    v.interior.inv_image(f).is_open
}

// Topology from open set version to net version: supplement all finite intersections to the open sets to get a net at each point. Then prove two definition of open set is the same

/// Topology converge is not defined by intersection of image of source_net, which have a too weak control of the order relation, say, if you consider the ℝ subset defined as distance of all of intersection of subcollection of source_net, then there are too many arbitrary infinite intersection, while net only assure that it have some element subset finite intersection.  
/// Topology does have some extra property that concern the intersection of image of source_net, i.e. the theory of compactness
define converge_to[K, X: Topology](source_net: Net[K], target: X, f: K -> X) -> Bool {
    is_limit(source_net, target.net, f)
}

theorem converge_to_definition_expand[K, X: Topology](source_net: Net[K], target: X, f: K -> X) {
    forall(b: Set[X]) {
        b ∈ target.net implies exists(a: Set[K]) {
            a ∈ source_net and a.image(f) ⊆ b
        }
    } implies is_limit(source_net, target.net, f)
}