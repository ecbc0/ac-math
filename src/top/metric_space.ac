from real import ℝ
from real.real_completeness import inf, sup, have_lower_bound, have_upper_bound, directly_closely_gt_inf_directly, have_inf, have_sup
numerals ℝ
from set import Set, intersection
from limit.net import Net, no_empty, directed, is_net, directed_helper, directed_helper_imp_by_ver_intersection, is_limit, image_of_net, net_contains_imp_directed, set_intersect_sets, subnet_sets, elem_in_subnet_sets, subnet, finer_helper
from top.top_base import Point_Net_System, Topology, converge_to, is_open_net, is_open_net_system, is_continuous, limit_at_every_point
from util import id_map
from top.compact import common_limit_pt, to_closure, to_closure_net

/// A metric space is a set equipped with a distance function that satisfies specific axioms.
/// The distance function must be non-negative, symmetric, and satisfy the triangle inequality.
typeclass M: Distance_Space {
    /// Every metric space must have a distance function
    distance: (M, M) -> ℝ

    /// Rule: the distance from a point to itself is zero
    self_distance_is_zero(x: M) {
        x.distance(x) = 0
    }

    /// Rule: distance must be symmetric
    symmetric(x: M, y: M) {
        x.distance(y) = y.distance(x)
    }

    /// Rule: distance must satisfy the triangle inequality  
    /// Considering example like 1/2 norm space, we should use d(x, z) <= k(d(x, y) + d(y, z)). The best k for p norm in finite dimension (>= 2) vector space is k = 2^(1/p - 1). But for simplicity, temporarily I will just use k = 1, this exclude cases of 0 < p < 1
    triangle(x: M, y: M, z: M) {
        x.distance(z) <= x.distance(y) + y.distance(z)
    }
}

theorem distance_non_negative[M: Distance_Space](x: M, y: M) {
    x.distance(y) >= 0
} by {
    x.distance(x) <= x.distance(y) + y.distance(x)
    0 <= x.distance(y) + x.distance(y)
    if x.distance(y) < 0 {
        x.distance(y) + x.distance(y) < 0
        false
    }
    0 <= x.distance(y)
}

typeclass M: Metric_Space extends Distance_Space {
    /// Rule: distance zero means the points are equal  
    /// Cannot use in measure and integral without quotient measure zero, and quotient may introduce incovenience to code writting
    dist_zero_imp_eq(x: M, y: M) {
        x.distance(y) = 0 implies x = y
    }
}

/// The discrete metric assigns distance 0 to identical elements and distance 1 to distinct elements.
define discrete[T](x: T, y: T) -> ℝ {
    if x = y {
        0
    } else {
        1
    }
}

theorem zero_lte_discrete[T](x: T, y: T) {
    0 <= discrete(x, y)
} by {
    if x = y {
        0 <= discrete(x, y)
    } else {
        0 <= discrete(x, y)
    }
}

theorem discrete_self_distance_is_zero[T](x: T) {
    discrete(x, x) = 0
}

theorem discrete_dist_zero_imp_eq[T](x: T, y: T) {
    discrete(x, y) = 0 implies x = y
}

theorem discrete_symmetric[T](x: T, y: T) {
    discrete(x, y) = discrete(y, x)
} by {
    if x = y {
        discrete(x, y) = discrete(y, x)
    } else {
        discrete(x, y) = discrete(y, x)
    }
}

theorem discrete_triangle[T](x: T, y: T, z: T) {
    discrete(x, z) <= discrete(x, y) + discrete(y, z)
} by {
    if x = y {
        discrete(x, z) <= discrete(x, y) + discrete(y, z)
    } else {
        discrete(x, y) = 1
        0 <= discrete(y, z)
        if x = z {
            discrete(x, z) <= discrete(x, y) + discrete(y, z)
        } else {
            discrete(x, z) <= discrete(x, y) + discrete(y, z)
        }
    }
}

/// A simple enumeration type used as an example of a metric space with the discrete metric.
inductive Color {
    /// Red means nothing. It's just different from green and blue.
    red

    /// Green is not red or blue.
    green

    /// Blue is not red or green.
    blue
}

instance Color: Distance_Space {
    let distance: (Color, Color) -> ℝ = discrete
}

theorem color_dist_zero_imp_eq(x: Color, y: Color) {
    x.distance(y) = 0 implies x = y
} by {
    discrete(x, y) = 0 implies x = y
}

instance Color: Metric_Space 

define elem_in_ball[M: Distance_Space](x: M, r: ℝ, y: M) -> Bool {
    x.distance(y) < r
}

attributes M: Distance_Space {
    define ball(self, radius: ℝ) -> Set[M] {
        Set[M].new(elem_in_ball(self, radius))
    }
}

theorem self_in_ball[M: Distance_Space](x: M, r: ℝ) {
    r > 0 implies x ∈ x.ball(r)
}

define elem_in_ball_net[M: Distance_Space](x: M, s: Set[M]) -> Bool {
    exists(r: ℝ) {
        r > 0 and s = x.ball(r)
    }
}

attributes M: Distance_Space {
    define ball_net(self) -> Set[Set[M]] {
        Set[Set[M]].new(elem_in_ball_net(self))
    }
}

theorem radius_lt_imp_subset[M: Distance_Space](x: M, r1: ℝ, r2: ℝ) {
    r1 > 0 and r1 <= r2 implies x.ball(r1) ⊆ x.ball(r2) 
} by {
    forall(y: M) {
        if y ∈ x.ball(r1) {
            x.distance(y) < r1
            x.distance(y) < r2
            y ∈ x.ball(r2)
        }
    }
}

theorem ball_net_is_net[M: Distance_Space](x: M) {
    is_net(x.ball_net)
} by {
    forall(s: Set[M]) {
        if s ∈ x.ball_net {
            let r: ℝ satisfy {
                r > 0 and s = x.ball(r)
            }
            x ∈ s
            s != Set[M].empty_set
        }
    }
    no_empty(x.ball_net)
    forall(a1: Set[M], a2: Set[M]) {
        if a1 ∈ x.ball_net and a2 ∈ x.ball_net {
            let r1: ℝ satisfy {
                r1 > 0 and a1 = x.ball(r1)
            }
            elem_in_ball_net(x, a2)
            let r2: ℝ satisfy {
                r2 > 0 and a2 = x.ball(r2)
            }
            let r: ℝ satisfy {
                r = r1.min(r2)
            }
            r <= r1
            r <= r2
            r > 0
            x.ball(r) ⊆ x.ball(r1)
            x.ball(r) ⊆ a1
            x.ball(r) ⊆ x.ball(r2)
            x.ball(r) ⊆ a2
            x.ball(r) ∈ x.ball_net
            x.ball(r) ∈ x.ball_net and x.ball(r) ⊆ a1 and x.ball(r) ⊆ a2
        }
    }
    directed_helper(x.ball_net)
    directed(x.ball_net)
}

theorem point_net[M: Distance_Space](x: M) {
    Net.new(x.ball_net).have_common_pt(x)
} by {
    forall(s: Set[M]) {
        if s ∈ Net.new(x.ball_net) {
            s ∈ Net.new(x.ball_net).sets
            s ∈ x.ball_net
            let r: ℝ satisfy {
                r > 0 and s = x.ball(r)
            }
            x.distance(x) = 0
            x.distance(x) < r
            x ∈ s
        }
    }
}

typeclass M: Distance_Net_System extends Distance_Space, Point_Net_System {
    net_from_ball(x: M) {
        M.net(x) = Net.new(M.ball_net(x))
    }
}

theorem ball_in_net[M: Distance_Net_System](x: M, r: ℝ) {
    r > 0 implies x.ball(r) ∈ x.net
} by {
    x.net.sets = x.ball_net
    x.ball(r) ∈ x.net.sets
}

theorem choose_ball[M: Distance_Net_System](s: Set[M], x: M) {
    s ∈ x.net implies exists(r: ℝ) {
        r > 0 and s = x.ball(r)
    }
} by {
    s ∈ x.net.sets
    x.net.sets = x.ball_net
}

define elem_in_dist_set[M: Distance_Space](s: Set[M], r: ℝ) -> Bool {
    exists(x: M, y: M) {
        x ∈ s and y ∈ s and r = x.distance(y)
    }
}

// Todo: rename to diam?
define dist_set[M: Distance_Space](s: Set[M]) -> Set[ℝ] {
    Set[ℝ].new(elem_in_dist_set(s))
}

theorem dist_set_helper[M: Distance_Space](s: Set[M], r: ℝ) {
    r ∈ dist_set(s) implies exists(x: M, y: M) {
        x ∈ s and y ∈ s and r = x.distance(y)
    }
} by {
    elem_in_dist_set(s, r)
}

theorem empty_to_empty_dist_set[M: Distance_Space] {
    dist_set(Set[M].empty_set) = Set[ℝ].empty_set
} by {
    forall(r: ℝ) {
        if r ∈ dist_set(Set[M].empty_set) {
            let (x: M, y: M) satisfy {
                x ∈ Set[M].empty_set and y ∈ Set[M].empty_set and r = x.distance(y)
            }
            false
        }
        not r ∈ dist_set(Set[M].empty_set)
    }
    dist_set(Set[M].empty_set).contains = Set[ℝ].empty_set.contains
}

// Todo: rename to diam (diameter)?
define dist[M: Distance_Space](s: Set[M]) -> ℝ {
    if s.is_empty {
        0
    } else {
        sup(dist_set(s))
    }
}

theorem lte_dist[M: Distance_Space](s: Set[M], r: ℝ) {
    have_sup(dist_set(s)) and r ∈ dist_set(s) implies r <= dist(s)
} by {
    if s.is_empty {
        dist_set(s).is_empty
        not r ∈ dist_set(s)
    } else {
        s.is_nonempty
        r <= sup(dist_set(s))
        dist(s) = sup(dist_set(s))
    }
}

theorem dist_is_least_upper[M: Distance_Space](s: Set[M], r: ℝ) {
    have_sup(dist_set(s)) and r.is_set_upper_bound(dist_set(s)) implies dist(s) <= r
} by {
    if s.is_empty {
        dist_set(s).is_empty
        not have_sup(dist_set(s))
    } else {
        sup(dist_set(s)) <= r
        dist(s) = sup(dist_set(s))
    }
}

theorem dist_set_gte_zero[M: Distance_Space](s: Set[M]) {
    forall(r: ℝ) {
        r ∈ dist_set(s) implies r >= 0
    }
} by {
    forall(r: ℝ) {
        if r ∈ dist_set(s) {
            let (x: M, y: M) satisfy {
                x ∈ s and y ∈ s and x.distance(y) = r
            }
            r >= 0
        } 
    }
}

theorem nonempty_imp_dist_set_contains_zero[M: Distance_Space](s: Set[M]) {
    (s).is_nonempty implies 0 ∈ dist_set(s)
} by {
    let x: M satisfy { x ∈ s }
    0 = x.distance(x)
}

theorem dist_set_have_lower_bound[M: Distance_Space](s: Set[M]) {
    (s).is_nonempty implies 0.is_set_lower_bound(dist_set(s))
}

theorem dist_set_have_inf[M: Distance_Space](s: Set[M]) {
    (s).is_nonempty implies have_inf(dist_set(s))
}

theorem nonempty_imp_dist_set_nonempty[M: Distance_Space](s: Set[M]) {
    (s).is_nonempty implies (dist_set(s)).is_nonempty
} 

theorem dist_gte_zero[M: Distance_Space](s: Set[M]) {
    have_sup(dist_set(s)) implies dist(s) >= 0
} by {
    let r: ℝ satisfy {
        r ∈ dist_set(s)
    }
    r <= dist(s)
    r >= 0 
}

theorem subset_to_dist_set_subset[M: Distance_Space](s1: Set[M], s2: Set[M]) {
    s1 ⊆ s2 implies dist_set(s1) ⊆ dist_set(s2)
} by {
    forall(r: ℝ) {
        if r ∈ dist_set(s1) {
            elem_in_dist_set(s1, r)
            let (x: M, y: M) satisfy {
                x ∈ s1 and y ∈ s1 and x.distance(y) = r
            }
            x ∈ s2
            y ∈ s2
            r ∈ dist_set(s2)
        }
    }
}

theorem subset_to_dist_lte[M: Distance_Space](s1: Set[M], s2: Set[M]) {
    s1 ⊆ s2 and have_sup(dist_set(s1)) and have_sup(dist_set(s2)) implies dist(s1) <= dist(s2)
} by {
    forall(r: ℝ) {
        if r ∈ dist_set(s1) {
            elem_in_dist_set(s1, r)
            let (x: M, y: M) satisfy {
                x ∈ s1 and y ∈ s1 and x.distance(y) = r
            }
            x ∈ s2
            y ∈ s2
            r ∈ dist_set(s2)
        }
    }
    dist_set(s1) ⊆ dist_set(s2)
}

theorem dist_control_helper[M: Distance_Space](s: Set[M], r: ℝ) {
    (s).is_nonempty and r > 0 and forall(x: M, y: M) {
        x ∈ s and y ∈ s implies x.distance(y) < r
    } implies have_sup(dist_set(s)) and dist(s) <= r
} by {
    forall(d: ℝ) {
        if d ∈ dist_set(s) {
            elem_in_dist_set(s, d)
            let (x: M, y: M) satisfy {
                x ∈ s and y ∈ s and d = x.distance(y)
            }
            d < r
        }
    }
    r.is_set_upper_bound(dist_set(s))
    have_sup(dist_set(s))
    sup(dist_set(s)) <= r
    dist(s) <= r
}

theorem have_sup_control[M: Distance_Space](s1: Set[M], s2: Set[M]) {
    (s1).is_nonempty and s1 ⊆ s2 and have_sup(dist_set(s2)) implies have_sup(dist_set(s1))
}

define elem_in_distance_from[M: Distance_Space](s: Set[M], x: M, r: ℝ) -> Bool {
    exists(y: M) {
        y ∈ s and x.distance(y) = r
    }
}

define distance_from[M: Distance_Space](s: Set[M], x: M) -> Set[ℝ] {
    Set[ℝ].new(elem_in_distance_from(s, x))
}

theorem empty_to_empty_distance_from[M: Distance_Space](x: M) {
    distance_from(Set[M].empty_set, x) = Set[ℝ].empty_set
} by {
    forall(r: ℝ) {
        if r ∈ distance_from(Set[M].empty_set, x) {
            let (y: M) satisfy {
                y ∈ Set[M].empty_set and x.distance(y) = r
            }
            false
        }
    }
    distance_from(Set[M].empty_set, x).contains = Set[ℝ].empty_set.contains
}

theorem distance_from_gte_zero[M: Distance_Space](s: Set[M], x: M) {
    forall(r: ℝ) {
        r ∈ distance_from(s, x) implies r >= 0
    }
} by {
    if s.is_empty {
        distance_from(s, x).is_empty
        forall(r: ℝ) {
            not r ∈ distance_from(s, x)
        }
    } else {
        forall(r: ℝ) {
            if r ∈ distance_from(s, x) {
                let (y: M) satisfy {
                    y ∈ s and x.distance(y) = r
                }
                r >= 0
            }
        }        
    }
}

theorem distance_from_have_lower_bound[M: Distance_Space](s: Set[M], x: M) {
    have_lower_bound(distance_from(s, x))
} by {
    0.is_set_lower_bound(distance_from(s, x))
}

theorem non_empty_imp_distance_from_non_empty[M: Distance_Space](s: Set[M], x: M) {
    (s).is_nonempty implies (distance_from(s, x)).is_nonempty
} by {
    let y: M satisfy {
        y ∈ s
    }
    x.distance(y) ∈ distance_from(s, x)
}

theorem non_empty_imp_have_inf[M: Distance_Space](s: Set[M], x: M) {
    (s).is_nonempty implies have_inf(distance_from(s, x))
}

theorem distance_from_inf_gte_zero[M: Distance_Space](s: Set[M], x: M) {
    inf(distance_from(s, x)) >= 0
} by {
    0.is_set_lower_bound(distance_from(s, x))
}

theorem subset_to_distance_from_subset[M: Distance_Space](s1: Set[M], s2: Set[M], x: M) {
    s1 ⊆ s2 implies distance_from(s1, x) ⊆ distance_from(s2, x)
} by {
    forall(r: ℝ) {
        if r ∈ distance_from(s1, x) {
            let y: M satisfy {
                y ∈ s1 and x.distance(y) = r
            }
            y ∈ s2
            r ∈ distance_from(s2, x)
        }
    }
}

theorem interior_have_non_zero_distance_from_inf[M: Distance_Net_System](a: Set[M], x: M) {
    x ∈ a.interior and (a.c).is_nonempty implies inf(distance_from(a.c, x)) > 0
} by {
    have_inf(distance_from(a.c, x))
    let s: Set[M] satisfy {
        s ∈ x.net and s ⊆ a
    }
    let r: ℝ satisfy {
        r > 0 and s = x.ball(r)
    }
    if inf(distance_from(a.c, x)) = 0 {
        inf(distance_from(a.c, x)) < r
        directly_closely_gt_inf_directly(distance_from(a.c, x), r)
        let ε: ℝ satisfy {
            ε ∈ distance_from(a.c, x) and ε < r
        }
        elem_in_distance_from(a.c, x, ε)
        let y: M satisfy {
            y ∈ a.c and x.distance(y) = ε
        }
        ε < r
        y ∈ x.ball(r)
        y ∈ a
        false
    }
    inf(distance_from(a.c, x)) != 0
    inf(distance_from(a.c, x)) >= 0
    inf(distance_from(a.c, x)) > 0
}

theorem distance_lt_inf_distance_from_compl_imp_in[M: Distance_Net_System](a: Set[M], x: M, y: M) {
    x.distance(y) < inf(distance_from(a.c, x)) implies y ∈ a
} by {
    if not y ∈ a {
        y ∈ a.c
        x.distance(y) ∈ distance_from(a.c, x)
        x.distance(y) >= inf(distance_from(a.c, x))
        false
    }
}

theorem not_in_imp_distance_gte_inf_distance_from_compl[M: Distance_Net_System](a: Set[M], x: M, y: M) {
    y ∉ a implies x.distance(y) >= inf(distance_from(a.c, x))
}

theorem ball_is_open_lemma[M: Distance_Net_System](x: M, r: ℝ) {
    r > 0 implies x.ball(r).interior = x.ball(r)
} by {
    forall(y: M) {
        if y ∈ x.ball(r) {
            x.distance(y) < r
            let r1 = r - x.distance(y)
            r1 > 0
            forall(z: M) {
                if z ∈ y.ball(r1) {
                    y.distance(z) < r1
                    x.distance(z) <= x.distance(y) + y.distance(z)
                    x.distance(y) + y.distance(z) < x.distance(y) + r1
                    x.distance(z) < x.distance(y) + r1
                    x.distance(y) + r1 = r
                    x.distance(z) < r
                    z ∈ x.ball(r)
                }
            }
            y.ball(r1) ⊆ x.ball(r)
            y.ball(r1) ∈ y.net
            y ∈ x.ball(r).interior
        }
    }
    x.ball(r).interior ⊇ x.ball(r)
    x.ball(r).interior ⊆ x.ball(r)
}

theorem net_limit_split_of_interior_boundary[M: Distance_Net_System](a: Set[M], x: M) {
    x ∈ a.interior implies exists(b: Set[M]) {
        b ∈ x.net and b ⊆ a.interior
    }
} by {
    if x ∈ a.interior {
        let b: Set[M] satisfy { 
            b ∈ x.net and b ⊆ a 
        }
        b ∈ x.ball_net
        let r: ℝ satisfy {
            r > 0 and b = x.ball(r)
        }
        b ⊆ a
        b.interior ⊆ a.interior
        b.interior = b
        b ∈ x.net and b ⊆ a.interior
    }
}

define is_bounded[M: Distance_Space](s: Set[M]) -> Bool {
    s.is_empty or have_sup(dist_set(s))
}

define are_bounded[M: Distance_Space](n: Set[Set[M]]) -> Bool {
    forall(s: Set[M]) {
        s ∈ n implies is_bounded(s)
    }
}

theorem ball_is_bounded[M: Distance_Space](x: M, r: ℝ) {
    r > 0 implies is_bounded(x.ball(r))
} by {
    forall(y: M, z: M) {
        if y ∈ x.ball(r) and z ∈ x.ball(r) {
            x.distance(y) < r
            x.distance(z) < r
            y.distance(z) <= x.distance(y) + x.distance(z)
            y.distance(z) < r + r
        }
    }
    r + r > 0
    (x.ball(r)).is_nonempty
    have_sup(dist_set(x.ball(r)))
}

theorem is_bounded_control[M: Distance_Space](s1: Set[M], s2: Set[M]) {
    s1 ⊆ s2 and is_bounded(s2) implies is_bounded(s1)
} by {
    if s2.is_empty {
        s1.is_empty
        is_bounded(s1)
    } else {
        (s2).is_nonempty
        is_bounded(s1)
    }
}

typeclass Distance_Top extends Distance_Net_System, Topology
typeclass Metric_Top extends Distance_Top, Metric_Space

theorem ball_is_open[M: Distance_Top](x: M, r: ℝ) {
    r > 0 implies x.ball(r).is_open
}

theorem distance_top_is_open_net_system[M: Distance_Top] {
    is_open_net_system(M.net)
} by {
    forall(x: M) {
        forall(s: Set[M]) {
            if s ∈ x.net {
                s ∈ x.ball_net
                s.is_open
            }
        }
        is_open_net(x.net)
    }
}

/// also called Cauchy net
define is_dist_vanish_net[M: Distance_Space](n: Net[M]) -> Bool {
    forall(ε: ℝ) {
        ε > 0 implies exists(s: Set[M]) {
            s ∈ n and is_bounded(s) and dist(s) < ε
        }
    }
}

theorem is_dist_vanish_net_helper[M: Distance_Space](n: Net[M]) {
    forall(ε: ℝ) {
        ε > 0 implies exists(s: Set[M]) {
            s ∈ n and is_bounded(s) and dist(s) < ε
        }
    } implies is_dist_vanish_net(n)
}

define elem_in_zero_dist_class[M: Distance_Space](x: M, y: M) -> Bool {
    x.distance(y) = 0
}

attributes M: Distance_Space {
    define zero_dist_class(self) -> Set[M] {
        Set[M].new(elem_in_zero_dist_class(self))
    }
}

theorem zero_dist_class_is_zero_dist_class[M: Distance_Space](x: M, y: M, z: M) {
    y ∈ x.zero_dist_class and z ∈ x.zero_dist_class implies y.distance(z) = 0
} by {
    y.distance(z) <= x.distance(y) + x.distance(z)
    x.distance(y) = 0 
    x.distance(z) = 0
    y.distance(z) <= 0
    y.distance(z) = 0
}

theorem distance_space_finer_definition_expand_ball_imp[M: Distance_Top](n: Net[M], x: M) {
    n.finer(x.net) implies (
        forall(ε: ℝ) { 
            ε > 0 implies exists(a: Set[M]) { 
                a ∈ n and a ⊆ x.ball(ε) 
            } 
        }
    )
} by {
    forall(ε: ℝ) {
        if ε > 0 {
            x.ball(ε) ∈ x.net
            n.finer(x.net)
            let a: Set[M] satisfy {
                a ∈ n and a ⊆ x.ball(ε)
            }
        }
    }
}

theorem distance_space_finer_definition_expand_ball_imp_by[M: Distance_Top](n: Net[M], x: M) {
    forall(ε: ℝ) { 
        ε > 0 implies exists(a: Set[M]) { 
            a ∈ n and a ⊆ x.ball(ε) 
        } 
    } implies n.finer(x.net) 
} by {
    forall(b: Set[M]) {
        if b ∈ x.net {
            let ε: ℝ satisfy {
                ε > 0 and b = x.ball(ε)
            }
            let (a: Set[M]) satisfy { 
                a ∈ n and a ⊆ x.ball(ε)
            }
            a ∈ n and a ⊆ b
        }
    }
    n.finer(x.net) 
}

theorem distance_space_converge_to_definition_expand_ball_imp[K, M: Distance_Top](source_net: Net[K], target: M, f: K -> M) {
    converge_to(source_net, target, f) implies (
        forall(ε: ℝ) { 
            ε > 0 implies exists(a: Set[K]) { 
                a ∈ source_net and a.image(f) ⊆ target.ball(ε) 
            } 
        }
    )
} by {
    forall(ε: ℝ) {
        if ε > 0 {
            target.ball(ε) ∈ target.net
            is_limit(source_net, target.net, f)
            let a: Set[K] satisfy {
                a ∈ source_net and a.image(f) ⊆ target.ball(ε)
            }
        }
    }
}

theorem distance_space_converge_to_definition_expand_ball_imp_by[K, M: Distance_Top](source_net: Net[K], target: M, f: K -> M) {
    forall(ε: ℝ) { 
        ε > 0 implies exists(a: Set[K]) { 
            a ∈ source_net and a.image(f) ⊆ target.ball(ε) 
        } 
    } implies converge_to(source_net, target, f) 
} by {
    forall(b: Set[M]) {
        if b ∈ target.net {
            let ε: ℝ satisfy {
                ε > 0 and b = target.ball(ε)
            }
            let (a: Set[K]) satisfy { 
                a ∈ source_net and a.image(f) ⊆ target.ball(ε)
            }
            a ∈ source_net and a.image(f) ⊆ b
        }
    }
    is_limit(source_net, target.net, f)
}

theorem limit_unique[M: Distance_Top](n: Net[M], x: M, y: M) {
    n.finer(x.net) and n.finer(y.net) implies x.distance(y) = 0
} by {
    forall(ε: ℝ) {
        if ε > 0 {
            ε/2 > 0
            let (ax: Set[M]) satisfy {
                ax ∈ n and ax ⊆ x.ball(ε/2)
            }
            distance_space_finer_definition_expand_ball_imp(n, y)
            let (ay: Set[M]) satisfy {
                ay ∈ n and ay ⊆ y.ball(ε/2)
            }
            is_net(n.sets)
            directed(n.sets)
            directed_helper_imp_by_ver_intersection(n.sets)
            ax ∈ n and ay ∈ n
            net_contains_imp_directed(n, ax, ay)
            let a: Set[M] satisfy {
                a ∈ n and a ⊆ ax and a ⊆ ay
            }
            (a).is_nonempty
            let z: M satisfy { z ∈ a }
            z ∈ x.ball(ε/2)
            z ∈ y.ball(ε/2)
            x.distance(z) < ε/2
            y.distance(z) < ε/2
            x.distance(y) <= x.distance(z) + y.distance(z)
            x.distance(z) + y.distance(z) < ε/2 + ε/2
            ε/2 + ε/2 = ε
            x.distance(y) < ε
        }
    }
    x.distance(y) <= 0
    x.distance(y) = 0    
}

theorem fn_limit_unique[K, M: Distance_Top](n: Net[K], x: M, y: M, f: K -> M) {
    converge_to(n, x, f) and converge_to(n, y, f) implies x.distance(y) = 0
} 

theorem limit_unique_ver_metric[M: Metric_Top](n: Net[M], x: M, y: M) {
    n.finer(x.net) and n.finer(y.net) implies x = y
} 

theorem fn_limit_unique_ver_metric[K, M: Metric_Top](n: Net[K], x: M, y: M, f: K -> M) {
    converge_to(n, x, f) and converge_to(n, y, f) implies x = y
} 

/// also called "converge net/sequence is Cauchy net/sequence"
theorem finer_imp_dist_vanish_net[M: Distance_Top](n: Net[M], x: M) {
    n.finer(x.net) implies is_dist_vanish_net(n)
} by {
    forall(ε: ℝ) {
        if ε > 0 {
            let r: ℝ satisfy { 0 < r and r < ε }
            r/2 > 0
            distance_space_finer_definition_expand_ball_imp(n, x)
            let (s: Set[M]) satisfy {
                s ∈ n and s ⊆ x.ball(r/2)
            }
            is_bounded(s)
            forall(y: M, z: M) {
                if y ∈ s and z ∈ s {
                    y ∈ x.ball(r/2)
                    z ∈ x.ball(r/2)
                    x.distance(y) < r/2
                    x.distance(z) < r/2
                    y.distance(z) <= x.distance(y) + x.distance(z)
                    x.distance(y) + x.distance(z) < r/2 + r/2
                    y.distance(z) < r
                }
            }
            (s).is_nonempty
            dist_control_helper(s, r)
            have_sup(dist_set(s))
            dist(s) <= r
            dist(s) < ε
            s ∈ n and is_bounded(s) and dist(s) < ε
        }
    }
}

theorem converge_to_imp_dist_vanish_net[K, M: Distance_Top](n: Net[K], x: M, f: K -> M) {
    converge_to(n, x, f) implies is_dist_vanish_net(image_of_net(n, f))
} 

define dist_vanish_net_finer[M: Distance_Top](n: Net[M]) -> Bool {
    is_dist_vanish_net(n) implies exists(x: M) { n.finer(x.net) }
}

typeclass M: Complete_Distance_Top extends Distance_Top {
    /// also called "Cauchy net/sequence converge"
    complete(n: Net[M]) {
        dist_vanish_net_finer[M](n)
    }
}

typeclass M: Complete_Metric_Top extends Complete_Distance_Top, Metric_Space

theorem dist_vanish_bounded_tail[M: Distance_Top](n: Net[M]) {
    is_dist_vanish_net(n) implies exists(sub_n: Net[M]) {
        are_bounded(sub_n.sets) and is_dist_vanish_net(sub_n) and (sub_n).same_limit(n)
    }
} by {
    1 > 0
    let s: Set[M] satisfy {
        s ∈ n and is_bounded(s) and dist(s) < 1
    }
    forall(t: Set[M]) {
        if t ∈ n {
            (s ∩ t).is_nonempty
        }
    }
    set_intersect_sets(n.sets, s)
    let sub_n = subnet(n, s)
    forall(a: Set[M]) {
        if a ∈ sub_n.sets {
            a ∈ subnet_sets(n.sets, s)
            elem_in_subnet_sets(n.sets, s, a)
            let t: Set[M] satisfy {
                t ∈ n.sets and a = s ∩ t
            }
            a ⊆ s
            is_bounded(a)
        }
    }
    are_bounded(sub_n.sets)
    forall(ε: ℝ) {
        if ε > 0 {
            let t: Set[M] satisfy {
                t ∈ n and is_bounded(t) and dist(t) < ε
            }
            s ∩ t ∈ sub_n
            is_bounded(s ∩ t)
            (t).is_nonempty
            (s ∩ t).is_nonempty
            s ∩ t ⊆ t
            have_sup(dist_set(s ∩ t))
            have_sup(dist_set(t))
            dist(s ∩ t) <= dist(t)
            dist(s ∩ t) < ε
            s ∩ t ∈ sub_n and is_bounded(s ∩ t) and dist(s ∩ t) < ε
        }
    }
    is_dist_vanish_net_helper(sub_n)
    is_dist_vanish_net(sub_n)
    forall(t: Set[M]) {
        if t ∈ n {
            s ∩ t ⊆ s
            s ∩ t ∈ sub_n
            s ∩ t ∈ sub_n and s ∩ t ⊆ s
        }
    }
    (sub_n).finer(n)
    forall(a: Set[M]) {
        if a ∈ sub_n {
            a ∈ subnet(n, s)
            let t: Set[M] satisfy {
                t ∈ n and a = s ∩ t
            }
            let b: Set[M] satisfy {
                b ∈ n and b ⊆ s ∩ t
            }
            b ∈ n and b ⊆ a
        }
    }
    finer_helper(n, sub_n)
    (n).finer(sub_n)
    (sub_n).finer(n) and (n).finer(sub_n)
}

theorem closure_preserve_bounded[M: Distance_Top](s: Set[M]) {
    is_bounded(s) implies is_bounded(s.closure) and dist(s.closure) = dist(s)
} by {
    if s.is_empty {
        s.closure.is_empty
        is_bounded(s.closure)
        dist(s) = 0
        dist(s.closure) = 0
        is_bounded(s.closure) and dist(s.closure) = dist(s) 
    } else {
        (s).is_nonempty
        have_sup(dist_set(s))
        forall(r: ℝ) {
            if r ∈ dist_set(s.closure) {
                forall(ε: ℝ) {
                    if ε > 0 {
                        ε/2 > 0
                        elem_in_dist_set(s.closure, r)
                        let (x: M, y: M) satisfy {
                            x ∈ s.closure and y ∈ s.closure and r = x.distance(y)
                        }
                        let ux = x.ball(ε/2)
                        let uy = y.ball(ε/2)
                        ux ∈ x.net
                        uy ∈ y.net
                        (ux ∩ s).is_nonempty
                        (uy ∩ s).is_nonempty
                        let x0: M satisfy { x0 ∈ ux ∩ s }
                        let y0: M satisfy { y0 ∈ uy ∩ s }
                        x0 ∈ x.ball(ε/2)
                        y0 ∈ y.ball(ε/2)
                        x.distance(x0) < ε/2
                        y.distance(y0) < ε/2
                        x0 ∈ s
                        y0 ∈ s
                        x0.distance(y0) ∈ dist_set(s)
                        x0.distance(y0) <= sup(dist_set(s))
                        x.distance(y) <= x.distance(x0) + y.distance(x0)
                        y.distance(x0) <= y.distance(y0) + x0.distance(y0)
                        x.distance(x0) + y.distance(x0) <= x.distance(x0) + (y.distance(y0) + x0.distance(y0))
                        y.distance(y0) + x0.distance(y0) < ε/2 + sup(dist_set(s))
                        x.distance(x0) + (y.distance(y0) + x0.distance(y0)) < ε/2 + (ε/2 + sup(dist_set(s)))
                        x.distance(y) <= x.distance(x0) + (y.distance(y0) + x0.distance(y0))
                        x.distance(y) < ε/2 + (ε/2 + sup(dist_set(s)))
                        x.distance(y) < ε + sup(dist_set(s))
                        r < ε + sup(dist_set(s))
                    }
                }
                r <= sup(dist_set(s))
            }
        }
        sup(dist_set(s)).is_set_upper_bound(dist_set(s.closure))
        (s.closure).is_nonempty
        have_sup(dist_set(s.closure))
        is_bounded(s.closure)
        sup(dist_set(s.closure)) <= sup(dist_set(s))
        s ⊆ s.closure
        sup(dist_set(s.closure)) >= sup(dist_set(s))
        sup(dist_set(s.closure)) = sup(dist_set(s))
        dist(s.closure) = dist(s)
        is_bounded(s.closure) and dist(s.closure) = dist(s)
    }
    is_bounded(s.closure) and dist(s.closure) = dist(s)
}

theorem to_closure_preserve_are_bounded[M: Distance_Top](n: Set[Set[M]]) {
    are_bounded(n) implies are_bounded(to_closure(n))
} by {
    forall(s: Set[M]) {
        if s ∈ to_closure(n) {
            let s0: Set[M] satisfy { s0 ∈ n and s = s0.closure }
            is_bounded(s0)
            is_bounded(s0.closure)
            is_bounded(s)
        }
    }
}

theorem to_closure_preserve_dist_vanish_net[M: Distance_Top](n: Net[M]) {
    is_dist_vanish_net(n) implies is_dist_vanish_net(to_closure_net(n))
} by {
    forall(ε: ℝ) {
        if ε > 0 {
            let s: Set[M] satisfy {
                s ∈ n and is_bounded(s) and dist(s) < ε
            }
            (s).is_nonempty
            is_bounded(s.closure)
            dist(s) = dist(s.closure)
            s.closure ∈ to_closure(n.sets)
            s.closure ∈ to_closure_net(n).sets
            dist(s.closure) < ε
            s.closure ∈ to_closure_net(n).sets and is_bounded(s.closure) and dist(s.closure) < ε
        }
    }
}

define uniform_control[X: Distance_Top, Y: Distance_Top](f: X -> Y, ε: ℝ, δ: ℝ) -> Bool {
    forall(x: X, y: X) {
        x.distance(y) < δ implies f(x).distance(f(y)) < ε
    }
}

define is_uniform_continuous[X: Distance_Top, Y: Distance_Top](f: X -> Y) -> Bool {
    forall(ε: ℝ) {
        ε > 0 implies exists(δ: ℝ) {
            δ > 0 and uniform_control(f, ε, δ)
        }
    }
}

define uniform_ball_control[X: Distance_Top, Y: Distance_Top](f: X -> Y, ε: ℝ, δ: ℝ) -> Bool {
    forall(x: X) {
        x.ball(δ).image(f) ⊆ f(x).ball(ε)
    }
}

theorem is_uniform_continuous_ver_ball[X: Distance_Top, Y: Distance_Top](f: X -> Y) {
    is_uniform_continuous(f) implies forall(ε: ℝ) {
        ε > 0 implies exists(δ: ℝ) {
            δ > 0 and uniform_ball_control(f, ε, δ)
        }
    }
} by {
    forall(ε: ℝ) {
        if ε > 0 {
            let δ: ℝ satisfy {
                δ > 0 and uniform_control(f, ε, δ)
            }
            forall(x: X) {
                forall(y: Y) {
                    if y ∈ x.ball(δ).image(f) {
                        let z: X satisfy {
                            z ∈ x.ball(δ) and y = f(z)
                        }
                        x.distance(z) < δ
                        f(x).distance(f(z)) < ε
                        y ∈ f(x).ball(ε)
                    }
                }
                x.ball(δ).image(f) ⊆ f(x).ball(ε)
            }
            uniform_ball_control(f, ε, δ)
            δ > 0 and uniform_ball_control(f, ε, δ)
        }
    }
}

theorem uniform_continuous_imp_continuous[X: Distance_Top, Y: Distance_Top](f: X -> Y) {
    is_uniform_continuous(f) implies is_continuous(f)
} by {
    forall(x:X, v: Set[Y]) {
        if v ∈ f(x).net {
            let ε: ℝ satisfy {
                ε > 0 and v = f(x).ball(ε)
            }
            let δ: ℝ satisfy {
                δ > 0 and uniform_ball_control(f, ε, δ)
            }
            x.ball(δ).image(f) ⊆ f(x).ball(ε)
            let u = x.ball(δ)
            u ∈ x.net
            u.image(f) ⊆ v
            u ∈ x.net and u.image(f) ⊆ v
        }
    }
    limit_at_every_point(f)
    is_continuous(f)
}

theorem uniform_continuous_preserve_dist_vanishing_net[X: Distance_Top, Y: Distance_Top](n: Net[X], f: X -> Y) {
    is_dist_vanish_net(n) and is_uniform_continuous(f) implies is_dist_vanish_net(image_of_net(n, f))
} by {
    forall(ε: ℝ) {
        if ε > 0 {
            let ε0: ℝ satisfy {
                0 < ε0 and ε0 < ε
            }
            ε0 > 0
            let δ: ℝ satisfy {
                δ > 0 and uniform_control(f, ε0, δ)
            }
            let s: Set[X] satisfy {
                s ∈ n and is_bounded(s) and dist(s) < δ
            }
            s.image(f) ∈ image_of_net(n, f)
            forall(y1: Y, y2: Y) {
                if y1 ∈ s.image(f) and y2 ∈ s.image(f) {
                    let x1: X satisfy {
                        x1 ∈ s and y1 = f(x1)
                    }
                    let x2: X satisfy {
                        x2 ∈ s and y2 = f(x2)
                    }
                    x1.distance(x2) ∈ dist_set(s)
                    x1.distance(x2) <= dist(s)
                    x1.distance(x2) < δ
                    f(x1).distance(f(x2)) < ε0
                    y1.distance(y2) < ε0
                }
            }
            (s.image(f)).is_nonempty
            dist_control_helper(s.image(f), ε0)
            have_sup(dist_set(s.image(f)))
            dist(s.image(f)) <= ε0
            dist(s.image(f)) < ε
            s.image(f) ∈ image_of_net(n, f) and is_bounded(s.image(f)) and dist(s.image(f)) < ε
        } 
    }
    is_dist_vanish_net(image_of_net(n, f))
}

// And locally compact in ℝ ...