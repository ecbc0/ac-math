from util import is_acyclic, is_transitive, is_reflexive, is_antisymmetric, is_nonreflexive

/// A partial order is a relation that is reflexive, transitive, and antisymmetric.
/// Not all elements need to be comparable.
typeclass P: Partial_Order {
    /// The less-than relation defining the partial order.
    lt: (P, P) -> Bool

    /// The order relation must be acyclic: cannot have ring.
    acyclic {
        is_acyclic(P.lt)
    }

    /// The order relation must be transitive: if `a < b` and `b < c`, then `a < c`.
    transitive {
        is_transitive(P.lt)
    }
}

attributes P: Partial_Order {
    /// Strict less-than comparison.
    define lte(self, other: P) -> Bool {
        self < other or self = other
    }

    /// Strict greater-than comparison.
    define gt(self, other: P) -> Bool {
        other < self
    }

    /// Greater-than-or-equal-to comparison.
    define gte(self, other: P) -> Bool {
        other <= self
    }
}

// equivalent representation of Partial_Order

theorem lt_and_eq_is_different_thing[P: Partial_Order](a: P) {
    not (a < a)
} 

theorem partial_order_lt_is_nonreflexive[P: Partial_Order] {
    is_nonreflexive(P.lt)
} 

theorem lt_imp_not_eq[P: Partial_Order](a: P, b: P) {
    a < b implies a != b
} 

theorem acyclic_and_transitive_imp_not_self[T](lt: (T, T) -> Bool) {
    is_acyclic(lt) and is_transitive(lt) implies is_nonreflexive(lt)
}

define lte_from[T](lt: (T, T) -> Bool, x: T, y: T) -> Bool {
    lt(x, y) or x = y    
}

define lt_from[T](lte: (T, T) -> Bool, x: T, y: T) -> Bool {
    lte(x, y) and x != y
} 

theorem lt_to_lte_to_lt[P: Partial_Order] {
    lt_from(lte_from(P.lt)) = P.lt 
} by {
    forall(x: P, y: P) {
        lte_from(P.lt)(x, y) implies (P.lt(x, y) or x = y)
        (P.lt(x, y) or x = y) implies lte_from(P.lt)(x, y)

        lte_from(P.lt)(x, y) = (P.lt(x, y) or x = y)

        lt_from(lte_from(P.lt))(x, y) implies ((P.lt(x, y) or x = y) and x != y)
        ((P.lt(x, y) or x = y) and x != y) implies lt_from(lte_from(P.lt))(x, y)

        lt_from(lte_from(P.lt))(x, y) = ((P.lt(x, y) or x = y) and x != y)

        ((P.lt(x, y) or x = y) and x != y) = ((P.lt(x, y) and x != y) or (x = y and x != y))

        ((P.lt(x, y) or x = y) and x != y) = (P.lt(x, y) and x != y)

        (P.lt(x, y) and x != y) = P.lt(x, y)

        lt_from(lte_from(P.lt))(x, y) implies P.lt(x, y)

        lt_from(lte_from(P.lt))(x, y) = P.lt(x, y)
    }
}

theorem lte_is_reflexive[T](lt: (T, T) -> Bool) {
    is_reflexive(lte_from(lt))
} by {
    forall(x: T) {
        x = x
        lte_from(lt)(x, x)
    }
}

theorem lt_is_nonreflexive[T](lte: (T, T) -> Bool) {
    is_nonreflexive(lt_from(lte))
} by {
    forall(x: T) {
        if lt_from(lte)(x, x) {
            lte(x, x) and x != x
            false
        }
    }
}

theorem acyclic_imp_antisymmetric[T](lt: (T, T) -> Bool) {
    is_acyclic(lt) implies is_antisymmetric(lte_from(lt))
} by {
    forall(x: T, y: T) {
        if lte_from(lt)(x, y) and lte_from(lt)(y, x) {
            lt(x, y) or x = y
            lt(y, x) or y = x
            x = y
        }
    }
    is_antisymmetric(lte_from(lt))    
}

theorem antisymmetric_imp_acyclic[T](lte: (T, T) -> Bool) {
    is_antisymmetric(lte) implies is_acyclic(lt_from(lte))
} by {
    forall(x: T, y: T) {
        if lt_from(lte)(x, y) and lt_from(lte)(y, x) {
            lte(x, y) and lte(y, x)
            x = y
            lt_from(lte)(x, x)
            not is_nonreflexive(lt_from(lte))
            false
        }
        not (lt_from(lte)(x, y) and lt_from(lte)(y, x))
    }
    is_acyclic(lt_from(lte))
}

theorem lt_trans_imp_lte_trans[T](lt: (T, T) -> Bool) {
    is_transitive(lt) implies is_transitive(lte_from(lt))
} by {
    forall(x: T, y: T, z: T) {
        if (lte_from(lt)(x, y) and lte_from(lt)(y, z)) {
            if x = y {
                lte_from(lt)(x, z)
            } else {
                if y = z {
                    lte_from(lt)(x, z)
                } else {
                    x != y
                    y != z
                    lt(x, y)
                    lt(y, z)
                    lt(x, z)
                    lte_from(lt)(x, z)
                }
            }
        }
    }
}

theorem lte_trans_imp_lt_trans[T](lte: (T, T) -> Bool) {
    is_antisymmetric(lte) implies (is_transitive(lte) implies is_transitive(lt_from(lte)))
} by {
    is_acyclic(lt_from(lte))
    if is_transitive(lte) {
        forall(x: T, y: T, z: T) {
            if lt_from(lte)(x, y) and lt_from(lte)(y, z) {
                lte(x, y)
                lte(y, z)
                lte(x, z)
                x != y
                y != z
                if x = z {
                    not is_acyclic(lt_from(lte))
                    false
                }
                lt_from(lte)(x, z)
            }
        }   
    }
}

// equivalent representation of Partial_Order
theorem lt_to_lte_partial_order[T](lt: (T, T) -> Bool) {
    (
        is_acyclic(lt) and 
        is_transitive(lt)
    ) implies (
        is_reflexive(lte_from(lt)) and 
        is_transitive(lte_from(lt)) and 
        is_antisymmetric(lte_from(lt))
    )
} 

theorem typeclass_lt_to_lte_partial_order[P: Partial_Order] {
    is_reflexive(lte_from(P.lt)) and 
    is_transitive(lte_from(P.lt)) and 
    is_antisymmetric(lte_from(P.lt))
} by {
    is_acyclic(P.lt) 
    is_transitive(P.lt)
}

theorem lte_to_lt_partial_order[T](lte: (T, T) -> Bool) {
    (
        is_reflexive(lte) and 
        is_transitive(lte) and 
        is_antisymmetric(lte)
    ) implies (
        is_acyclic(lt_from(lte)) and 
        is_transitive(lt_from(lte))
    ) 
} 

theorem lte_to_lt_to_lte[T](lte: (T, T) -> Bool) {
    (
        is_reflexive(lte) and 
        is_transitive(lte) and 
        is_antisymmetric(lte)
    ) implies 
    (lte = lte_from(lt_from(lte)))
} by {
    forall(x: T, y: T) {
        lt_from(lte)(x, y) implies (lte(x, y) and x != y)

        lt_from(lte)(x, y) = (lte(x, y) and x != y)

        lte_from(lt_from(lte))(x, y) implies ((lte(x, y) and x != y) or x = y)
        ((lte(x, y) and x != y) or x = y) implies lte_from(lt_from(lte))(x, y)

        lte_from(lt_from(lte))(x, y) = ((lte(x, y) and x != y) or x = y)

        ((lte(x, y) and x != y) or x = y) = ((lte(x, y) or x = y) and (x != y or x = y))

        ((lte(x, y) and x != y) or x = y) = (lte(x, y) or x = y)

        if lte(x, y) or x = y {
            if x = y {
                lte(x, x) // reflexive
                lte(x, y)
                (lte(x, y) or x = y) = lte(x, y)
            } else {
                x != y
                lte(x, y)
                (lte(x, y) or x = y) = lte(x, y)
            }
        } 
        (lte(x, y) or x = y) = lte(x, y)

        lte_from(lt_from(lte))(x, y) implies lte(x, y)

        lte_from(lt_from(lte))(x, y) = lte(x, y)
    }
}

theorem typeclass_lte_from[P: Partial_Order] {
    lte_from(P.lt) = P.lte
} by {
    forall(a: P, b: P) {
        lte_from(P.lt)(a, b) implies P.lte(a, b)
        P.lte(a, b) implies lte_from(P.lt)(a, b)
        lte_from(P.lt)(a, b) = P.lte(a, b)
    }
    lte_from(P.lt) = P.lte
}

theorem typeclass_lt_to_lte_to_lt[P: Partial_Order] {
    lt_from(lte_from(P.lt)) = P.lt
}

theorem typeclass_lte_order[P: Partial_Order] {
    is_reflexive(P.lte) and 
    is_transitive(P.lte) and 
    is_antisymmetric(P.lte)
} by {
    P.lte = lte_from(P.lt)
}

theorem typeclass_lt_from[P: Partial_Order] {
    lt_from(P.lte) = P.lt
}

theorem typeclass_lte_to_lt_to_lte[P: Partial_Order] {
    lte_from(lt_from(P.lte)) = P.lte
}

theorem lt_and_lte[P: Partial_Order](a: P, b: P, c: P) { a < b and b <= c implies a < c } by {
    if b = c {
        a < c
    } else {
        a < c
    }
}

theorem lte_and_lt[P: Partial_Order](a: P, b: P, c: P) { a <= b and b < c implies a < c } by {
    if a = b {
        a < c
    } else {
        a < c
    }
}

attributes P: Partial_Order {
    let comparable = function(a: P, b: P) {
        (a < b) or (b < a) or (a = b)
    }
}

/// A linear order (total order) is a partial order where all elements are comparable.
typeclass L: Linear_Order extends Partial_Order {
    /// All elements are comparable: for any two elements `a` and `b`, either `a < b` or `b < a` or `a = b`.
    trichotomy(a: L, b: L) {
        Partial_Order.comparable(a, b)
    }
}

theorem gt_is_not_lte[L: Linear_Order](a: L, b: L) { 
    a > b iff not a <= b 
} by {
    a > b implies not a <= b 
}

attributes L: Linear_Order {
    /// Yields the smaller of two elements.
    define min(self, other: L) -> L {
        if self <= other {
            self
        } else {
            other
        }
    }

    /// Yields the larger of two elements.
    define max(self, other: L) -> L {
        if other <= self {
            self
        } else {
            other
        }
    }
}

theorem max_imp_gte[L: Linear_Order](a: L, b: L) {
    a.max(b) >= a and a.max(b) >= b
} by {
    // Funny that the prover needs help here (says Prover status: Exhausted?)
    if a.max(b) = b {
        a.max(b) >= a
        a.max(b) >= b
    } else {
        a.max(b) >= a
        a.max(b) >= b
    }
}

theorem lte_max[L: Linear_Order](a: L, b: L) {
    a <= a.max(b) and b <= a.max(b)
} by {
    a <= a.max(b)
    b <= a.max(b)
}

theorem min_imp_lte[L: Linear_Order](a: L, b: L) {
    a.min(b) <= a and a.min(b) <= b
} by {
    if a.min(b) = a {
        a.min(b) <= a
        a.min(b) <= b
    } else {
        a.min(b) <= a
        a.min(b) <= b
    }
}

theorem gte_min[L: Linear_Order](a: L, b: L) {
    a >= a.min(b) and b >= a.min(b)
} by {
    a >= a.min(b) 
    b >= a.min(b)
}

theorem lt_imp_min[L: Linear_Order](a: L, b: L) {
    a < b implies a.min(b) = a
}

theorem not_lt_imp_min[L: Linear_Order](a: L, b: L) {
    not a < b implies a.min(b) = b
}

theorem gt_imp_min[L: Linear_Order](a: L, b: L) {
    a > b implies a.min(b) = b
}

theorem not_gt_imp_min[L: Linear_Order](a: L, b: L) {
    not a > b implies a.min(b) = a
}

theorem gte_imp_min[L: Linear_Order](a: L, b: L) {
    a >= b implies a.min(b) = b
}

theorem not_gte_imp_min[L: Linear_Order](a: L, b: L) {
    not a >= b implies a.min(b) = a
}

theorem lt_imp_max[L: Linear_Order](a: L, b: L) {
    a < b implies a.max(b) = b
}

theorem not_lt_imp_max[L: Linear_Order](a: L, b: L) {
    not a < b implies a.max(b) = a
}

theorem gt_imp_max[L: Linear_Order](a: L, b: L) {
    a > b implies a.max(b) = a
}

theorem not_gt_imp_max[L: Linear_Order](a: L, b: L) {
    not a > b implies a.max(b) = b
}

theorem gte_imp_max[L: Linear_Order](a: L, b: L) {
    a >= b implies a.max(b) = a
}

theorem not_gte_imp_max[L: Linear_Order](a: L, b: L) {
    not a >= b implies a.max(b) = b
}

theorem min_is_one[L: Linear_Order](a: L, b: L) {
    a.min(b) = a or a.min(b) = b
}

theorem max_is_one[L: Linear_Order](a: L, b: L) {
    a.max(b) = a or a.max(b) = b
}

theorem min_symm[L: Linear_Order](a: L, b: L) {
    a.min(b) = b.min(a)
} by {
    if a <= b {
        a.min(b) = b.min(a)
    } else {
        b < a
        b.min(a) = a.min(b)
    }
}

theorem max_symm[L: Linear_Order](a: L, b: L) {
    a.max(b) = b.max(a)
} by {
    if a <= b {
        a.max(b) = b.max(a)
    } else {
        b < a
        b.max(a) = a.max(b)
    }
}

theorem min_lte_left[L: Linear_Order](a: L, b: L) {
    a.min(b) <= a
} 

theorem max_gte_left[L: Linear_Order](a: L, b: L) {
    a.max(b) >= a
} 

theorem min_lte_right[L: Linear_Order](a: L, b: L) {
    a.min(b) <= b
} 

theorem max_gte_right[L: Linear_Order](a: L, b: L) {
    a.max(b) >= b
} 

theorem lt_both_imp_lt_min[L: Linear_Order](a: L, b: L, c: L) {
    a < b and a < c implies a < b.min(c)
} by {
    if b <= c {
        b.min(c) = b
        a < b.min(c)
    } else {
        b > c
        b.min(c) = c
        a < b.min(c)
    }
}

theorem lt_min_imp_lt_left[L: Linear_Order](a: L, b: L, c: L) {
    a < b.min(c) implies a < b
} 

theorem lt_min_imp_lt_right[L: Linear_Order](a: L, b: L, c: L) {
    a < b.min(c) implies a < c
} 

theorem gt_both_imp_gt_max[L: Linear_Order](a: L, b: L, c: L) {
    a > b and a > c implies a > b.max(c)
} by {
    if b <= c {
        b.max(c) = c
        a > b.max(c)
    } else {
        b > c
        b.max(c) = b
        a > b.max(c)
    }
}

theorem gt_max_imp_gt_left[L: Linear_Order](a: L, b: L, c: L) {
    a > b.max(c) implies a > b
} by {
    if b <= c {
        b.max(c) = c
        a > b
    } else {
        b > c
        b.max(c) = b
        a > b
    }
}

theorem gt_max_imp_gt_right[L: Linear_Order](a: L, b: L, c: L) {
    a > b.max(c) implies a > c
} 