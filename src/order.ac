from util import is_acyclic, is_transitive

/// A partial order is a relation that is reflexive, transitive, and antisymmetric.
/// Not all elements need to be comparable.
typeclass P: Partial_Order {
    /// The less-than-or-equal-to relation defining the partial order.
    lt: (P, P) -> Bool

    /// The order relation must be acyclic: cannot have ring.
    acyclic {
        is_acyclic(P.lt)
    }

    /// The order relation must be transitive: if `a < b` and `b < c`, then `a < c`.
    transitive {
        is_transitive(P.lt)
    }
}

attributes P: Partial_Order {
    /// Strict less-than comparison.
    define lte(self, other: P) -> Bool {
        self < other or self = other
    }

    /// Strict greater-than comparison.
    define gt(self, other: P) -> Bool {
        other < self
    }

    /// Greater-than-or-equal-to comparison.
    define gte(self, other: P) -> Bool {
        other <= self
    }
}

/// A linear order (total order) is a partial order where all elements are comparable.
typeclass L: Linear_Order extends Partial_Order {
    /// All elements are comparable: for any two elements `a` and `b`, either `a < b` or `b < a` or `a = b`.
    trichotomy(a: L, b: L) {
        (a < b) or (b < a) or (a = b)
    }
}

attributes L: Linear_Order {
    /// Yields the smaller of two elements.
    define min(self, other: L) -> L {
        if self <= other {
            self
        } else {
            other
        }
    }

    /// Yields the larger of two elements.
    define max(self, other: L) -> L {
        if other <= self {
            self
        } else {
            other
        }
    }
}

theorem max_imp_gte[L: Linear_Order](a: L, b: L) {
    a.max(b) >= a and a.max(b) >= b
} by {
    // Funny that the prover needs help here (says Prover status: Exhausted?)
    if a.max(b) = b {
        a.max(b) >= a
        a.max(b) >= b
    } else {
        a.max(b) >= a
        a.max(b) >= b
    }
}

theorem min_imp_lte[L: Linear_Order](a: L, b: L) {
    a.min(b) <= a and a.min(b) <= b
} by {
    if a.min(b) = a {
        a.min(b) <= a
        a.min(b) <= b
    } else {
        a.min(b) <= a
        a.min(b) <= b
    }
}

theorem lt_imp_min[L: Linear_Order](a: L, b: L) {
    a < b implies a.min(b) = a
}

theorem not_lt_imp_min[L: Linear_Order](a: L, b: L) {
    not a < b implies a.min(b) = b
}

theorem gt_imp_min[L: Linear_Order](a: L, b: L) {
    a > b implies a.min(b) = b
}

theorem not_gt_imp_min[L: Linear_Order](a: L, b: L) {
    not a > b implies a.min(b) = a
}

theorem gte_imp_min[L: Linear_Order](a: L, b: L) {
    a >= b implies a.min(b) = b
}

theorem not_gte_imp_min[L: Linear_Order](a: L, b: L) {
    not a >= b implies a.min(b) = a
}

theorem lt_imp_max[L: Linear_Order](a: L, b: L) {
    a < b implies a.max(b) = b
}

theorem not_lt_imp_max[L: Linear_Order](a: L, b: L) {
    not a < b implies a.max(b) = a
}

theorem gt_imp_max[L: Linear_Order](a: L, b: L) {
    a > b implies a.max(b) = a
}

theorem not_gt_imp_max[L: Linear_Order](a: L, b: L) {
    not a > b implies a.max(b) = b
}

theorem gte_imp_max[L: Linear_Order](a: L, b: L) {
    a >= b implies a.max(b) = a
}

theorem not_gte_imp_max[L: Linear_Order](a: L, b: L) {
    not a >= b implies a.max(b) = b
}

theorem min_is_one[L: Linear_Order](a: L, b: L) {
    a.min(b) = a or a.min(b) = b
}

theorem max_is_one[L: Linear_Order](a: L, b: L) {
    a.max(b) = a or a.max(b) = b
}

theorem min_symm[L: Linear_Order](a: L, b: L) {
    a.min(b) = b.min(a)
} by {
    if a <= b {
        a.min(b) = b.min(a)
    } else {
        b < a
        b.min(a) = a.min(b)
    }
}

theorem max_symm[L: Linear_Order](a: L, b: L) {
    a.max(b) = b.max(a)
} by {
    if a <= b {
        a.max(b) = b.max(a)
    } else {
        b < a
        b.max(a) = a.max(b)
    }
}