from list.list_base import List, two_to_finite, preserve_two_to_finite, preserve_two, preserve_finite
from set import Set, constant_false, functional_insert, functional_remove, intersection, union, compl_of_sets, compose, elem_in_intersection_general
from nat import ℕ
numerals ℕ

/// True if a boolean function represents a finite set.
/// A function satisfies the finite constraint if there exists a finite list containing all elements for which the function returns true.
define finite_constraint[T](contains: T -> Bool) -> Bool {
    exists(super: List[T]) {
        forall(x: T) {
            contains(x) implies super.contains(x)
        }
    }
}

theorem const_false_satisfies_finite_constraint[T] {
    finite_constraint(constant_false[T])
}

theorem list_contains_satisfies_finite_constraint[T](ts: List[T]) {
    finite_constraint(ts.contains)
    // ts.contains implies ts.contains
}

// Finite-set attributes and lemmas
attributes Set[K] {
    /// True if the set contains only finitely many elements.
    define is_finite(self) -> Bool {
        finite_constraint(self.contains)
    }

    define have_super_list(self, super: List[K]) -> Bool {
        forall(x: K) {
            x ∈ self implies x ∈ super
        }        
    }

    define have_exact_list(self, list: List[K]) -> Bool {
        list.is_unique and self.contains = list.contains
    }

    /// True if the cardinality is at most n.
    define cardinality_at_most(self, n: ℕ) -> Bool {
        exists(l: List[K]) {
            self.have_super_list(l) and l.length <= n
        }
    }

    /// True if the cardinality equals n.
    define cardinality_is(self, n: ℕ) -> Bool {
        exists(l: List[K]) {
            self.have_exact_list(l) and l.length = n
        }
    }
}

theorem is_finite_imp_have_super_list[K](a: Set[K]) {
    a.is_finite implies exists(l: List[K]) { a.have_super_list(l) }
} 

theorem have_super_list_imp_is_finite[K](a: Set[K]) {
    exists(l: List[K]) { a.have_super_list(l) } implies a.is_finite
}

theorem have_exact_list_imp_same_contains[K](s: Set[K], l: List[K]) {
    s.have_exact_list(l) implies s.contains = l.contains
}

define to_exact[K](s: Set[K], l: List[K]) -> List[K] {
    if s.have_super_list(l) {
        l.filter(s.contains).unique
    } else {
        List[K].nil
    }
}

theorem super_list_to_exact_list_is_exact_list[K](s: Set[K], l: List[K]) {
    s.have_super_list(l) implies s.have_exact_list(to_exact(s, l))
}
 by {
    let filtered = l.filter(s.contains).unique
    filtered = to_exact(s, l)

    forall(x: K) {
        x ∈ l.filter(s.contains) iff x ∈ l.filter(s.contains).unique
        x ∈ s implies x ∈ filtered
        x ∈ filtered implies x ∈ s
        x ∈ s iff x ∈ filtered
    }

    s.have_exact_list(filtered)
}

theorem finite_set_has_exact_list[K](s: Set[K]) {
    s.is_finite implies exists(l: List[K]) {
        s.have_exact_list(l)
    }
}

theorem have_exact_list_imp_finite[K](s: Set[K]) {
    exists(l: List[K]) {
        s.have_exact_list(l)
    } implies s.is_finite
}

theorem cardinality_is_imp_finite[K](s: Set[K], n: ℕ) {
    s.cardinality_is(n) implies s.is_finite
}

theorem cardinality_always_exists[K](s: Set[K]) {
    s.is_finite implies exists(n: ℕ) {
        s.cardinality_is(n)
    }
} by {
    let (l: List[K]) satisfy {
        s.have_exact_list(l)
    }

    let n = l.length
}

theorem exact_list_is_well_defined[K](s: Set[K], l1: List[K], l2: List[K]) {
    s.have_exact_list(l1) and s.have_exact_list(l2) implies l1.is_permutation(l2)
} by {
    l1.contains = l2.contains
    l1.is_unique
    l2.is_unique
    l1.is_permutation(l2)    
}

theorem cardinality_is_well_defined[K](s: Set[K], n1: ℕ, n2: ℕ) {
    s.cardinality_is(n1) and s.cardinality_is(n2) implies n1 = n2
} by {
    let (l1: List[K]) satisfy {
        s.have_exact_list(l1) and l1.length = n1
    }
    let (l2: List[K]) satisfy {
        s.have_exact_list(l2) and l2.length = n2
    }
    l1.is_permutation(l2)
    l1.length = l2.length
    n1 = n2
}

theorem cardinality_is_smallest_cardinality[K](s: Set[K], n: ℕ, m: ℕ) {
    s.cardinality_is(n) and s.cardinality_at_most(m) implies n <= m
} by {
    s.is_finite
    let (l: List[K]) satisfy {
        s.have_super_list(l) and l.length <= m
    }
    s.have_exact_list(to_exact(s, l))
    to_exact(s, l).length = n
    to_exact(s, l) = l.filter(s.contains).unique
    l.filter(s.contains).unique.length <= l.filter(s.contains).length
    l.filter(s.contains).length <= l.length
}

theorem cardinality_is_implies_is_finite[K](s: Set[K], n: ℕ) {
    s.cardinality_is(n) implies s.is_finite
} 

theorem union_is_finite_of_finite[K](a: Set[K], b: Set[K]) {
    a.is_finite and b.is_finite implies (a ∪ b).is_finite
} by {
    let la: List[K] satisfy {
        a.have_super_list(la)
    }
    let lb: List[K] satisfy {
        b.have_super_list(lb)
    }

    let l = la + lb

    forall(x: K) {
        if x ∈ a ∪ b {
            if x ∈ a {
                x ∈ la
                x ∈ l
            } else {
                x ∈ b
                x ∈ lb
                x ∈ l
            }
            x ∈ l
        }
    }
    (a ∪ b).have_super_list(l)
}

theorem intersection_is_finite_of_finite[K](a: Set[K], b: Set[K]) {
    a.is_finite and b.is_finite implies (a ∩ b).is_finite
} by {
    a.is_finite

    let la: List[K] satisfy {
        a.have_super_list(la)
    }

    let l = la

    forall(x: K) {
        if x ∈ a ∩ b {
            x ∈ a
            x ∈ l 
        }
    }

    (a ∩ b).have_super_list(l)
}

theorem difference_is_finite_of_finite[K](a: Set[K], b: Set[K]) {
    a.is_finite implies (a ∖ b).is_finite
} by {
    a.is_finite

    let la: List[K] satisfy {
        a.have_super_list(la)
    }

    let l = la

    forall(x: K) {
        if x ∈ a ∖ b {
            x ∈ a
            x ∈ l
        }
    }

    (a ∖ b).have_super_list(l)
}

theorem union_is_at_most_length[K](a: Set[K], b: Set[K], n1: ℕ, n2: ℕ) {
    a.cardinality_at_most(n1) and b.cardinality_at_most(n2) implies (a ∪ b).cardinality_at_most(n1 + n2)
} by {
    let (la: List[K]) satisfy {
        a.have_super_list(la) and la.length <= n1
    }

    let (lb: List[K]) satisfy {
        b.have_super_list(lb) and lb.length <= n2
    }

    let l = la + lb

    forall(x: K) {
        x ∈ a ∪ b implies x ∈ l
    }

    l.length = la.length + lb.length
    la.length + lb.length <= n1 + n2
    l.length <= n1 + n2
}

let set_to_exact_list[T](s: Set[T]) -> l: List[T] satisfy {
    if s.is_finite {
       s.have_exact_list(l) 
    } else {
        l = List[T].nil
    }
} 

theorem empty_set_have_exact_list_nil[T] {
    Set[T].empty_set.have_exact_list(List[T].nil)
} by {
    List[T].nil.is_unique
    forall(x: T) {
        not x ∈ Set[T].empty_set
        not x ∈ List[T].nil
    }
    Set[T].empty_set.contains = List[T].nil.contains
}

theorem empty_set_to_nil[T] {
    set_to_exact_list(Set[T].empty_set) = List[T].nil
}

define list_to_set[T](l: List[T]) -> Set[T] {
    Set[T].new(l.contains)
}

theorem list_to_set_have_same_contains[T](l: List[T]) {
    l.contains = list_to_set(l).contains
}

theorem unique_list_to_set_is_exact[T](l: List[T]) {
    l.is_unique implies list_to_set(l).have_exact_list(l)
}

theorem exact_list_to_set_is_self[T](s: Set[T], l: List[T]) {
    s.have_exact_list(l) implies s = list_to_set(l)
} by {
    s.contains = list_to_set(l).contains
}

define intersection_of_list_recursion[K](l: List[Set[K]]) -> Set[K] {
    match l {
        List[Set[K]].nil {
            Set[K].universal_set
        }
        List.cons(head, tail) {
            head ∩ intersection_of_list_recursion(tail)
        }
    }
}

theorem intersection_of_list_recursion_is_two_to_finite[K](l: List[Set[K]]) {
    intersection_of_list_recursion(l) = two_to_finite(Set[K].intersection, l, Set[K].universal_set)
} by {
    define p(xs: List[Set[K]]) -> Bool {
        intersection_of_list_recursion(xs) = two_to_finite(Set[K].intersection, xs, Set[K].universal_set)
    }
    p(List[Set[K]].nil)
    forall(head: Set[K], tail: List[Set[K]]) {
        if p(tail) {
            if tail = List[Set[K]].nil {
                intersection_of_list_recursion(tail) = Set[K].universal_set
                intersection_of_list_recursion(List.cons(head, tail)) = head ∩ Set[K].universal_set
                intersection_of_list_recursion(List.cons(head, tail)) = head
                two_to_finite(Set.intersection[K], List.cons(head, tail), Set[K].universal_set) = head
                p(List.cons(head, tail))
            } else {
                intersection_of_list_recursion(tail) = two_to_finite(Set.intersection[K], tail, Set[K].universal_set)
                intersection_of_list_recursion(List.cons(head, tail)) = head ∩ intersection_of_list_recursion(tail)
                two_to_finite(Set[K].intersection, List.cons(head, tail), Set[K].universal_set) = head ∩ two_to_finite(Set.intersection[K], tail, Set[K].universal_set)
                p(List.cons(head, tail))
            }
            p(List.cons(head, tail))
        }
    }
    p(l)
}

define elem_in_intersection_of_list[K](l: List[Set[K]], x: K) -> Bool {
    forall(s: Set[K]) {
        s ∈ l implies x ∈ s
    }
}

define intersection_of_list[K](l: List[Set[K]]) -> Set[K] {
    Set[K].new(elem_in_intersection_of_list(l))
}

// I want to use
// define p(contains: Set[K] -> Bool) -> (K -> Bool) {
//     function(x: K) {
//         forall(s: Set[K]) {
//             contains(s) implies s.contains(x)
//         }
//     }
// }
// and     
// forall(x: K) {
//     p(c.contains)(x) = elem_in_intersection_general(c, x)
// }
// however, not work
theorem equivalent_of_intersection_of_list_and_set[K](l: List[Set[K]]) {
    intersection(list_to_set(l)) = intersection_of_list(l)
} by {
    let c = list_to_set(l)
    c.contains = l.contains
    forall(x: K) {
        if x ∈ intersection(c) {
            forall(s: Set[K]) {
                if s ∈ l {
                    s ∈ c
                    x ∈ s
                }
            }
            x ∈ intersection_of_list(l)
        }
    }
    intersection(c) ⊆ intersection_of_list(l)

    forall(x: K) {
        if x ∈ intersection_of_list(l) {
            forall(s: Set[K]) {
                if s ∈ c {
                    s ∈ l
                    x ∈ s
                }
            }
            x ∈ intersection(c)
        }
    }
    intersection_of_list(l) ⊆ intersection(c)

    intersection(c) = intersection_of_list(l)
}

theorem equivalent_of_intersection_of_exact_list_and_set[K](c: Set[Set[K]], l: List[Set[K]]) {
    c.have_exact_list(l) implies intersection(c) = intersection_of_list(l)
} by {
    list_to_set(l) = c
}

theorem empty_intersection_is_universe[K] {
    intersection_of_list(List[Set[K]].nil) = Set[K].universal_set
} 

theorem intersection_of_list_decomposition[K](head: Set[K], tail: List[Set[K]]) {
    intersection_of_list(List.cons(head, tail)) = head ∩ intersection_of_list(tail)
} by {
    forall(x: K) {
        if x ∈ intersection_of_list(List.cons(head, tail)) {
            head ∈ List.cons(head, tail)
            x ∈ head
            forall(s: Set[K]) {
                if s ∈ tail {
                    s ∈ List.cons(head, tail)
                    x ∈ s
                }
            }            
            x ∈ intersection_of_list(tail)
            x ∈ head ∩ intersection_of_list(tail)
        }
    }
    intersection_of_list(List.cons(head, tail)) ⊆ head ∩ intersection_of_list(tail)

    forall(x: K) {
        if x ∈ head ∩ intersection_of_list(tail) {
            x ∈ head
            x ∈ intersection_of_list(tail)
            forall(s: Set[K]) {
                if s ∈ List.cons(head, tail) {
                    if s = head {
                        x ∈ s
                    } else {
                        s ∈ tail
                        x ∈ s
                    }
                    x ∈ s
                }
            }
            x ∈ intersection_of_list(List.cons(head, tail))
        }
    }
    head ∩ intersection_of_list(tail) ⊆ intersection_of_list(List.cons(head, tail))

    intersection_of_list(List.cons(head, tail)) = head ∩ intersection_of_list(tail)
}

theorem intersection_of_list_recursion_decomposition[K](head: Set[K], tail: List[Set[K]]) {
    intersection_of_list_recursion(List.cons(head, tail)) = head ∩ intersection_of_list_recursion(tail)
}

theorem equivalent_of_two_definiton_of_intersection_of_list[K](list: List[Set[K]]) {
    intersection_of_list_recursion(list) = intersection_of_list(list)
} by {
    define p(l: List[Set[K]]) -> Bool {
        intersection_of_list_recursion(l) = intersection_of_list(l)
    }
    p(List[Set[K]].nil) 
    forall(head: Set[K], tail: List[Set[K]]) {
        if p(tail) {
            intersection_of_list_recursion(List.cons(head, tail)) = head ∩ intersection_of_list_recursion(tail)

            intersection_of_list(List.cons(head, tail)) = head ∩ intersection_of_list(tail)

            intersection_of_list_recursion(tail) = intersection_of_list(tail)

            intersection_of_list_recursion(List.cons(head, tail)) = intersection_of_list(List.cons(head, tail))

            p(List.cons(head, tail))
        }
    }
    p(list)
}

theorem equivalent_of_intersection_of_list_recursion_and_set[K](list: List[Set[K]]) {
    intersection(list_to_set(list)) = intersection_of_list_recursion(list)
} 

theorem equivalent_of_intersection_of_exact_list_recursion_and_set[K](c: Set[Set[K]], list: List[Set[K]]) {
    c.have_exact_list(list) implies intersection(c) = intersection_of_list_recursion(list)
} 

theorem intersection_of_unique_list[K](list: List[Set[K]]) {
    intersection_of_list(list.unique) = intersection_of_list(list)
} by {
    list.contains = list.unique.contains

    forall(x: K) {
        if x ∈ intersection_of_list(list.unique) {
            forall(s: Set[K]) {
                if s ∈ list {
                    s ∈ list.unique
                    x ∈ s
                }
            }
            x ∈ intersection_of_list(list)
        }
    }
    intersection_of_list(list.unique) ⊆ intersection_of_list(list)

    forall(x: K) {
        if x ∈ intersection_of_list(list) {
            forall(s: Set[K]) {
                if s ∈ list.unique {
                    s ∈ list
                    x ∈ s
                }
            }
            x ∈ intersection_of_list(list.unique)
        }
    }
    intersection_of_list(list) ⊆ intersection_of_list(list.unique)

    intersection_of_list(list.unique) = intersection_of_list(list)
}

define union_of_list_recursion[K](l: List[Set[K]]) -> Set[K] {
    match l {
        List[Set[K]].nil {
            Set[K].empty_set
        }
        List.cons(head, tail) {
            head ∪ union_of_list_recursion(tail)
        }
    }
}

theorem union_of_list_recursion_is_two_to_finite[K](l: List[Set[K]]) {
    union_of_list_recursion(l) = two_to_finite(Set[K].union, l, Set[K].empty_set)
} by {
    define p(xs: List[Set[K]]) -> Bool {
        union_of_list_recursion(xs) = two_to_finite(Set[K].union, xs, Set[K].empty_set)
    }
    p(List[Set[K]].nil)
    forall(head: Set[K], tail: List[Set[K]]) {
        if p(tail) {
            if tail = List[Set[K]].nil {
                union_of_list_recursion(tail) = Set[K].empty_set
                union_of_list_recursion(List.cons(head, tail)) = head ∪ Set[K].empty_set
                union_of_list_recursion(List.cons(head, tail)) = head
                two_to_finite(Set.union[K], List.cons(head, tail), Set[K].empty_set) = head
                p(List.cons(head, tail))
            } else {
                union_of_list_recursion(tail) = two_to_finite(Set.union[K], tail, Set[K].empty_set)
                union_of_list_recursion(List.cons(head, tail)) = head ∪ union_of_list_recursion(tail)
                two_to_finite(Set[K].union, List.cons(head, tail), Set[K].empty_set) = head ∪ two_to_finite(Set.union[K], tail, Set[K].empty_set)
                p(List.cons(head, tail))
            }
            p(List.cons(head, tail))
        }
    }
    p(l)
}

define elem_in_union_of_list[K](l: List[Set[K]], x: K) -> Bool {
    exists(s: Set[K]) {
        s ∈ l and x ∈ s
    }
}

define union_of_list[K](l: List[Set[K]]) -> Set[K] {
    Set[K].new(elem_in_union_of_list(l))
}

theorem equivalent_of_union_of_list_and_set[K](l: List[Set[K]]) {
    union(list_to_set(l)) = union_of_list(l)
} by {
    let c = list_to_set(l)
    c.contains = l.contains
    forall(x: K) {
        if x ∈ union(c) {
            let (s: Set[K]) satisfy {
                s ∈ c and x ∈ s
            }
            s ∈ l
            s ∈ l and x ∈ s
            x ∈ union_of_list(l)
        }
    }
    union(c) ⊆ union_of_list(l)

    forall(x: K) {
        if x ∈ union_of_list(l) {
            let (s: Set[K]) satisfy {
                s ∈ l and x ∈ s
            } 
            s ∈ c 
            s ∈ c and x ∈ s
            x ∈ union(c)
        }
    }
    union_of_list(l) ⊆ union(c)

    union(c) = union_of_list(l)
}

theorem equivalent_of_union_of_exact_list_and_set[K](c: Set[Set[K]], l: List[Set[K]]) {
    c.have_exact_list(l) implies union(c) = union_of_list(l)
}

define compl_of_list[K](l: List[Set[K]]) -> List[Set[K]] {
    l.map(Set[K].c)
}

theorem compl_of_list_preserve_compl_count[K](l: List[Set[K]], s: Set[K]) {
    l.count(s) = compl_of_list(l).count(s.c)
} by {
    define p(x: List[Set[K]]) -> Bool {
        x.count(s) = compl_of_list(x).count(s.c)
    }
    List[Set[K]].nil.map(Set[K].c) = List[Set[K]].nil
    compl_of_list(List[Set[K]].nil) = List[Set[K]].nil
    p(List[Set[K]].nil)
    forall(head: Set[K], tail: List[Set[K]]) {
        List.cons(head, tail).map(Set[K].c) = List.cons(head.c, tail.map(Set[K].c))
        compl_of_list(List.cons(head, tail)) = List.cons(head.c, compl_of_list(tail))
        if p(tail) {
            if s = head {
                s.c = head.c

                List.cons(head, tail).count(s) = ℕ.1 + tail.count(s)

                compl_of_list(List.cons(head, tail)).count(s.c) = ℕ.1 + compl_of_list(tail).count(s.c)

                p(List.cons(head, tail))
            } else {
                s != head
                s.c != head.c

                List.cons(head, tail).count(s) = tail.count(s)

                compl_of_list(List.cons(head, tail)).count(s.c) = compl_of_list(tail).count(s.c)
                
                p(List.cons(head, tail))
            }
            p(List.cons(head, tail))
        }
    }
    p(l)
}

theorem compl_of_list_preserve_unique[K](l: List[Set[K]]) {
    l.is_unique implies compl_of_list(l).is_unique
} by {
    forall(s: Set[K]) {
        l.count(s.c) <= ℕ.1
        compl_of_list(l).count(s) <= ℕ.1
    }
}

theorem compl_of_list_reflect[K](l: List[Set[K]]) {
    compl_of_list(compl_of_list(l)) = l
} by {
    l.map(Set[K].c).map(Set[K].c) = l.map(compose(Set[K].c, Set[K].c))
}

theorem equivalent_of_compl_set_to_list[K](a: Set[Set[K]], l: List[Set[K]]) {
    a.have_exact_list(l) implies compl_of_sets(a).have_exact_list(compl_of_list(l))
} by {
    a.contains = l.contains
    forall(s: Set[K]) {
        s.c ∈ a iff s.c ∈ l
        if s ∈ compl_of_sets(a) {
            s.c ∈ a
            s.c ∈ l
            s.c.c ∈ l.map(Set[K].c)
            s ∈ compl_of_list(l)
        }
        if s ∈ compl_of_list(l) {
            s ∈ l.map(Set[K].c)
            s.c ∈ l.map(Set[K].c).map(Set[K].c)
            s.c ∈ l
            s.c ∈ a
            s ∈ compl_of_sets(a)
        }
        s ∈ compl_of_sets(a) iff s ∈ compl_of_list(l)
    } 
    compl_of_sets(a).contains = compl_of_list(l).contains
    compl_of_list(l).is_unique
}

theorem equivalent_of_compl_list_to_set[K](l: List[Set[K]]) {
    list_to_set(compl_of_list(l)) = compl_of_sets(list_to_set(l))
} by {
    forall(s: Set[K]) {
        if s ∈ list_to_set(compl_of_list(l)) {
            s ∈ compl_of_list(l)
            s.c ∈ l
            s.c ∈ list_to_set(l)
            s ∈ compl_of_sets(list_to_set(l))
        }
    }
    list_to_set(compl_of_list(l)) ⊆ compl_of_sets(list_to_set(l))
    forall(s: Set[K]) {
        if s ∈ compl_of_sets(list_to_set(l)) {
            s.c ∈ list_to_set(l)
            s.c ∈ l
            s ∈ compl_of_list(l)
            s ∈ list_to_set(compl_of_list(l))
        }
    }
    list_to_set(compl_of_list(l)) ⊇ compl_of_sets(list_to_set(l))
}

theorem union_intersection_compl_dual_general[K](l: List[Set[K]]) {
    union_of_list(l).c = intersection_of_list(compl_of_list(l))
} by {
    union_of_list(l) = union(list_to_set(l))
    union(list_to_set(l)).c = intersection(compl_of_sets(list_to_set(l)))
    intersection(compl_of_sets(list_to_set(l))) = intersection(list_to_set(compl_of_list(l)))
    intersection(list_to_set(compl_of_list(l))) = intersection_of_list(compl_of_list(l))
}

theorem empty_union_is_empty[K] {
    union_of_list(List[Set[K]].nil) = Set[K].empty_set
} 

theorem union_of_list_decomposition[K](head: Set[K], tail: List[Set[K]]) {
    union_of_list(List.cons(head, tail)) = head ∪ union_of_list(tail)
} by {
    intersection_of_list(List.cons(head, tail).map(Set[K].c)) = head.c ∩ intersection_of_list(tail.map(Set[K].c))
}

theorem union_of_list_recursion_decomposition[K](head: Set[K], tail: List[Set[K]]) {
    union_of_list_recursion(List.cons(head, tail)) = head ∪ union_of_list_recursion(tail)
}

theorem equivalent_of_two_definiton_of_union_of_list[K](list: List[Set[K]]) {
    union_of_list_recursion(list) = union_of_list(list)
} by {
    define p(l: List[Set[K]]) -> Bool {
        union_of_list_recursion(l) = union_of_list(l)
    }
    p(List[Set[K]].nil) 
    forall(head: Set[K], tail: List[Set[K]]) {
        if p(tail) {
            union_of_list_recursion(List.cons(head, tail)) = head ∪ union_of_list_recursion(tail)

            union_of_list(List.cons(head, tail)) = head ∪ union_of_list(tail)

            union_of_list_recursion(tail) = union_of_list(tail)

            union_of_list_recursion(List.cons(head, tail)) = union_of_list(List.cons(head, tail))

            p(List.cons(head, tail))
        }
    }
    p(list)
}

theorem equivalent_of_union_of_list_recursion_and_set[K](list: List[Set[K]]) {
    union(list_to_set(list)) = union_of_list_recursion(list)
} 

theorem equivalent_of_union_of_exact_list_recursion_and_set[K](c: Set[Set[K]], list: List[Set[K]]) {
    c.have_exact_list(list) implies union(c) = union_of_list_recursion(list)
} 

theorem union_of_unique_list[K](list: List[Set[K]]) {
    union_of_list(list.unique) = union_of_list(list)
} by {
    list.contains = list.unique.contains

    forall(x: K) {
        if x ∈ union_of_list(list.unique) {
            let (s: Set[K]) satisfy {
                s ∈ list.unique and x ∈ s
            }  
            s ∈ list 
            x ∈ union_of_list(list)
        }
    }
    union_of_list(list.unique) ⊆ union_of_list(list)

    forall(x: K) {
        if x ∈ union_of_list(list) {
            let (s: Set[K]) satisfy {
                s ∈ list and x ∈ s
            } 
            s ∈ list.unique
            x ∈ union_of_list(list.unique)
        }
    }
    union_of_list(list) ⊆ union_of_list(list.unique)

    union_of_list(list.unique) = union_of_list(list)
}

theorem two_intersection_from_general[K](a1: Set[K], a2: Set[K]) {
    a1 ∩ a2 = intersection(list_to_set(List.cons(a1, List.singleton(a2))))
} 

define is_set_of_finite_intersection[K](n: Set[Set[K]], s: Set[K]) -> Bool {
    exists(c: Set[Set[K]]) {
        c ⊆ n and c.is_finite and s = intersection(c)
    }
}

define sets_of_finite_intersection[K](n: Set[Set[K]]) -> Set[Set[K]] {
    Set[Set[K]].new(is_set_of_finite_intersection(n))
}

theorem sets_of_finite_intersection_preserve_two_intersection[K](n: Set[Set[K]], s1: Set[K], s2: Set[K]) {
    s1 ∈ sets_of_finite_intersection(n) and s2 ∈ sets_of_finite_intersection(n) implies s1 ∩ s2 ∈ sets_of_finite_intersection(n)
} by {
    let c1: Set[Set[K]] satisfy {
        c1 ⊆ n and c1.is_finite and s1 = intersection(c1)
    }
    is_set_of_finite_intersection(n, s2)
    let c2: Set[Set[K]] satisfy {
        c2 ⊆ n and c2.is_finite and s2 = intersection(c2)
    }

    let c = c1 ∪ c2
    c1 ∪ c2 ⊆ n
    c ⊆ n
    c.is_finite
    c1 ⊆ c
    c2 ⊆ c
    intersection(c) ⊆ intersection(c1)
    intersection(c) ⊆ intersection(c2)
    intersection(c) ⊆ s1 ∩ s2

    forall(x: K) {
        if x ∈ s1 ∩ s2 {
            x ∈ s1
            x ∈ s2
            x ∈ intersection(c1)
            x ∈ intersection(c2)
            forall(s: Set[K]) {
                if s ∈ c {
                    if s ∈ c1 {
                        x ∈ s
                    }
                    if s ∈ c2 {
                        x ∈ s
                    }
                    x ∈ s
                }
            }
            elem_in_intersection_general(c, x)
            x ∈ intersection(c)
        }
    }
    s1 ∩ s2 ⊆ intersection(c)

    s1 ∩ s2 = intersection(c)

    s1 ∩ s2 ∈ sets_of_finite_intersection(n)
}

define is_sets_of_finite_intersection[K](n: Set[Set[K]], s: Set[K]) -> Bool {
    s ∈ sets_of_finite_intersection(n)
}

theorem sets_of_finite_intersection_preserve_two[K](n: Set[Set[K]]) {
    preserve_two(Set[K].intersection, is_set_of_finite_intersection(n))
} by {
    forall(s1: Set[K], s2: Set[K]) {
        if is_set_of_finite_intersection(n)(s1) and is_set_of_finite_intersection(n)(s2) {
            s1 ∈ sets_of_finite_intersection(n)
            s2 ∈ sets_of_finite_intersection(n)
            s1 ∩ s2 ∈ sets_of_finite_intersection(n)
            is_set_of_finite_intersection(n)(Set[K].intersection(s1, s2))
        }
    }
}

theorem finite_intersection_preserve_sets_of_finite_intersection[K](n: Set[Set[K]], list: List[Set[K]]) {
    list.length != 0 and (forall(s: Set[K]) { s ∈ list implies s ∈ sets_of_finite_intersection(n) }) implies intersection_of_list(list) ∈ sets_of_finite_intersection(n)
} by {
    preserve_two(Set[K].intersection, is_set_of_finite_intersection(n))
    preserve_finite(Set[K].intersection, list, Set[K].universal_set, is_set_of_finite_intersection(n))
    forall(s: Set[K]) { 
        if s ∈ list {
            s ∈ sets_of_finite_intersection(n) 
            is_set_of_finite_intersection(n)(s)
        } 
    }
    is_set_of_finite_intersection(n)(two_to_finite(Set[K].intersection, list, Set[K].universal_set))
    is_set_of_finite_intersection(n)(intersection_of_list(list))
}

theorem sets_of_finite_intersection_superset[K](n: Set[Set[K]]) {
    sets_of_finite_intersection(n) ⊇ n
} by {
    forall(s: Set[K]) {
        if s ∈ n {
            let l = List[Set[K]].singleton(s)
            intersection_of_list(l) = s
            intersection(list_to_set(l)) = intersection_of_list(l) 
            forall(t: Set[K]) {
                if t = s {
                    t ∈ l
                    t ∈ list_to_set(l)
                    list_to_set(l).contains(t) = Set[Set[K]].singleton(s).contains(t)
                } else {
                    t ∉ l
                    t ∉ list_to_set(l)
                    list_to_set(l).contains(t) = Set[Set[K]].singleton(s).contains(t)
                }
                list_to_set(l).contains(t) = Set[Set[K]].singleton(s).contains(t)
            }
            list_to_set(l).contains = Set[Set[K]].singleton(s).contains
            list_to_set(l) = Set[Set[K]].singleton(s)
            list_to_set(l) ⊆ n
            list_to_set(l).have_super_list(l)
            list_to_set(l).is_finite
            intersection(list_to_set(l)) = s
            s ∈ sets_of_finite_intersection(n)
        }
    }
}

theorem sets_of_finite_intersection_preserve_non_empty[K](n: Set[Set[K]]) {
    n.is_nonempty implies sets_of_finite_intersection(n).is_nonempty
} by {
    sets_of_finite_intersection(n) ⊇ n
}

theorem sets_of_finite_intersection_preserve_intersection[K](n: Set[Set[K]]) {
    intersection(sets_of_finite_intersection(n)) = intersection(n)
} by {
    sets_of_finite_intersection(n) ⊇ n
    intersection(sets_of_finite_intersection(n)) ⊆ intersection(n)

    forall(x: K) {
        if x ∈ intersection(n) {
            forall(s: Set[K]) {
                if s ∈ sets_of_finite_intersection(n) {
                    let c: Set[Set[K]] satisfy {
                        c ⊆ n and c.is_finite and s = intersection(c)
                    }
                    intersection(n) ⊆ intersection(c)
                    x ∈ s
                }
            }
            x ∈ intersection(sets_of_finite_intersection(n))
        }
    }
    intersection(sets_of_finite_intersection(n)) ⊇ intersection(n)
}

define is_set_of_finite_union[K](n: Set[Set[K]], s: Set[K]) -> Bool {
    exists(c: Set[Set[K]]) {
        c ⊆ n and c.is_finite and s = union(c)
    }
}

define sets_of_finite_union[K](n: Set[Set[K]]) -> Set[Set[K]] {
    Set[Set[K]].new(is_set_of_finite_union(n))
}

theorem sets_of_finite_intersection_union_dual[K](n: Set[Set[K]]) {
    sets_of_finite_intersection(compl_of_sets(n)) = compl_of_sets(sets_of_finite_union(n))
} by {
    forall(s: Set[K]) {
        if s ∈ sets_of_finite_intersection(compl_of_sets(n)) {
            let c: Set[Set[K]] satisfy {
                c ⊆ compl_of_sets(n) and c.is_finite and s = intersection(c)
            }
            s = union(compl_of_sets(c)).c
            forall(t: Set[K]) {
                if t ∈ compl_of_sets(c) {
                    t.c ∈ c
                    t.c ∈ compl_of_sets(n)
                    t ∈ n
                }
            }
            compl_of_sets(c) ⊆ n
            compl_of_sets(c).is_finite
            union(compl_of_sets(c)) ∈ sets_of_finite_union(n)
            s ∈ compl_of_sets(sets_of_finite_union(n))
        }
    }
    sets_of_finite_intersection(compl_of_sets(n)) ⊆ compl_of_sets(sets_of_finite_union(n))

    forall(s: Set[K]) {
        if s ∈ compl_of_sets(sets_of_finite_union(n)) {
            s.c ∈ sets_of_finite_union(n)
            let c: Set[Set[K]] satisfy {
                c ⊆ n and c.is_finite and s.c = union(c)
            }
            s = union(c).c
            s = intersection(compl_of_sets(c))
            forall(t: Set[K]) {
                if t ∈ compl_of_sets(c) {
                    t.c ∈ c
                    t.c ∈ n
                    t ∈ compl_of_sets(n)
                }
            }
            compl_of_sets(c) ⊆ compl_of_sets(n)
            compl_of_sets(c).is_finite
            intersection(compl_of_sets(c)) ∈ sets_of_finite_intersection(compl_of_sets(n))
            s ∈ sets_of_finite_intersection(compl_of_sets(n))
        }
    }
    sets_of_finite_intersection(compl_of_sets(n)) ⊇ compl_of_sets(sets_of_finite_union(n))    
}

theorem sets_of_finite_union_preserve_two_union[K](n: Set[Set[K]], s1: Set[K], s2: Set[K]) {
    s1 ∈ sets_of_finite_union(n) and s2 ∈ sets_of_finite_union(n) implies s1 ∪ s2 ∈ sets_of_finite_union(n)
} by {
    s1.c ∈ sets_of_finite_intersection(compl_of_sets(n))
    s2.c ∈ sets_of_finite_intersection(compl_of_sets(n))
    s1.c ∩ s2.c ∈ sets_of_finite_intersection(compl_of_sets(n))
    s1.c ∩ s2.c = (s1 ∪ s2).c
    (s1 ∪ s2).c ∈ compl_of_sets(sets_of_finite_union(n))
    s1 ∪ s2 ∈ sets_of_finite_union(n)
}

define is_sets_of_finite_union[K](n: Set[Set[K]], s: Set[K]) -> Bool {
    s ∈ sets_of_finite_union(n)
}

theorem sets_of_finite_union_preserve_two[K](n: Set[Set[K]]) {
    preserve_two(Set[K].union, is_set_of_finite_union(n))
} by {
    forall(s1: Set[K], s2: Set[K]) {
        if is_set_of_finite_union(n)(s1) and is_set_of_finite_union(n)(s2) {
            s1 ∈ sets_of_finite_union(n)
            s2 ∈ sets_of_finite_union(n)
            s1 ∪ s2 ∈ sets_of_finite_union(n)
            is_set_of_finite_union(n)(Set[K].union(s1, s2))
        }
    }
} 

theorem finite_union_preserve_sets_of_finite_union[K](n: Set[Set[K]], list: List[Set[K]]) {
    list.length != 0 and (forall(s: Set[K]) { s ∈ list implies s ∈ sets_of_finite_union(n) }) implies union_of_list(list) ∈ sets_of_finite_union(n)
} by {
    preserve_two(Set[K].union, is_set_of_finite_union(n))
    preserve_finite(Set[K].union, list, Set[K].empty_set, is_set_of_finite_union(n))
    forall(s: Set[K]) { 
        if s ∈ list {
            s ∈ sets_of_finite_union(n) 
            is_set_of_finite_union(n)(s)
        } 
    }
    is_set_of_finite_union(n)(two_to_finite(Set[K].union, list, Set[K].empty_set))
    is_set_of_finite_union(n)(union_of_list(list))
}

/// A finite set is a `Set` bundled with a finiteness proof.
structure Finite_Set[T] {
    /// The underlying set.
    set: Set[T]
} constraint {
    set.is_finite
}

attributes Finite_Set[T] {
    /// Access the underlying set.
    define as_set(self) -> Set[T] {
        self.set
    }

    /// Membership predicate.
    define contains(self, x: T) -> Bool {
        self.set.contains(x)
    }

    /// The empty finite set.
    let empty: Finite_Set[T] = Finite_Set.new(Set[T].empty_set)

    /// Subset relation lifted from sets.
    define subset_eq(self, other: Finite_Set[T]) -> Bool {
        self.set.subset_eq(other.set)
    }

    /// Superset relation lifted from sets.
    define superset_eq(self, other: Finite_Set[T]) -> Bool {
        self.set.superset_eq(other.set)
    }

    /// Union of finite sets.
    define union(self, other: Finite_Set[T]) -> Finite_Set[T] {
        Finite_Set.new(self.set ∪ other.set)
    }

    /// Intersection of finite sets.
    define intersection(self, other: Finite_Set[T]) -> Finite_Set[T] {
        Finite_Set.new(self.set ∩ other.set)
    }

    /// Difference of finite sets.
    define difference(self, other: Finite_Set[T]) -> Finite_Set[T] {
        Finite_Set.new(self.set ∖ other.set)
    }

    /// Empty predicate.
    define is_empty(self) -> Bool {
        self.set.is_empty
    }

    /// Cardinality helper lifted from sets.
    define cardinality_at_most(self, n: ℕ) -> Bool {
        self.set.cardinality_at_most(n)
    }

    /// True if the cardinality equals n.
    define cardinality_is(self, n: ℕ) -> Bool {
        self.set.cardinality_is(n)
    }
}

theorem functional_insert_preserve_finite_constraint[T](f: T -> Bool, item: T) {
    finite_constraint(f) implies finite_constraint(functional_insert(f, item))
}

theorem functional_remove_preserve_finite_constraint[T](f: T -> Bool, item: T) {
    finite_constraint(f) implies finite_constraint(functional_remove(f, item))
}

theorem functional_insert_preserve_finite[T](s: Set[T], item: T) {
    s.is_finite implies s.insert(item).is_finite
} by {
    finite_constraint(s.contains) 
    finite_constraint(functional_insert(s.contains, item))
    s.insert(item).contains = functional_insert(s.contains, item)
    finite_constraint(s.insert(item).contains)
}

theorem functional_remove_preserve_finite[T](s: Set[T], item: T) {
    s.is_finite implies s.remove(item).is_finite
} by {
    finite_constraint(s.contains) 
    finite_constraint(functional_remove(s.contains, item))
    s.remove(item).contains = functional_remove(s.contains, item)
    finite_constraint(s.remove(item).contains)
}

attributes Finite_Set[T] {
    /// Converts a list to a finite set.
    let from_list: List[T] -> Finite_Set[T] = function(ts: List[T]) {
        Finite_Set.new(Set[T].new(ts.contains))
    }

    /// Insert preserves finiteness.
    define insert(self, item: T) -> Finite_Set[T] {
        Finite_Set.new(self.set.insert(item))
    }

    /// Remove preserves finiteness.
    define remove(self, item: T) -> Finite_Set[T] {
        Finite_Set.new(self.set.remove(item))
    }
}

theorem insert_contains[T](a: Finite_Set[T], item: T) {
    item ∈ a.insert(item)
} by {
    a.set.is_finite
    a.set.insert(item).is_finite
}

theorem remove_does_not_contain[T](a: Finite_Set[T], item: T) {
    not item ∈ a.remove(item)
} by {
    a.set.is_finite
    a.set.remove(item).is_finite
}

theorem insert_other_contains_eq[T](a: Finite_Set[T], item: T, other: T) {
    item != other implies item ∈ a = item ∈ a.insert(other)
} by {
    a.set.is_finite
    a.set.insert(other).is_finite
}

theorem remove_other_contains_eq[T](a: Finite_Set[T], item: T, other: T) {
    item != other implies item ∈ a = item ∈ a.remove(other)
} by {
    a.set.is_finite
    a.set.insert(other).is_finite
    a.set.remove(other).is_finite
}

theorem remove_then_insert[T](a: Finite_Set[T], item: T) {
    item ∈ a implies a.remove(item).insert(item) = a
} by {
    a.set.is_finite
    a.set.remove(item).is_finite
    a.set.remove(item).insert(item).is_finite
}

theorem insert_then_remove[T](a: Finite_Set[T], item: T) {
    not item ∈ a implies a.insert(item).remove(item) = a
} by {
    a.set.is_finite
    a.set.insert(item).is_finite
    a.set.insert(item).remove(item).is_finite
}