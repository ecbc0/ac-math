from nat import ℕ
from set import is_bijective, is_injective, is_surjective, Set, Product, union_index, intersection_index, fn_image, compose
from list import partial_sum, range_sum, sum
numerals ℕ

// Cantor pairing function diagonal enumeration diagram:
// (a,b) pairs are traversed along diagonals a+b = constant
// b=4 | (0,4) (1,4) (2,4) (3,4) ...
// b=3 | (0,3) (1,3) (2,3) (3,3) ...
// b=2 | (0,2) (1,2) (2,2) (3,2) ...
// b=1 | (0,1) (1,1) (2,1) (3,1) ...
// b=0 | (0,0) (1,0) (2,0) (3,0) ...
//       ----------------------------→ a
//         a=0   a=1   a=2   a=3

/// The sum of the first 1 positive integers equals 1.
theorem range_sum_suc_one {
    range_sum(ℕ.suc, 1) = 1
}

/// The sum of the first 2 positive integers equals 3.
theorem range_sum_suc_two {
    range_sum(ℕ.suc, 2) = 3
} by {
    range_sum(ℕ.suc, 2) = range_sum(ℕ.suc, 1) + ℕ.suc(1)
    range_sum(ℕ.suc, 1) + ℕ.suc(1) = 1 + 2
    1 + 2 = 3
}


/// Cantor pairing function: encodes ordered pairs of natural numbers as a single natural number.
/// Maps (a,b) to the position along diagonals where diagonal index is a+b.
define cantor_pair(a: ℕ, b: ℕ) -> ℕ {
    range_sum(ℕ.suc, a + b) + a
}

/// The Cantor pairing function maps (0,0) to 0.
theorem cantor_pair_at_zero_zero {
    cantor_pair(0, 0) = 0
} by {
    cantor_pair(0, 0) = range_sum(ℕ.suc, 0)
}

/// The Cantor pairing function maps (0,2) to 3.
theorem cantor_pair_at_zero_two {
    cantor_pair(0, 2) = 3
} by {
    cantor_pair(0, 2) = range_sum(ℕ.suc, 2)
}

/// Recursive definition of range_sum for the successor function.
theorem range_sum_suc(n: ℕ) {
    range_sum(ℕ.suc, n.suc) = range_sum(ℕ.suc, n) + n.suc
} 

/// The Cantor pairing function preserves order when the sum of coordinates differs by exactly one.
theorem cantor_pair_lt_suc(a1: ℕ, b1: ℕ, a2: ℕ, b2: ℕ) {
    (a1 + b1).suc = a2 + b2 implies cantor_pair(a1, b1) < cantor_pair(a2, b2)
} by {
    a1 <= a1 + b1
    0 <= a2
    cantor_pair(a1, b1) <= range_sum(ℕ.suc, a1 + b1) + (a1 + b1)
    range_sum(ℕ.suc, a1 + b1) + (a1 + b1) < range_sum(ℕ.suc, a1 + b1) + (a1 + b1).suc
    range_sum(ℕ.suc, a2 + b2) = range_sum(ℕ.suc, a1 + b1) + (a1 + b1).suc
    range_sum(ℕ.suc, a2 + b2) <= cantor_pair(a2, b2)
    cantor_pair(a1, b1) < range_sum(ℕ.suc, a2 + b2)
}

/// The Cantor pairing function preserves strict order on sums of coordinates.
/// Proved by induction on the sum a2 + b2.
theorem cantor_pair_lt(a1: ℕ, b1: ℕ, a2: ℕ, b2: ℕ) {
    a1 + b1 < a2 + b2 implies cantor_pair(a1, b1) < cantor_pair(a2, b2)
} by {
    // Define induction predicate: for fixed (a1,b1), all pairs with sum n have greater cantor_pair values
    define p(n: ℕ) -> Bool {
        forall(a: ℕ, b: ℕ) {
            a1 + b1 < a + b and a + b = n implies cantor_pair(a1, b1) < cantor_pair(a, b)
        }
    }
    p(0)
    forall(n: ℕ) {
        if p(n) {
            forall(a: ℕ, b: ℕ) {
                if a1 + b1 < a + b and a + b = n.suc {
                    if a1 + b1 = n {
                        cantor_pair(a1, b1) < cantor_pair(a, b)
                    } else {
                        // Use induction hypothesis on the intermediate pair (n, 0)
                        a1 + b1 < n
                        let x = n
                        let y = 0
                        x + y = n
                        a1 + b1 < x + y
                        cantor_pair(a1, b1) < cantor_pair(x, y)
                        // Use cantor_pair_lt_suc to compare (n, 0) with (a, b)
                        cantor_pair(x, y) < cantor_pair(a, b)
                        cantor_pair(a1, b1) < cantor_pair(a, b)
                    }
                }
            }
            p(n.suc)
        }
    }
    p(a2 + b2)
}

/// Distinct sums of coordinates produce distinct Cantor pair values.
theorem cantor_pair_lt_imp_neq(a1: ℕ, b1: ℕ, a2: ℕ, b2: ℕ) {
    a1 + b1 < a2 + b2 implies cantor_pair(a1, b1) != cantor_pair(a2, b2)
}

/// Unequal sums of coordinates imply unequal Cantor pair values.
theorem cantor_pair_is_injective_lemma(a1: ℕ, b1: ℕ, a2: ℕ, b2: ℕ) {
    a1 + b1 != a2 + b2 implies cantor_pair(a1, b1) != cantor_pair(a2, b2)
}

/// On the same diagonal (equal sum), the first coordinate uniquely determines the second.
theorem sum_eq_imp_both_eq_or_neq_lemma(a1: ℕ, b1: ℕ, a2: ℕ, b2: ℕ) {
    a1 + b1 = a2 + b2 implies (a1 = a2 iff b1 = b2)
} by {
    a1 = a2 implies b1 = b2
}

/// The Cantor pairing function is injective: distinct pairs map to distinct values.
theorem cantor_pair_is_injective_raw(a1: ℕ, b1: ℕ, a2: ℕ, b2: ℕ) {
    not (a1 = a2 and b1 = b2) implies cantor_pair(a1, b1) != cantor_pair(a2, b2)
} by {
    // Case 1: pairs lie on different diagonals
    if a1 + b1 = a2 + b2 {
        a1 != a2
        cantor_pair(a1, b1) = range_sum(ℕ.suc, a1 + b1) + a1
        cantor_pair(a2, b2) = range_sum(ℕ.suc, a2 + b2) + a2
        range_sum(ℕ.suc, a1 + b1) = range_sum(ℕ.suc, a2 + b2)
        cantor_pair(a1, b1) != cantor_pair(a2, b2)
    } else {
        // Case 2: pairs lie on different diagonals
        a1 + b1 != a2 + b2
        cantor_pair(a1, b1) != cantor_pair(a2, b2)
    }
}

/// Every natural number lies on some diagonal between its inclusive lower bound and exclusive upper bound.
/// This lemma is proved by induction on n.
theorem cantor_pair_is_surjective_lemma(n: ℕ) {
    exists(m: ℕ) {
        range_sum(ℕ.suc, m) <= n and n < range_sum(ℕ.suc, m.suc)
    }
} by {
    // Define induction predicate: x lies on some diagonal
    define p(x: ℕ) -> Bool {
        exists(m: ℕ) {
            range_sum(ℕ.suc, m) <= x and x < range_sum(ℕ.suc, m.suc)
        }
    }
    // Base case: 0 lies on diagonal 0
    range_sum(ℕ.suc, 0) = 0
    p(0)
    // Inductive step
    forall(x: ℕ) {
        if p(x) {
            let m: ℕ satisfy {
                range_sum(ℕ.suc, m) <= x and x < range_sum(ℕ.suc, m.suc)
            }
            x.suc <= range_sum(ℕ.suc, m.suc)
            // Case 1: x.suc equals the upper bound of current diagonal
            if x.suc = range_sum(ℕ.suc, m.suc) {
                range_sum(ℕ.suc, m.suc) <= x.suc
                range_sum(ℕ.suc, m.suc) < range_sum(ℕ.suc, m.suc.suc)
                x.suc < range_sum(ℕ.suc, m.suc.suc)
                p(x.suc)
            } else {
                // Case 2: x.suc is still on the current diagonal
                x.suc < range_sum(ℕ.suc, m.suc)
                range_sum(ℕ.suc, m) <= x.suc
                p(x.suc)
            }
            p(x.suc)
        }
    }
    p(n)
}

/// The Cantor pairing function is surjective: every natural number is the image of some pair.
theorem cantor_pair_is_surjective_raw(n: ℕ) {
    exists(a: ℕ, b: ℕ) {
        cantor_pair(a, b) = n
    }
} by {
    // Find the diagonal containing n
    let m: ℕ satisfy {
        range_sum(ℕ.suc, m) <= n and n < range_sum(ℕ.suc, m.suc)
    }
    // The first coordinate a is the offset within the diagonal
    let a = n - range_sum(ℕ.suc, m)
    n - range_sum(ℕ.suc, m) < range_sum(ℕ.suc, m.suc) - range_sum(ℕ.suc, m)
    range_sum(ℕ.suc, m.suc) - range_sum(ℕ.suc, m) = m.suc
    a < m.suc
    a <= m
    // The second coordinate b makes the sum equal to m
    let b = m - a
    a + b = m
    n = range_sum(ℕ.suc, m) + a
    n = cantor_pair(a, b)
}

/// Cantor pairing function defined on Product[ℕ, ℕ] type.
define c_pair(p: Product[ℕ, ℕ]) -> ℕ {
    cantor_pair(p.first, p.second)
}

/// The Cantor pairing function is injective on Product[ℕ, ℕ].
theorem cantor_pair_is_injective {
    is_injective(c_pair)
} by {
    forall(p1: Product[ℕ, ℕ], p2: Product[ℕ, ℕ]) {
        if p1 != p2 {
            let a1 = p1.first
            let b1 = p1.second
            let a2 = p2.first
            let b2 = p2.second
            not (a1 = a2 and b1 = b2)
            cantor_pair(a1, b1) != cantor_pair(a2, b2)
            c_pair(p1) != c_pair(p2)
        }
    }
}

/// The Cantor pairing function is surjective on Product[ℕ, ℕ].
theorem cantor_pair_is_surjective {
    is_surjective(c_pair)
} by {
    forall(n: ℕ) {
        let (a: ℕ, b: ℕ) satisfy {
            cantor_pair(a, b) = n
        }
        let p = Product.new(a, b)
        c_pair(p) = n
    }
}

/// The Cantor pairing function is bijective on Product[ℕ, ℕ].
theorem cantor_pair_is_bijective {
    is_bijective(c_pair)
}

/// The inverse of the Cantor pairing function.
let c_pair_inv(n: ℕ) -> p: Product[ℕ, ℕ] satisfy {
    c_pair(p) = n
} by {
    is_surjective(c_pair)
    let p: Product[ℕ, ℕ] satisfy {
        c_pair(p) = n
    }
}

/// c_pair_inv is a left inverse of c_pair.
theorem c_pair_inv_is_inv_1(n: ℕ) {
    c_pair(c_pair_inv(n)) = n
}

/// c_pair_inv is a right inverse of c_pair.
theorem c_pair_inv_is_inv_2(p: Product[ℕ, ℕ]) {
    c_pair_inv(c_pair(p)) = p
} by {
    c_pair(c_pair_inv(c_pair(p))) = c_pair(p)
    is_injective(c_pair)
    c_pair_inv(c_pair(p)) = p
}

/// The inverse function c_pair_inv is injective.
theorem c_pair_inv_is_injective {
    is_injective(c_pair_inv)
} by {
    forall(n1: ℕ, n2: ℕ) {
        if c_pair_inv(n1) = c_pair_inv(n2) {
            c_pair(c_pair_inv(n1)) = c_pair(c_pair_inv(n2))
            c_pair(c_pair_inv(n1)) = n1
            c_pair(c_pair_inv(n2)) = n2
            n1 = n2
        }
    }
}

/// The inverse function c_pair_inv is surjective.
theorem c_pair_inv_is_surjective {
    is_surjective(c_pair_inv)
} by {
    forall(p: Product[ℕ, ℕ]) {
        c_pair_inv(c_pair(p)) = p
    }
}

/// The inverse function c_pair_inv is bijective.
theorem c_pair_inv_is_bijective {
    is_bijective(c_pair_inv)
}

/// An operation preserves countability: if the image of f is a subset of s, then op(f) is in s.
define preserve_countable[T](op: (ℕ -> T) -> T, s: Set[T]) -> Bool {
    forall(f: ℕ -> T) {
        fn_image(f) ⊆ s implies op(f) ∈ s
    }
}

/// If op preserves countability and f is a family of functions whose images are subsets of s,
/// then op composed with the family of functions produces an element of s.
theorem countable_preserve_countable[T](op: (ℕ -> T) -> T, s: Set[T], f: ℕ -> (ℕ -> T)) {
    preserve_countable(op, s) and forall(n: ℕ) { fn_image(f(n)) ⊆ s } implies op(compose[ℕ, ℕ -> T, T](op, f)) ∈ s
} by {
    // Show that the image of the composed function is a subset of s
    forall(x: T) {
        if x ∈ fn_image(compose[ℕ, ℕ -> T, T](op, f)) {
            let n: ℕ satisfy {
                x = compose[ℕ, ℕ -> T, T](op, f)(n)
            }
            x = op(f(n))
            x ∈ s
        }
        fn_image(compose[ℕ, ℕ -> T, T](op, f)) ⊆ s
    }
    op(compose[ℕ, ℕ -> T, T](op, f)) ∈ s
}