from type_class.add import Add
from real import ℝ
from nat import ℕ
from set import is_bijective

// Temporarily not consider dimension, waiting for dependent type

/// Temporarily just use ℝ, ignore ℂ, ℂ' and other field or division algebra
typeclass V: Vec extends Add {
    scal: (ℝ, V) -> V

    vec_distrib(a: ℝ, v1: V, v2: V) {
        Vec.scal(a, v1 + v2) = Vec.scal(a, v1) + Vec.scal(a, v2)
    }

    scal_distrib(a1: ℝ, a2: ℝ, v: V) {
        Vec.scal(a1 + a2, v) = Vec.scal(a1, v) + Vec.scal(a2, v)
    }

    unit_scal(v: V) {
        Vec.scal(ℝ.1, v) = v
    }

    zero_scal(v: V) {
        Vec.scal(ℝ.0, v) = V.0
    }
    
    scal_assco(a1: ℝ, a2: ℝ, v: V) {
        Vec.scal(a1, Vec.scal(a2, v)) = Vec.scal(a1 ⋅ a2, v)
    }
}

instance ℝ: Vec {
    let scal = ℝ.mul
}

let scal[V] = Vec.scal[V]

theorem add_neg_is_scal_reverse[V: Vec](v: V) {
    scal(-ℝ.1, v) = -v
} by {
    scal(-ℝ.1, v) + v = scal(-ℝ.1, v) + scal(ℝ.1, v)
    scal(-ℝ.1, v) + scal(ℝ.1, v) = scal(-ℝ.1 + ℝ.1, v)
    scal(-ℝ.1 + ℝ.1, v) = scal(ℝ.0, v)
}

define scal_hom[V: Vec, W: Vec](f: V -> W) -> Bool {
    forall(a: ℝ, v: V) {
        f(scal[V](a, v)) = scal[W](a, f(v)) 
    }
}

define add_hom[V: Vec, W: Vec](f: V -> W) -> Bool {
    forall(v: V, w: V) {
        f(v + w) = f(v) + f(w) 
    }
}

define is_linear[V: Vec, W: Vec](f: V -> W) -> Bool
 {
    scal_hom(f) and add_hom(f)
}

define is_linear_isom[V: Vec, W: Vec](f: V -> W) -> Bool {
    is_linear(f) and is_bijective(f)
}

// Temporarily workaround
structure Vec_Product[V: Vec] {
    dim: ℕ
    c: ℕ -> V
} constraint {
    forall(idx: ℕ) {
        idx >= dim implies c(idx) = V.0
    }
} by {
    let dim = ℕ.1
    define c(n: ℕ) -> V {
        V.0
    }
}