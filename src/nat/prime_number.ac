from nat.nat_divide import Nat, divides_suc
from nat.nat_base import true_below, strong_induction
// from list import List
numerals Nat

attributes Nat {
    define is_composite(self) -> Bool {
        exists(a: Nat) {
            a.proper_divides(self)
        }
    }

    define is_prime(self) -> Bool {
        forall(a: Nat) {
            self > 1 and not a.proper_divides(self)
        }
    }
}

attributes Nat {
    define is_direct_composite(self) -> Bool {
        exists(a: Nat, b: Nat) {
            (1 < a and a < self) and
            (1 < b and b < self) and
            a * b = self
        }
    }
}

theorem composite_is_direct_composite(n: Nat) {
    n.is_composite iff n.is_direct_composite
} by {
    if n.is_composite {
        let a: Nat satisfy { a.proper_divides(n) }
        let b: Nat satisfy { a * b = n }
        b.proper_divides(n)
        (
            (1 < a and a < n) and
            (1 < b and b < n) and
            a * b = n
        )
        n.is_direct_composite
    }
}

theorem composite_is_not_prime(n: Nat) {
    n.is_prime iff n > 1 and not n.is_composite
} by {
    n.is_prime implies not n.is_composite
}

theorem has_prime_divisor(n: Nat) {
    1 < n implies exists(p: Nat) {
        p.is_prime and p.divides(n)
    }
} by {
    forall(k: Nat) {
        if true_below(has_prime_divisor, k) {
            if k.is_prime {
                k.divides(k)
                has_prime_divisor(k)
            }
            if k.is_composite {
                k.is_direct_composite
                let (b: Nat, c: Nat) satisfy {
                    1 < b and b < k and k = b * c
                }
                has_prime_divisor(b)
                let (p: Nat) satisfy {
                    p.is_prime and p.divides(b)
                }
                p.divides(k)
                has_prime_divisor(k)
            }
            has_prime_divisor(k)
        }
    }
    has_prime_divisor(n)
}

from list import List, Add, sum, common_item

define all_prime(l: List[Nat]) -> Bool {
    forall(n: Nat) {
        n ∈ l implies n.is_prime
    }
}

instance Nat: Add {
    let add: (Nat, Nat) -> Nat = Nat.mul

    let 0 = Nat.1
}

let product = sum[Nat] 

// todo: uniqueness
theorem prime_decomposition(n: Nat) {
    1 < n implies exists(l: List[Nat]) {
        all_prime(l) and n = product(l)
    }
} by {
    forall(k: Nat) {
        if true_below(prime_decomposition, k) {
            if k.is_prime {
                let l = List.singleton(k)
                product(l) = k
                forall(m: Nat) {
                    m ∈ l implies m = k
                    k.is_prime
                    m ∈ l implies m.is_prime
                }
                all_prime(l)
                prime_decomposition(k)
            } 
            if k.is_composite {
                k.is_direct_composite
                let (a: Nat, b: Nat) satisfy {
                    (1 < a and a < k) and
                    (1 < b and b < k) and 
                    a * b = k
                }
                prime_decomposition(a)
                prime_decomposition(b)
                let la: List[Nat] satisfy {
                    all_prime(la) and a = product(la)
                }
                let lb: List[Nat] satisfy {
                    all_prime(lb) and b = product(lb)
                }
                let l = la + lb
                forall(x: Nat) {
                    x ∈ la + lb implies x ∈ la or x ∈ lb
                    x ∈ la implies x.is_prime
                    x ∈ lb implies x.is_prime
                    x ∈ l implies x.is_prime
                }
                all_prime(l)
                product(la + lb) = a * b
                product(l) = k
                prime_decomposition(k)
            }
            prime_decomposition(k)
        }
    }
    prime_decomposition(n)
}

from nat.nat_combo import divides_factorial

theorem exists_infinite_primes(n: Nat) {
    exists(p: Nat) {
        p > n and p.is_prime
    }
} by {
    let m: Nat = n.! + 1
    1 < m
    let (p: Nat) satisfy {
        p.is_prime and p.divides(m)
    }
    p > 1
    p != 1
    if p <= n {
        divides_factorial(p, n)
        p.divides(n.!)
        p.divides(n.! + 1)
        not divides_suc(p, n.!)
        false
    }
    not (p <= n)
    p > n
}

// prepare for the defition of rational number
attributes Nat {
    define relative_prime(self, a: Nat) -> Bool {
        forall(l: List[Nat], la: List[Nat]) {
            (all_prime(l) and product(l) = self) and
            (all_prime(la) and product(la) = a) implies
            forall(p: Nat) {
                not common_item(l, la, p)
            }
        }
    }
}