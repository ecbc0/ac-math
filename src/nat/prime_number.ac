from nat.nat_divide import Nat, divides_suc
from nat.nat_base import true_below, strong_induction
// from list import List
numerals Nat

attributes Nat {
    define is_composite(self) -> Bool {
        exists(a: Nat) {
            a.proper_divides(self)
        }
    }

    define is_prime(self) -> Bool {
        forall(a: Nat) {
            self > 1 and not a.proper_divides(self)
        }
    }
}

attributes Nat {
    define is_direct_composite(self) -> Bool {
        exists(a: Nat, b: Nat) {
            (1 < a and a < self) and
            (1 < b and b < self) and
            a * b = self
        }
    }

    define is_normal_composite(self) -> Bool {
        exists(a: Nat, b: Nat) {
            (1 < a) and
            (1 < b) and
            a * b = self
        }
    }
}

theorem composite_is_direct_composite(n: Nat) {
    n.is_composite iff n.is_direct_composite
} by {
    if n.is_composite {
        let a: Nat satisfy { a.proper_divides(n) }
        let b: Nat satisfy { a * b = n }
        b.proper_divides(n)
        (
            (1 < a and a < n) and
            (1 < b and b < n) and
            a * b = n
        )
        n.is_direct_composite
    }
}

theorem normal_composite_is_direct_composite(n: Nat) {
    n.is_normal_composite iff n.is_direct_composite
} by {
    n.is_direct_composite implies n.is_normal_composite

    if n.is_normal_composite {
        let (a: Nat, b: Nat) satisfy {
            (1 < a) and
            (1 < b) and
            a * b = n
        }
        a != 0
        b != 0
        a <= n
        b <= n
        a != 1
        b != 1
        a != n
        b != n
        a < n
        b < n

        n.is_direct_composite
    }
}

theorem composite_is_normal_composite(n: Nat) {
    n.is_composite iff n.is_normal_composite
}

theorem composite_is_not_prime(n: Nat) {
    n.is_prime iff n > 1 and not n.is_composite
} by {
    n.is_prime implies not n.is_composite
}

theorem not_prime_iff_lte_one_or_composite(n: Nat) {
    not n.is_prime iff n <= 1 or n.is_composite
} by {
    not n.is_prime implies n <= 1 or n.is_composite
    n <= 1 or n.is_composite implies not n.is_prime
}

theorem has_prime_divisor(n: Nat) {
    1 < n implies exists(p: Nat) {
        p.is_prime and p.divides(n)
    }
} by {
    forall(k: Nat) {
        if true_below(has_prime_divisor, k) {
            if k.is_prime {
                k.divides(k)
                has_prime_divisor(k)
            }
            if k.is_composite {
                k.is_direct_composite
                let (b: Nat, c: Nat) satisfy {
                    1 < b and b < k and k = b * c
                }
                has_prime_divisor(b)
                let (p: Nat) satisfy {
                    p.is_prime and p.divides(b)
                }
                p.divides(k)
                has_prime_divisor(k)
            }
            has_prime_divisor(k)
        }
    }
    has_prime_divisor(n)
}

from list import List, Add, sum, common_item

define all_prime(l: List[Nat]) -> Bool {
    forall(n: Nat) {
        n ∈ l implies n.is_prime
    }
}

instance Nat: Add {
    let add: (Nat, Nat) -> Nat = Nat.mul

    let 0 = Nat.1
}

let product = sum[Nat] 

// todo: uniqueness
theorem prime_decomposition(n: Nat) {
    1 < n implies exists(l: List[Nat]) {
        all_prime(l) and n = product(l)
    }
} by {
    forall(k: Nat) {
        if true_below(prime_decomposition, k) {
            if k.is_prime {
                let l = List.singleton(k)
                product(l) = k
                forall(m: Nat) {
                    m ∈ l implies m = k
                    k.is_prime
                    m ∈ l implies m.is_prime
                }
                all_prime(l)
                prime_decomposition(k)
            } 
            if k.is_composite {
                k.is_direct_composite
                let (a: Nat, b: Nat) satisfy {
                    (1 < a and a < k) and
                    (1 < b and b < k) and 
                    a * b = k
                }
                prime_decomposition(a)
                prime_decomposition(b)
                let la: List[Nat] satisfy {
                    all_prime(la) and a = product(la)
                }
                let lb: List[Nat] satisfy {
                    all_prime(lb) and b = product(lb)
                }
                let l = la + lb
                forall(x: Nat) {
                    x ∈ la + lb implies x ∈ la or x ∈ lb
                    x ∈ la implies x.is_prime
                    x ∈ lb implies x.is_prime
                    x ∈ l implies x.is_prime
                }
                all_prime(l)
                product(la + lb) = a * b
                product(l) = k
                prime_decomposition(k)
            }
            prime_decomposition(k)
        }
    }
    prime_decomposition(n)
}

from nat.nat_combo import divides_factorial

theorem exists_infinite_primes(n: Nat) {
    exists(p: Nat) {
        p > n and p.is_prime
    }
} by {
    let m: Nat = n.! + 1
    1 < m
    let (p: Nat) satisfy {
        p.is_prime and p.divides(m)
    }
    p > 1
    p != 1
    if p <= n {
        divides_factorial(p, n)
        p.divides(n.!)
        p.divides(n.! + 1)
        not divides_suc(p, n.!)
        false
    }
    not (p <= n)
    p > n
}

// prepare for the defition of rational number
attributes Nat {
    define relative_prime(self, a: Nat) -> Bool {
        forall(l: List[Nat], la: List[Nat]) {
            (all_prime(l) and product(l) = self) and
            (all_prime(la) and product(la) = a) implies
            forall(p: Nat) {
                not common_item(l, la, p)
            }
        }
    }
}

// we need Euclid algorithm and gcd to prove uniqueness of prime_decomposition

structure Pair[T1, T2] {
    first: T1
    second: T2
}

/// Performs one step of the Euclidean algorithm for computing GCD.
/// Takes the pair (a, b) and replaces it with (b, a mod b).
define gcd_step(p: Pair[Nat, Nat]) -> Pair[Nat, Nat] {
    if p.second = 0 {
        p
    } else {
        Pair.new(p.second, p.first.mod(p.second))
    }
}

/// Performs n steps of the Euclidean GCD algorithm.
define gcd_step_n(p: Pair[Nat, Nat], n: Nat) -> Pair[Nat, Nat] {
    match n {
        Nat.0 {
            p
        }
        Nat.suc(pred) {
            gcd_step(gcd_step_n(p, pred))
        }
    }
}

/// True if a predicate is false for all values below n.
define false_below(f: Nat -> Bool, n: Nat) -> Bool { 
    forall(x: Nat) { x < n implies f(x) = false } 
}

theorem all_false_below(f: Nat -> Bool) {
    forall(x: Nat) { false_below(f, x) } implies forall(x: Nat) { not f(x) }
}

/// True if m is the smallest natural number for which the predicate f is true.
define is_min(f: Nat -> Bool, m: Nat) -> Bool {
    f(m) = true and false_below(f, m)
}

// If f is true anywhere (somewhere) on the naturals, it has a min.
theorem has_min(f: Nat -> Bool, n: Nat) {
    f(n) implies exists(m: Nat) { is_min(f, m) }
} by {
    define g(x: Nat) -> Bool { has_min(f, x) }
    strong_induction(g)
    forall(k: Nat) {
        if true_below(g, k) {
            if f(k) {
                if false_below(f, k) {
                    is_min(f, k)
                    has_min(f, k)
                } else {
                    exists(a: Nat) { a < k and f(a) }
                    let a: Nat satisfy { a < k and f(a) } 
                    g(a)
                    has_min(f, a)
                    has_min(f, k)
                }
            } else {
                // vacuous true
                has_min(f, k)
            }
            g(k)
        }
    }
    g(n)
}

// A decreasing_to_zero function strictly decreases until it hits zero.
define decreasing_to_zero(f: Nat -> Nat) -> Bool {
    forall(x: Nat) {
        f(x) = 0 or f(x.suc) < f(x)
    }
}

theorem no_infinite_decreasing(f: Nat -> Nat) {
    exists(x: Nat) { f(x) <= f(x.suc) }
} by {
    if not no_infinite_decreasing(f) {
        forall(x: Nat) {
            not (f(x) <= f(x.suc))
            f(x.suc) < f(x)
        }
        // Intuitively, f(x.suc) < f(x) make the decreasing speed of f >= 1, so, start from f(0), after f(0) steps, we must have f(f(0)) <= 0 hence contradiction.
        let h = function(x: Nat) { x + f(x) <= f(0) }
        Nat.induction(h)
        0 + f(0) <= f(0)
        h(0)
        forall(x: Nat) {
            if h(x) {
                x + f(x) <= f(0)
                not (f(x) <= f(x.suc))
                f(x.suc) < f(x)
                x + f(x.suc) < x + f(x)
                (x + f(x.suc)).suc <= x + f(x)
                x.suc + f(x.suc) <= x + f(x)
                x.suc + f(x.suc) <= f(0)
                h(x.suc)
            }
        }
        forall(x: Nat) {
            h(x)
        }
        h(f(0).suc)
        f(0).suc + f(f(0).suc) <= f(0)
        f(0).suc <= f(0).suc + f(f(0).suc)
        f(0).suc <= f(0)
        false
    }
}

theorem dtz_terminates(f: Nat -> Nat) {
    decreasing_to_zero(f) implies exists(n: Nat) { f(n) = 0 }
} by {
    let (n: Nat) satisfy { f(n) <= f(n.suc) }
    f(n) = 0 or f(n.suc) < f(n)
    f(n) = 0
}

theorem gcd_terminates(p: Pair[Nat, Nat]) {
    exists(n: Nat) { gcd_step_n(p, n).second = 0 }
} by {
    // prove that gcd_step_n(p, x).second decreasing_to_zero
    // use 
    //     gcd_step(p) = Pair.new(p.second, p.first.mod(p.second)) 
    // and 
    //     p.first.mod(p.second) < p.second
    let f = function(x: Nat) { 
        gcd_step_n(p, x).second 
    }
    forall(x: Nat) {
        if f(x) != 0 {
            let q = gcd_step_n(p, x)

            gcd_step_n(p, x.suc) = gcd_step(gcd_step_n(p, x))

            gcd_step_n(p, x.suc) = gcd_step(q)

            f(x.suc) = gcd_step_n(p, x.suc).second

            f(x.suc) = gcd_step(q).second

            q.second != 0

            gcd_step(q) = Pair.new(q.second, q.first.mod(q.second))
            
            q.first.mod(q.second) = gcd_step(q).second
            
            f(x.suc) = q.first.mod(q.second)
            
            f(x.suc) = q.first.mod(f(x))
            
            q.first.mod(f(x)) < f(x)
            
            f(x.suc) < f(x)
        }
    }
    decreasing_to_zero(f)
}

define gcd_termination(p: Pair[Nat, Nat]) -> (Nat -> Bool) {
    function(n: Nat) {
        gcd_step_n(p, n).second = 0
    }
}

let num_gcd_steps(p: Pair[Nat, Nat]) -> n: Nat satisfy {
    is_min(gcd_termination(p), n)
} by {
    exists(k: Nat) { gcd_termination(p, k) }
}

theorem num_gcd_steps_terminates(p: Pair[Nat, Nat]) {
    gcd_step_n(p, num_gcd_steps(p)).second = 0
} by {
    exists(n: Nat) { is_min(gcd_termination(p), n) }
    let f = gcd_termination(p)
    is_min(f, num_gcd_steps(p))
    gcd_termination(p)(num_gcd_steps(p)) = true
}

define gcd_of_pair(p: Pair[Nat, Nat]) -> Nat { gcd_step_n(p, num_gcd_steps(p)).first }

define gcd(a: Nat, b: Nat) -> Nat { gcd_of_pair(Pair.new(a, b)) }

define divides_both(a: Nat, p: Pair[Nat, Nat]) -> Bool {
    a.divides(p.first) and a.divides(p.second)
}

theorem divides_both_step(a: Nat, p: Pair[Nat, Nat]) {
    divides_both(a, p) implies divides_both(a, gcd_step(p))
} by {
    a.divides(p.first)
    a.divides(p.second)
    a.divides(p.first.mod(p.second))
    if p.second = 0 {
        gcd_step(p) = p
        divides_both(a, gcd_step(p))
    } else {
        gcd_step(p) = Pair[Nat, Nat].new(p.second, p.first.mod(p.second))
        divides_both(a, gcd_step(p))
    }
}

theorem divides_gcd_step_n(d: Nat, p: Pair[Nat, Nat], n: Nat) {
    divides_both(d, p) implies divides_both(d, gcd_step_n(p, n))
} by {
    let f = function(x: Nat) { 
        divides_both(d, gcd_step_n(p, x)) 
    }
    divides_both(d, gcd_step_n(p, 0))
    f(0)
    forall(x: Nat) {
        if f(x) {
            divides_both(d, gcd_step_n(p, x))
            divides_both(d, gcd_step(gcd_step_n(p, x)))
            divides_both(d, gcd_step_n(p, x.suc))
            f(x.suc)
        }
    }
    divides_both(d, gcd_step_n(p, n))
}

theorem divides_gcd_of_pair(d: Nat, p: Pair[Nat, Nat]) {
    divides_both(d, p) implies d.divides(gcd_of_pair(p))
} by {
    divides_both(d, gcd_step_n(p, num_gcd_steps(p)))

    d.divides(gcd_step_n(p, num_gcd_steps(p)).first)
}

theorem divides_gcd(d: Nat, a: Nat, b: Nat) {
    d.divides(a) and d.divides(b) implies d.divides(gcd(a, b))
} by {
    d.divides(Pair[Nat, Nat].new(a, b).first)
    d.divides(Pair[Nat, Nat].new(a, b).second)
    divides_both(d, Pair[Nat, Nat].new(a, b))
    divides_gcd_of_pair(d, Pair[Nat, Nat].new(a, b))

    d.divides(gcd_of_pair(Pair[Nat, Nat].new(a, b)))
    d.divides(gcd(a, b))
}

theorem divides_both_unstep(a: Nat, p: Pair[Nat, Nat]) {
    divides_both(a, gcd_step(p)) implies divides_both(a, p)
} by {
    if p.second = 0 {
        p = gcd_step(p)
        divides_both(a, p)
    } else {
        gcd_step(p) = Pair[Nat, Nat].new(p.second, p.first.mod(p.second))
        a.divides(gcd_step(p).first)
        a.divides(p.second)
        a.divides(gcd_step(p).second)
        a.divides(p.first.mod(p.second))
        a.divides(p.first)
        divides_both(a, p)
    }
}

theorem divides_gcd_step_n_converse(d: Nat, p: Pair[Nat, Nat], n: Nat) {
    divides_both(d, gcd_step_n(p, n)) implies divides_both(d, p)
} by {
    let f = function(x: Nat) {
        divides_gcd_step_n_converse(d, p, x)
    }
    Nat.induction(f)
    if divides_both(d, gcd_step_n(p, 0)) {
        divides_both(d, p)
    }
    divides_gcd_step_n_converse(d, p, 0)
    f(0)
    forall(x: Nat) {
        if f(x) {
            if divides_both(d, gcd_step_n(p, x.suc)) {
                gcd_step_n(p, x.suc) = gcd_step(gcd_step_n(p, x))
                divides_both(d, gcd_step_n(p, x))
                divides_both(d, p)
            }
            divides_gcd_step_n_converse(d, p, x.suc)
            f(x.suc)
        }
    }
}

theorem divides_gcd_pair_converse(d: Nat, p: Pair[Nat, Nat]) {
    d.divides(gcd_of_pair(p)) implies divides_both(d, p)
} by {
    gcd_of_pair(p) = gcd_step_n(p, num_gcd_steps(p)).first
    0 = gcd_step_n(p, num_gcd_steps(p)).second
    d.divides(gcd_step_n(p, num_gcd_steps(p)).first)
    d.divides(gcd_step_n(p, num_gcd_steps(p)).second)
    divides_both(d, gcd_step_n(p, num_gcd_steps(p)))
    divides_both(d, p)
}

theorem gcd_divides(d: Nat, a: Nat, b: Nat) {
    d.divides(gcd(a, b)) implies d.divides(a) and d.divides(b)
} by {
    let p = Pair[Nat, Nat].new(a, b)
    p.first = a
    p.second = b
    d.divides(gcd_of_pair(p))
    divides_both(d, p)
    d.divides(p.first)
    d.divides(a)
    d.divides(p.second)
    d.divides(b)
    d.divides(a) and d.divides(b)
}

theorem gcd_divides_both(a: Nat, b: Nat) {
    gcd(a, b).divides(a) and gcd(a, b).divides(b)
} by {
    gcd(a, b).divides(gcd(a, b))
}

theorem gcd_is_gcd(a: Nat, b: Nat, d: Nat) {
    a != 0 and b != 0 and d.divides(a) and d.divides(b) implies d <= gcd(a, b)
} by {
    gcd(a, b) != 0
    d.divides(gcd(a, b))
    d <= gcd(a, b)
}

theorem gcd_nonzero_left(a: Nat, b: Nat) {
    a != 0 or b != 0 implies gcd(a, b) != 0
} by {
    if gcd(a, b) = 0 {
        0.divides(a)
        0.divides(b)
        a = 0 and b = 0
        false
    }
}

theorem gcd_zero_right(a: Nat) { gcd(a, 0) = a } by {
    a.divides(a)
    a.divides(0)
    a.divides(gcd(a, 0))
    gcd(a, 0).divides(a)
}

theorem gcd_zero_left(a: Nat) { gcd(0, a) = a } by {
    gcd(a, 0).divides(0)
    gcd(a, 0).divides(a)
    gcd(a, 0).divides(gcd(0, a))
    a.divides(gcd(a, 0))
    nat_divide.divides_trans(a, gcd(a, 0), gcd(0, a))
    a.divides(gcd(0, a))
    gcd(0, a).divides(a)
}

theorem gcd_comm(a: Nat, b: Nat) { gcd(a, b) = gcd(b, a) } by {
    (
        a.divides(gcd(a, b)) and b.divides(gcd(a, b)) 
        iff 
        b.divides(gcd(a, b)) and a.divides(gcd(a, b))
    )
    gcd(b, a).divides(gcd(a, b))
    gcd(a, b).divides(gcd(b, a))
}

define mod_maintains(f: Nat -> Bool) -> Bool {
    forall(a: Nat, b: Nat) { f(a) and f(b) implies f(a.mod(b)) }
}

theorem mod_maintains_imp_gcd(f: Nat -> Bool, a: Nat, b: Nat) {
    mod_maintains(f) and f(a) and f(b) implies f(gcd(a, b))
} by {
    let p = Pair[Nat, Nat].new(a, b)
    let g = function(n: Nat) {
        f(gcd_step_n(p, n).first) and f(gcd_step_n(p, n).second)
    }
    gcd_step_n(p, 0).first = a
    gcd_step_n(p, 0).second = b
    f(gcd_step_n(p, 0).second)
    f(gcd_step_n(p, 0).first)
    g(0)
    forall(x: Nat) {
        if g(x) {
            gcd_step_n(p, x.suc) = gcd_step(gcd_step_n(p, x))
            f(gcd_step_n(p, x).first)
            f(gcd_step_n(p, x).second)

            if gcd_step_n(p, x).second = 0 {
                gcd_step_n(p, x.suc) = gcd_step_n(p, x)
                f(gcd_step_n(p, x.suc).first)
                f(gcd_step_n(p, x.suc).second)
                g(x.suc)
            } else {
                Pair.new(
                    gcd_step_n(p, x).second,
                    gcd_step_n(p, x).first.mod(gcd_step_n(p, x).second)
                ) = gcd_step(gcd_step_n(p, x))

                gcd_step_n(p, x.suc).first = gcd_step_n(p, x).second
                                
                gcd_step_n(p, x.suc).second = gcd_step_n(p, x).first.mod(gcd_step_n(p, x).second)
                
                f(gcd_step_n(p, x.suc).first)

                f(gcd_step_n(p, x).first.mod(gcd_step_n(p, x).second))
                
                f(gcd_step_n(p, x.suc).second)
                g(x.suc)
            }
        }
    }
    g(num_gcd_steps(p))
    f(gcd_step_n(p, num_gcd_steps(p)).first)
    f(gcd(a, b))
}

theorem gcd_one_right(a: Nat) {
    gcd(a, 1) = 1
}

theorem gcd_one_left(a: Nat) {
    gcd(1, a) = 1
}

theorem gcd_mul_left_nonzero(a: Nat, b: Nat, m: Nat) {
    m != 0 implies m * gcd(a, b) = gcd(m * a, m * b)
} by {
    m.divides(m * a)
    m.divides(m * b)
    m.divides(gcd(m * a, m * b))
    let d: Nat satisfy {
        m * d = gcd(m * a, m * b)
    }

    // Overall we will prove equality by proving both sides divide the other.
    // First we prove that d equals gcd(a, b), to prove that right divides left.
    (m * d).divides(m * a)
    d.divides(a)
    (m * d).divides(m * b)
    d.divides(b)
    d.divides(gcd(a, b))
    (m * d).divides(m * gcd(a, b))
    gcd(m * a, m * b).divides(m * gcd(a, b))

    // Now we prove left divides right.
    (m * gcd(a, b)).divides(m * a)
    (m * gcd(a, b)).divides(m * b)
    (m * gcd(a, b)).divides(gcd(m * a, m * b))
}

theorem gcd_mul_left(a: Nat, b: Nat, m: Nat) {
    m * gcd(a, b) = gcd(m * a, m * b)
} by {
    if m = 0 {
        m * gcd(a, b) = 0
        gcd(m * a, m * b) = 0
    } else {
        m * gcd(a, b) = gcd(m * a, m * b)
    }
}

theorem gcd_mul_right(a: Nat, b: Nat, m: Nat) {
    gcd(a, b) * m = gcd(a * m, b * m)
} by {
    gcd_mul_left(a, b, m)
    gcd_comm(a, b)
    gcd_comm(m * a, m * b)
}

theorem cofactor(a: Nat, b: Nat, af: Nat, bf: Nat) {
    (
        gcd(a, b) != 0 and
        af * gcd(a, b) = a and
        bf * gcd(a, b) = b
    ) implies gcd(af, bf) = 1
} by {
    gcd(af, bf).divides(af)
    (gcd(a, b) * gcd(af, bf)).divides(a)
    gcd(af, bf).divides(bf)
    (gcd(a, b) * gcd(af, bf)).divides(b)
    (gcd(a, b) * gcd(af, bf)).divides(gcd(a, b))
    (gcd(a, b) * gcd(af, bf)).divides(gcd(a, b) * 1)
    gcd(af, bf).divides(1)
    gcd(af, bf) = 1
}

theorem gcd_of_prime(p: Nat, n: Nat) {
    p.is_prime implies gcd(p, n) = 1 or p.divides(n)
} by {
    gcd(p, n).divides(p)
    let d: Nat satisfy {
        d * gcd(p, n) = p
    }
    d != 0
    if d = 1 {
        gcd(p, n) = p
        p.divides(n)
    } else {
        if gcd(p, n) > 1 {
            d > 1
            p.is_composite
            false
        }
        gcd(p, n) != 0
        gcd(p, n) = 1
    }
}

theorem euclids_lemma_prime(a: Nat, b: Nat, c: Nat) {
    a.is_prime and a.divides(b * c) implies a.divides(b) or a.divides(c)
} by {
    if not a.divides(b) {
        gcd(a, b) = 1
        gcd(a * c, b * c) = gcd(a, b) * c
        gcd(a * c, b * c) = c
        a.divides(a * c)
        a.divides(b * c)
        a.divides(gcd(a * c, b * c))
        a.divides(c)
    }
}

theorem divides_prime(a: Nat, b: Nat) {
    a.is_prime and b.is_prime and a.divides(b) implies a = b 
} by {
    a <= b
    not (1 < a and a < b)
    a = b    
}

theorem euclids_lemma_divides_primes(a: Nat, b: Nat, c: Nat) {
    a.is_prime and b.is_prime and c.is_prime and a.divides(b * c) implies a = b or a = c
} 

theorem all_prime_decomposition(head: Nat, tail: List[Nat]) {
    all_prime(List.cons(head, tail)) iff head.is_prime and all_prime(tail)
} by {
    if all_prime(List.cons(head, tail)) {
        head.is_prime
        forall(x: Nat) {
            x ∈ tail implies x ∈ List.cons(head, tail)
            x ∈ tail implies x.is_prime
        }
        all_prime(tail)
    }
    if head.is_prime and all_prime(tail) {
        forall(x: Nat) {
            x ∈ List.cons(head, tail) implies x = head or x ∈ tail
            x ∈ List.cons(head, tail) implies x.is_prime
        }
        all_prime(List.cons(head, tail))
    }
}

theorem euclids_lemma_prime_divides_list(a: Nat, l: List[Nat]) {
    a.is_prime and a.divides(product(l)) implies exists(b: Nat) {
        b ∈ l and a.divides(b)
    } 
} by {
    define f(ps: List[Nat]) -> Bool {
        euclids_lemma_prime_divides_list(a, ps)
    }
    product(List[Nat].nil) = 1
    not a.divides(1)
    f(List[Nat].nil)

    forall(head: Nat, tail: List[Nat]) {
        product(List.cons(head, tail)) = head * product(tail)
        if f(tail) {
            if a.divides(product(List.cons(head, tail))) {
                a.divides(head) or a.divides(product(tail))
                if a.divides(head) { 
                    exists(b: Nat) {
                        b ∈ List.cons(head, tail) and a.divides(b)
                    }
                } else {
                    a.divides(product(tail))
                    let (n: Nat) satisfy {
                        n ∈ tail and a.divides(n)
                    }
                    n ∈ List.cons(head, tail) and a.divides(n)
                    exists(b: Nat) {
                        b ∈ List.cons(head, tail) and a.divides(b)
                    }
                }
                exists(b: Nat) {
                    b ∈ List.cons(head, tail) and a.divides(b)
                }
                f(List.cons(head, tail))
            } else {
                euclids_lemma_prime_divides_list(a, List.cons(head, tail))

                f(List.cons(head, tail))
            }
            f(List.cons(head, tail))
        }
    }
    f(l)
}

theorem euclids_lemma_prime_divides_prime_list(a: Nat, l: List[Nat]) {
    a.is_prime and all_prime(l) and a.divides(product(l)) implies exists(p: Nat) {
        p ∈ l and a = p
    } 
} by {
    let (p: Nat) satisfy {
        p ∈ l and a.divides(p)
    } 
    a = p
}

theorem remove_product(x: Nat, l: List[Nat]) {
    x^(l.count(x)) * product(l ∖ x) = product(l)
} by {
    define f(ns: List[Nat]) -> Bool {
        x^(ns.count(x)) * product(ns ∖ x) = product(ns)
    }
    f(List[Nat].nil)
    forall(head: Nat, tail: List[Nat]) {
        product(List.cons(head, tail)) = head * product(tail)        
        if f(tail) {
            if x ∈ List.cons(head, tail) {
                if head = x {
                    List.cons(head, tail) ∖ x = tail ∖ x

                    List.cons(head, tail).count(x) = 1 + tail.count(x)

                    x^(List.cons(head, tail).count(x)) = x * x^(tail.count(x))

                    x^(tail.count(x)) * product(tail ∖ x) = product(tail)

                    x * x^(tail.count(x)) * product(List.cons(head, tail) ∖ x) = x * product(tail)

                    x^(List.cons(head, tail).count(x)) * product(List.cons(head, tail) ∖ x) = product(List.cons(head, tail))

                    f(List.cons(head, tail))
                } else {
                    x != head
                    x ∈ tail

                    List.cons(head, tail).count(x) = tail.count(x)
                    
                    List.cons(head, tail) ∖ x = List.cons(head, tail ∖ x)

                    product(List.cons(head, tail) ∖ x) = head * product(tail ∖
                     x)

                    x^(tail.count(x)) * product(tail ∖ x) = product(tail)

                    product(List.cons(head, tail)) = head * x^(tail.count(x)) * product(tail ∖ x)

                    product(List.cons(head, tail)) = head * x^(List.cons(head, tail).count(x)) * product(tail ∖ x)

                    product(List.cons(head, tail)) = x^(List.cons(head, tail).count(x)) * product(List.cons(head, tail) ∖ x)

                    f(List.cons(head, tail))
                }
            } else {
                x ∉ List.cons(head, tail)
                List.cons(head, tail).count(x) = 0
                List.cons(head, tail) ∖ x = List.cons(head, tail)
                x^(List.cons(head, tail).count(x)) * product(List.cons(head, tail) ∖ x) = product(List.cons(head, tail))
                f(List.cons(head, tail))
            }
        }
    }
    f(l)
}

theorem divides_iff_contains(x: Nat, l: List[Nat], q: Nat) {
    x.is_prime and x.divides(product(l)) and all_prime(l) implies l.count(x) != 0
} 

theorem remove_preserve_all_prime(x: Nat, l: List[Nat]) {
    all_prime(l) and x.is_prime implies all_prime(l ∖ x)
} by {
    forall(n: Nat) {
        n ∈ l ∖ x implies n ∈ l
        n ∈ l ∖ x implies n.is_prime
    }
}

theorem prime_list_same_count_prime_half(x: Nat, l1: List[Nat], l2: List[Nat]) {
    x.is_prime and 
    all_prime(l1) and all_prime(l2) and
    product(l1) = product(l2) 
    implies l1.count(x) >= l2.count(x)
} by {
    x^(l1.count(x)) * product(l1 ∖ x) = product(l1)
    x^(l2.count(x)) * product(l2 ∖ x) = product(l2)
    if l1.count(x) < l2.count(x) {
        let n: Nat satisfy {
            l1.count(x) + n = l2.count(x) and n != 0
        }
        x^(l2.count(x)) = x^(l1.count(x)) * x^n

        x^(l1.count(x)) * product(l1 ∖ x) = x^(l1.count(x)) * (x^n * product(l2 ∖ x))

        x^(l1.count(x)) != 0

        product(l1 ∖ x) = x^n * product(l2 ∖ x)

        1 <= n

        product(l1 ∖ x) = x * x^(n - 1) * product(l2 ∖ x)

        x.is_prime
        all_prime(l1 ∖ x)

        x.divides(product(l1 ∖ x))

        (l1 ∖ x).count(x) != 0

        false
    }
}

theorem prime_list_same_count_prime(x: Nat, l1: List[Nat], l2: List[Nat]) {
    x.is_prime and 
    all_prime(l1) and all_prime(l2) and
    product(l1) = product(l2) 
    implies l1.count(x) = l2.count(x)
} by {
    l1.count(x) >= l2.count(x)
    l2.count(x) >= l1.count(x)
}

theorem composite_not_divides_prime(a: Nat, p: Nat) {
    a.is_composite and p.is_prime implies not a.divides(p)
} by {
    if a.divides(p) {
        let (b: Nat, c: Nat, n: Nat) satisfy { 
            a = b * c and
            (1 < b and b < a) and 
            (1 < c and c < a) and
            a * n = p
        }
        b * (c * n) = p
        b < p
        b.proper_divides(p)
        not p.is_prime
        false
    }
}

theorem not_prime_not_in_prime_list(n: Nat, l: List[Nat]) {
    not n.is_prime and all_prime(l) implies l.count(n) = 0
} by {
    if n <= 1 {
        l.count(n) = 0
    } else {
        1 < n
        n.is_composite
        l.count(n) = 0
    }
}

theorem prime_decomposition_uniqueness(n: Nat, l1: List[Nat], l2: List[Nat]) {
    1 < n and
    all_prime(l1) and n = product(l1) and
    all_prime(l2) and n = product(l2) implies 
    l1.is_permutation(l2)
} by {
    forall(x: Nat) {
        x.is_prime implies l1.count(x) = l2.count(x)
        not x.is_prime implies l1.count(x) = l2.count(x)
    }
}

theorem non_nil_prime_list_product_gt_1(l: List[Nat]) {
    l != List[Nat].nil and all_prime(l) implies 1 < product(l)
} by {
    define f(ps: List[Nat]) -> Bool {
        non_nil_prime_list_product_gt_1(ps)
    }
    f(List[Nat].nil)
    forall(head: Nat, tail: List[Nat]) {
        if f(tail) {
            if all_prime(List.cons(head, tail)) {
                if tail = List[Nat].nil {
                    product(List.cons(head, tail)) = head
                    head.is_prime
                    1 < head
                    1 < product(List.cons(head, tail))
                } else {
                    1 < product(tail)
                    head.is_prime
                    1 < head
                    product(List.cons(head, tail)) = head * product(tail)
                    1 < product(List.cons(head, tail))
                }
                1 < product(List.cons(head, tail))
            }
            f(List.cons(head, tail))
        }
    }
    f(l)
}

attributes Nat {
    define have_prime_decomposition(self, l: List[Nat]) -> Bool {
        1 < self and all_prime(l) and self = product(l)
    }
}

theorem prime_have_singleton_prime_decomposition(x: Nat, l: List[Nat]) {
    x.is_prime and x.have_prime_decomposition(l) implies l = List.singleton(x)
} by {
    not x.have_prime_decomposition(List[Nat].nil)
    prime_have_singleton_prime_decomposition(x, List[Nat].nil)
    
    forall(head: Nat, tail: List[Nat]) {
        if all_prime(List.cons(head, tail)) and 
        x.have_prime_decomposition(List.cons(head, tail)) {
            if tail != List[Nat].nil {
                1 < head
                1 < product(tail)
                product(List.cons(head, tail)) = head * product(tail)
                not x.is_prime
                false
            } else {
                tail = List[Nat].nil
                List.cons(head, tail) = List.singleton(head)
                x = product(List.cons(head, tail))
                x = head
            }
            List.cons(head, tail) = List.singleton(x)
        }
    }

    List.induction(function (xs: List[Nat]) {
        prime_have_singleton_prime_decomposition(x, xs)
    })

    l = List.singleton(x)
}