from nat.nat_divide import ℕ, divides_suc, divides_trans
from nat.nat_base import true_below, strong_induction
from list.list_mul import List, Mul, product

numerals ℕ

attributes ℕ {
    // A number is composite if it has a proper divisor (i.e., a nontrivial factor)
    define is_composite(self) -> Bool {
        exists(a: ℕ) {
            a.proper_divides(self)
        }
    }

    // A number is prime if it's greater than 1 and has no proper divisors
    // In other words, its only divisors are 1 and itself
    define is_prime(self) -> Bool {
        forall(a: ℕ) {
            self > 1 and not a.proper_divides(self)
        }
    }
}

attributes ℕ {
    // A number is directly composite if it can be written as product of two nontrivial factors
    // Both factors must be strictly between 1 and the number itself
    define is_direct_composite(self) -> Bool {
        exists(a: ℕ, b: ℕ) {
            (1 < a and a < self) and
            (1 < b and b < self) and
            a * b = self
        }
    }

    // A number is normally composite if it can be factored with both factors > 1
    // This is equivalent to is_direct_composite but doesn't require factors < n
    define is_normal_composite(self) -> Bool {
        exists(a: ℕ, b: ℕ) {
            (1 < a) and
            (1 < b) and
            a * b = self
        }
    }
}

// n is composite iff n is directly composite
// Direct composite explicitly requires both factors to be between 1 and n
theorem composite_is_direct_composite(n: ℕ) {
    n.is_composite iff n.is_direct_composite
} by {
    // Forward direction: if n is composite, then n is directly composite
    if n.is_composite {
        let a: ℕ satisfy { a.proper_divides(n) }
        let b: ℕ satisfy { a * b = n }
        // If a is a proper divisor, then b is also a proper divisor
        b.proper_divides(n)
        // Both a and b are strictly between 1 and n
        (
            (1 < a and a < n) and
            (1 < b and b < n) and
            a * b = n
        )
        n.is_direct_composite
    }

    // Reverse direction: if n is directly composite, then n has a proper divisor
    n.is_direct_composite implies n.is_composite
}

// n is normally composite iff n is directly composite
// They are equivalent because if a,b > 1 and a*b = n, then automatically a,b < n
theorem normal_composite_is_direct_composite(n: ℕ) {
    n.is_normal_composite iff n.is_direct_composite
} by {
    // Forward direction: direct composite requires a,b < n, so they satisfy normal composite
    n.is_direct_composite implies n.is_normal_composite

    // Reverse direction: if a,b > 1 and a*b = n, prove a,b < n
    if n.is_normal_composite {
        let (a: ℕ, b: ℕ) satisfy {
            (1 < a) and
            (1 < b) and
            a * b = n
        }
        // Show that a,b can't be 0, 1, or n (contradiction in each case)
        a != 0
        b != 0
        a <= n
        b <= n
        a != 1
        b != 1
        a != n
        b != n
        // Therefore a,b < n
        a < n
        b < n

        n.is_direct_composite
    }
}

theorem composite_is_normal_composite(n: ℕ) {
    n.is_composite iff n.is_normal_composite
}

// n is prime iff n > 1 and n is not composite
// Prime numbers have no proper divisors
theorem composite_is_not_prime(n: ℕ) {
    n.is_prime iff n > 1 and not n.is_composite
} by {
    // If n is prime (n > 1 with no proper divisors), then n is not composite
    n.is_prime implies not n.is_composite
}

// n is not prime iff n <= 1 or n is composite
// This characterizes all non-prime numbers: 0, 1, and composites
theorem not_prime_iff_lte_one_or_composite(n: ℕ) {
    not n.is_prime iff n <= 1 or n.is_composite
} by {
    // If n is not prime, then either n <= 1 or n > 1 and has a proper divisor
    not n.is_prime implies n <= 1 or n.is_composite
    // If n <= 1 or n is composite, then n is not prime
    n <= 1 or n.is_composite implies not n.is_prime
}

// Every number n > 1 has at least one prime divisor
// Proof by strong induction: if n is prime, done; if composite, any proper divisor has a prime divisor
theorem has_prime_divisor(n: ℕ) {
    1 < n implies exists(p: ℕ) {
        p.is_prime and p.divides(n)
    }
} by {
    // Strong induction on k: assume property holds for all values below k
    forall(k: ℕ) {
        if true_below(has_prime_divisor, k) {
            // Case 1: k is prime - then k itself is a prime divisor
            if k.is_prime {
                // k itself is a prime divisor of k
                k.divides(k)
                has_prime_divisor(k)
            }
            // Case 2: k is composite
            if k.is_composite {
                // k = b*c with 1 < b,c < k
                k.is_direct_composite
                let (b: ℕ, c: ℕ) satisfy {
                    1 < b and b < k and k = b * c
                }
                // By induction hypothesis, b has a prime divisor p
                has_prime_divisor(b)
                let (p: ℕ) satisfy {
                    p.is_prime and p.divides(b)
                }
                // Since p divides b and b divides k, p divides k by transitivity
                p.divides(k)
                has_prime_divisor(k)
            }
            has_prime_divisor(k)
        }
    }
    has_prime_divisor(n)
}

// A list consists entirely of primes
define are_primes(l: List[ℕ]) -> Bool {
    forall(n: ℕ) {
        n ∈ l implies n.is_prime
    }
}

// Empty list trivially consists of primes
theorem nil_list_are_primes {
    are_primes(List[ℕ].nil)
}

// Make ℕ an instance of Mul to use product function
instance ℕ: Mul {
    let mul: (ℕ, ℕ) -> ℕ = ℕ.mul

    let 1 = ℕ.1
}

// Prime factorization theorem: every n != 0 can be factored into primes
// The list l contains only primes and their product equals n
theorem prime_decomposition(n: ℕ) {
    n != 0 implies exists(l: List[ℕ]) {
        are_primes(l) and n = product(l)
    }
} by {
    // Induction on k using true_below (strong induction principle)
    forall(k: ℕ) {
        if true_below(prime_decomposition, k) {
            // Case k = 0: vacuously true (antecedent false)
            if k = 0 { prime_decomposition(k) }
            // Base case: 1 = product(empty list)
            if k = 1 {
                are_primes(List[ℕ].nil)
                1 = product(List[ℕ].nil)

                prime_decomposition(k)
            }
            // If k is prime, then [k] is its prime factorization
            if k.is_prime {
                let l = List.singleton(k)
                product(l) = k
                forall(m: ℕ) {
                    m ∈ l implies m = k
                    k.is_prime
                    m ∈ l implies m.is_prime
                }
                are_primes(l)
                prime_decomposition(k)
            }
            // If k is composite, factor it as a*b and use induction on a and b
            if k.is_composite {
                k.is_direct_composite
                let (a: ℕ, b: ℕ) satisfy {
                    (1 < a and a < k) and
                    (1 < b and b < k) and
                    a * b = k
                }
                // By induction, a and b have prime factorizations
                prime_decomposition(a)
                prime_decomposition(b)
                a != 0
                b != 0
                let la: List[ℕ] satisfy {
                    are_primes(la) and a = product(la)
                }
                let lb: List[ℕ] satisfy {
                    are_primes(lb) and b = product(lb)
                }
                // Concatenate the two lists to get factorization of k
                let l = la + lb
                forall(x: ℕ) {
                    x ∈ la + lb implies x ∈ la or x ∈ lb
                    x ∈ la implies x.is_prime
                    x ∈ lb implies x.is_prime
                    x ∈ l implies x.is_prime
                }
                are_primes(l)
                // product of concatenated lists = product of factors
                product(la + lb) = a * b
                product(l) = k
                prime_decomposition(k)
            }
            prime_decomposition(k)
        }
    }
    prime_decomposition(n)
}

from nat.nat_combo import divides_factorial

// Euclid's theorem: there are infinitely many primes
// For any n, there exists a prime p > n
theorem exists_infinite_primes(n: ℕ) {
    exists(p: ℕ) {
        p > n and p.is_prime
    }
} by {
    // Consider m = n! + 1, which is > 1
    let m: ℕ = n.! + 1
    1 < m
    // By has_prime_divisor, m has a prime divisor p
    let (p: ℕ) satisfy {
        p.is_prime and p.divides(m)
    }
    p > 1
    p != 1
    // Prove p > n by contradiction: if p <= n, then p divides n! and n!+1, impossible
    if p <= n {
        divides_factorial(p, n)
        p.divides(n.!)
        p.divides(n.! + 1)
        // But a number cannot divide both x and x+1 (unless it's 1)
        not divides_suc(p, n.!)
        false
    }
    not (p <= n)
    p > n
}

// We need Euclid algorithm and gcd to prove uniqueness of prime_decomposition. More explicitly, to prove
// theorem euclids_lemma_prime(a: ℕ, b: ℕ, c: ℕ) {
//     a.is_prime and a.divides(b * c) implies a.divides(b) or a.divides(c)
// }
// Anyway we need induction to prove this, and Euclid algorithm is one way to implement inductive proof.

// A pair structure for Euclidean algorithm state
structure Pair[T1, T2] {
    first: T1
    second: T2
}

/// Performs one step of Euclidean algorithm for computing GCD.
/// Takes pair (a, b) and replaces it with (b, a mod b).
define gcd_step(p: Pair[ℕ, ℕ]) -> Pair[ℕ, ℕ] {
    if p.second = 0 {
        p
    } else {
        Pair.new(p.second, p.first.mod(p.second))
    }
}

/// Performs n steps of the Euclidean GCD algorithm.
define gcd_step_n(p: Pair[ℕ, ℕ], n: ℕ) -> Pair[ℕ, ℕ] {
    match n {
        ℕ.0 {
            p
        }
        ℕ.suc(pred) {
            gcd_step(gcd_step_n(p, pred))
        }
    }
}

/// True if a predicate is false for all values below n.
define false_below(f: ℕ -> Bool, n: ℕ) -> Bool {
    forall(x: ℕ) { x < n implies f(x) = false }
}

theorem all_false_below(f: ℕ -> Bool) {
    forall(x: ℕ) { false_below(f, x) } implies forall(x: ℕ) { not f(x) }
}

/// True if m is the smallest natural number for which the predicate f is true.
define is_min(f: ℕ -> Bool, m: ℕ) -> Bool {
    f(m) = true and false_below(f, m)
}

// If f is true anywhere (somewhere) on the naturals, it has a min.
theorem has_min(f: ℕ -> Bool, n: ℕ) {
    f(n) implies exists(m: ℕ) { is_min(f, m) }
} by {
    // Strong induction: prove that if f is true at k, it has a minimum
    define g(x: ℕ) -> Bool { has_min(f, x) }
    strong_induction(g)
    forall(k: ℕ) {
        if true_below(g, k) {
            if f(k) {
                // If f is false everywhere below k, then k is the minimum
                if false_below(f, k) {
                    is_min(f, k)
                    has_min(f, k)
                } else {
                    // Otherwise, there's some a < k where f(a) holds
                    exists(a: ℕ) { a < k and f(a) }
                    let a: ℕ satisfy { a < k and f(a) }
                    // By induction, f has a minimum at a
                    g(a)
                    has_min(f, a)
                    has_min(f, k)
                }
            } else {
                // vacuous true: if f(k) is false, nothing to prove
                has_min(f, k)
            }
            g(k)
        }
    }
    g(n)
}

// A decreasing_to_zero function strictly decreases until it hits zero.
define decreasing_to_zero(f: ℕ -> ℕ) -> Bool {
    forall(x: ℕ) {
        f(x) = 0 or f(x.suc) < f(x)
    }
}

theorem no_infinite_decreasing(f: ℕ -> ℕ) {
    exists(x: ℕ) { f(x) <= f(x.suc) }
} by {
    // Proof by contradiction: assume f decreases everywhere
    if not no_infinite_decreasing(f) {
        forall(x: ℕ) {
            not (f(x) <= f(x.suc))
            f(x.suc) < f(x)
        }
        // Intuitively, f(x.suc) < f(x) makes the decreasing speed of f >= 1,
        // so, start from f(0), after f(0) steps, we must have f(f(0)) <= 0 hence contradiction.
        let h = function(x: ℕ) { x + f(x) <= f(0) }
        ℕ.induction(h)
        0 + f(0) <= f(0)
        h(0)
        // Inductive step: prove that if x + f(x) <= f(0), then (x+1) + f(x+1) <= f(0)
        forall(x: ℕ) {
            if h(x) {
                x + f(x) <= f(0)
                not (f(x) <= f(x.suc))
                f(x.suc) < f(x)
                x + f(x.suc) < x + f(x)
                (x + f(x.suc)).suc <= x + f(x)
                x.suc + f(x.suc) <= x + f(x)
                x.suc + f(x.suc) <= f(0)
                h(x.suc)
            }
        }
        forall(x: ℕ) {
            h(x)
        }
        // Plug in x = f(0) to get contradiction
        h(f(0).suc)
        f(0).suc + f(f(0).suc) <= f(0)
        f(0).suc <= f(0).suc + f(f(0).suc)
        f(0).suc <= f(0)
        false
    }
}

theorem dtz_terminates(f: ℕ -> ℕ) {
    decreasing_to_zero(f) implies exists(n: ℕ) { f(n) = 0 }
} by {
    // By no_infinite_decreasing, there exists n where f(n) <= f(n.suc)
    let (n: ℕ) satisfy { f(n) <= f(n.suc) }
    // Since f decreases everywhere, f(n) must be 0 (can't be f(n.suc) < f(n))
    f(n) = 0 or f(n.suc) < f(n)
    f(n) = 0
}

theorem gcd_terminates(p: Pair[ℕ, ℕ]) {
    exists(n: ℕ) { gcd_step_n(p, n).second = 0 }
} by {
    // Prove that gcd_step_n(p, x).second is decreasing_to_zero
    // Use:
    //     gcd_step(p) = Pair.new(p.second, p.first.mod(p.second))
    // and
    //     p.first.mod(p.second) < p.second (when second != 0)
    let f = function(x: ℕ) {
        gcd_step_n(p, x).second
    }
    // Show that if f(x) != 0, then f(x.suc) < f(x)
    forall(x: ℕ) {
        if f(x) != 0 {
            let q = gcd_step_n(p, x)

            gcd_step_n(p, x.suc) = gcd_step(gcd_step_n(p, x))

            gcd_step_n(p, x.suc) = gcd_step(q)

            f(x.suc) = gcd_step_n(p, x.suc).second

            f(x.suc) = gcd_step(q).second

            q.second != 0

            gcd_step(q) = Pair.new(q.second, q.first.mod(q.second))

            q.first.mod(q.second) = gcd_step(q).second

            f(x.suc) = q.first.mod(q.second)

            f(x.suc) = q.first.mod(f(x))

            // Property of mod: remainder < divisor
            q.first.mod(f(x)) < f(x)

            f(x.suc) < f(x)
        }
    }
    decreasing_to_zero(f)
}

// Predicate that is true when gcd_step_n reaches zero (remainder = 0)
define gcd_termination(p: Pair[ℕ, ℕ]) -> (ℕ -> Bool) {
    function(n: ℕ) {
        gcd_step_n(p, n).second = 0
    }
}

// Number of steps needed for Euclidean algorithm to terminate
let num_gcd_steps(p: Pair[ℕ, ℕ]) -> n: ℕ satisfy {
    is_min(gcd_termination(p), n)
} by {
    exists(k: ℕ) { gcd_termination(p, k) }
}

// The computed number of steps indeed makes the remainder zero
theorem num_gcd_steps_terminates(p: Pair[ℕ, ℕ]) {
    gcd_step_n(p, num_gcd_steps(p)).second = 0
} by {
    exists(n: ℕ) { is_min(gcd_termination(p), n) }
    let f = gcd_termination(p)
    is_min(f, num_gcd_steps(p))
    gcd_termination(p)(num_gcd_steps(p)) = true
}

// The GCD is the first component of the pair when algorithm terminates
define gcd_of_pair(p: Pair[ℕ, ℕ]) -> ℕ { gcd_step_n(p, num_gcd_steps(p)).first }

// GCD of two numbers a and b
define gcd(a: ℕ, b: ℕ) -> ℕ { gcd_of_pair(Pair.new(a, b)) }

// Helper: a divides both components of a pair
define divides_both(a: ℕ, p: Pair[ℕ, ℕ]) -> Bool {
    a.divides(p.first) and a.divides(p.second)
}

// If a divides both numbers, it divides the result after one Euclidean step
theorem divides_both_step(a: ℕ, p: Pair[ℕ, ℕ]) {
    divides_both(a, p) implies divides_both(a, gcd_step(p))
} by {
    // a divides p.first and p.second
    a.divides(p.first)
    a.divides(p.second)
    // a also divides p.first mod p.second (remainder of division)
    a.divides(p.first.mod(p.second))
    // Case analysis: if remainder is 0, gcd_step returns p unchanged
    if p.second = 0 {
        gcd_step(p) = p
        divides_both(a, gcd_step(p))
    } else {
        // Otherwise, gcd_step swaps and computes remainder
        gcd_step(p) = Pair[ℕ, ℕ].new(p.second, p.first.mod(p.second))
        divides_both(a, gcd_step(p))
    }
}

// If d divides both numbers, it divides both after any number of Euclidean steps
theorem divides_gcd_step_n(d: ℕ, p: Pair[ℕ, ℕ], n: ℕ) {
    divides_both(d, p) implies divides_both(d, gcd_step_n(p, n))
} by {
    // Induction on n
    let f = function(x: ℕ) {
        divides_both(d, gcd_step_n(p, x))
    }
    divides_both(d, gcd_step_n(p, 0))
    f(0)
    // Inductive step: if property holds for x, it holds for x+1
    forall(x: ℕ) {
        if f(x) {
            divides_both(d, gcd_step_n(p, x))
            divides_both(d, gcd_step(gcd_step_n(p, x)))
            divides_both(d, gcd_step_n(p, x.suc))
            f(x.suc)
        }
    }
    divides_both(d, gcd_step_n(p, n))
}

// If d divides both numbers, then d divides their GCD
theorem divides_gcd_of_pair(d: ℕ, p: Pair[ℕ, ℕ]) {
    divides_both(d, p) implies d.divides(gcd_of_pair(p))
} by {
    // After num_gcd_steps steps, d still divides both components
    divides_both(d, gcd_step_n(p, num_gcd_steps(p)))

    // The GCD is the first component at termination
    d.divides(gcd_step_n(p, num_gcd_steps(p)).first)
}

// If d divides a and b, then d divides gcd(a,b)
theorem divides_gcd(d: ℕ, a: ℕ, b: ℕ) {
    d.divides(a) and d.divides(b) implies d.divides(gcd(a, b))
} by {
    d.divides(Pair[ℕ, ℕ].new(a, b).first)
    d.divides(Pair[ℕ, ℕ].new(a, b).second)
    divides_both(d, Pair[ℕ, ℕ].new(a, b))
    divides_gcd_of_pair(d, Pair[ℕ, ℕ].new(a, b))

    d.divides(gcd_of_pair(Pair[ℕ, ℕ].new(a, b)))
    d.divides(gcd(a, b))
}

// Converse: if a divides both after one step, it divides both before
theorem divides_both_unstep(a: ℕ, p: Pair[ℕ, ℕ]) {
    divides_both(a, gcd_step(p)) implies divides_both(a, p)
} by {
    if p.second = 0 {
        // If remainder is already 0, gcd_step does nothing
        p = gcd_step(p)
        divides_both(a, p)
    } else {
        // Otherwise, gcd_step swapped the numbers
        gcd_step(p) = Pair[ℕ, ℕ].new(p.second, p.first.mod(p.second))
        a.divides(gcd_step(p).first)
        a.divides(p.second)
        a.divides(gcd_step(p).second)
        a.divides(p.first.mod(p.second))
        a.divides(p.first)
        divides_both(a, p)
    }
}

theorem divides_gcd_step_n_converse(d: ℕ, p: Pair[ℕ, ℕ], n: ℕ) {
    divides_both(d, gcd_step_n(p, n)) implies divides_both(d, p)
} by {
    let f = function(x: ℕ) {
        divides_gcd_step_n_converse(d, p, x)
    }
    ℕ.induction(f)
    if divides_both(d, gcd_step_n(p, 0)) {
        divides_both(d, p)
    }
    divides_gcd_step_n_converse(d, p, 0)
    f(0)
    forall(x: ℕ) {
        if f(x) {
            if divides_both(d, gcd_step_n(p, x.suc)) {
                gcd_step_n(p, x.suc) = gcd_step(gcd_step_n(p, x))
                divides_both(d, gcd_step_n(p, x))
                divides_both(d, p)
            }
            divides_gcd_step_n_converse(d, p, x.suc)
            f(x.suc)
        }
    }
}

theorem divides_gcd_pair_converse(d: ℕ, p: Pair[ℕ, ℕ]) {
    d.divides(gcd_of_pair(p)) implies divides_both(d, p)
} by {
    gcd_of_pair(p) = gcd_step_n(p, num_gcd_steps(p)).first
    0 = gcd_step_n(p, num_gcd_steps(p)).second
    d.divides(gcd_step_n(p, num_gcd_steps(p)).first)
    d.divides(gcd_step_n(p, num_gcd_steps(p)).second)
    divides_both(d, gcd_step_n(p, num_gcd_steps(p)))
    divides_both(d, p)
}

// Converse: if d divides gcd(a,b), then d divides a and b
theorem gcd_divides(d: ℕ, a: ℕ, b: ℕ) {
    d.divides(gcd(a, b)) implies d.divides(a) and d.divides(b)
} by {
    let p = Pair[ℕ, ℕ].new(a, b)
    p.first = a
    p.second = b
    d.divides(gcd_of_pair(p))
    divides_both(d, p)
    d.divides(p.first)
    d.divides(a)
    d.divides(p.second)
    d.divides(b)
    d.divides(a) and d.divides(b)
}

// GCD divides both arguments
theorem gcd_divides_both(a: ℕ, b: ℕ) {
    gcd(a, b).divides(a) and gcd(a, b).divides(b)
} by {
    // Since gcd divides itself, and we've shown divides(gcd(a,b), gcd(a,b))
    // implies divides(gcd(a,b), a) and divides(gcd(a,b), b)
    gcd(a, b).divides(gcd(a, b))
}

// The GCD is the greatest common divisor: any common divisor is <= GCD
theorem gcd_is_gcd(a: ℕ, b: ℕ, d: ℕ) {
    a != 0 and b != 0 and d.divides(a) and d.divides(b) implies d <= gcd(a, b)
} by {
    // GCD is non-zero when a and b are non-zero
    gcd(a, b) != 0
    // Any common divisor divides the GCD
    d.divides(gcd(a, b))
    // If d divides a non-zero number, d <= that number
    d <= gcd(a, b)
}

// GCD is non-zero when at least one argument is non-zero
theorem gcd_nonzero_left(a: ℕ, b: ℕ) {
    a != 0 or b != 0 implies gcd(a, b) != 0
} by {
    // Proof by contradiction: if GCD = 0, then both a and b must be 0
    if gcd(a, b) = 0 {
        0.divides(a)
        0.divides(b)
        a = 0 and b = 0
        false
    }
}

theorem gcd_zero_right(a: ℕ) { gcd(a, 0) = a } by {
    // a divides both a and 0, so a divides gcd(a, 0)
    a.divides(a)
    a.divides(0)
    a.divides(gcd(a, 0))
    // gcd(a, 0) divides a, so they're equal (gcd divides both arguments)
    gcd(a, 0).divides(a)
}

theorem gcd_zero_left(a: ℕ) { gcd(0, a) = a } by {
    // gcd(a, 0) = a by previous theorem, show gcd(0, a) = a
    gcd(a, 0).divides(0)
    gcd(a, 0).divides(a)
    gcd(a, 0).divides(gcd(0, a))
    a.divides(gcd(a, 0))
    divides_trans(a, gcd(a, 0), gcd(0, a))
    a.divides(gcd(0, a))
    gcd(0, a).divides(a)
}

// GCD is commutative
theorem gcd_comm(a: ℕ, b: ℕ) { gcd(a, b) = gcd(b, a) } by {
    // Both gcd(a,b) and gcd(b,a) divide a and b
    (
        a.divides(gcd(a, b)) and b.divides(gcd(a, b))
        iff
        b.divides(gcd(a, b)) and a.divides(gcd(a, b))
    )
    // Each divides the other, so they're equal
    gcd(b, a).divides(gcd(a, b))
    gcd(a, b).divides(gcd(b, a))
}

// A property f is preserved under mod: if f holds for a and b, it holds for a mod b
define mod_maintains(f: ℕ -> Bool) -> Bool {
    forall(a: ℕ, b: ℕ) { f(a) and f(b) implies f(a.mod(b)) }
}

// If f is preserved under mod and holds for a,b, then f holds for gcd(a,b)
theorem mod_maintains_imp_gcd(f: ℕ -> Bool, a: ℕ, b: ℕ) {
    mod_maintains(f) and f(a) and f(b) implies f(gcd(a, b))
} by {
    // Track whether f holds for both components of the pair during Euclidean algorithm
    let p = Pair[ℕ, ℕ].new(a, b)
    let g = function(n: ℕ) {
        f(gcd_step_n(p, n).first) and f(gcd_step_n(p, n).second)
    }
    // Base case: initially, f holds for a and b
    gcd_step_n(p, 0).first = a
    gcd_step_n(p, 0).second = b
    f(gcd_step_n(p, 0).second)
    f(gcd_step_n(p, 0).first)
    g(0)
    // Inductive step: if f holds at step x, it holds at step x+1
    forall(x: ℕ) {
        if g(x) {
            gcd_step_n(p, x.suc) = gcd_step(gcd_step_n(p, x))
            f(gcd_step_n(p, x).first)
            f(gcd_step_n(p, x).second)

            if gcd_step_n(p, x).second = 0 {
                // Algorithm terminates, pair unchanged
                gcd_step_n(p, x.suc) = gcd_step_n(p, x)
                f(gcd_step_n(p, x.suc).first)
                f(gcd_step_n(p, x.suc).second)
                g(x.suc)
            } else {
                // One Euclidean step: (a,b) -> (b, a mod b)
                Pair.new(
                    gcd_step_n(p, x).second,
                    gcd_step_n(p, x).first.mod(gcd_step_n(p, x).second)
                ) = gcd_step(gcd_step_n(p, x))

                gcd_step_n(p, x.suc).first = gcd_step_n(p, x).second

                gcd_step_n(p, x.suc).second = gcd_step_n(p, x).first.mod(gcd_step_n(p, x).second)

                f(gcd_step_n(p, x.suc).first)

                // mod_maintains ensures f holds for a mod b
                f(gcd_step_n(p, x).first.mod(gcd_step_n(p, x).second))

                f(gcd_step_n(p, x.suc).second)
                g(x.suc)
            }
        }
    }
    // At termination, f holds for the GCD (first component when second is 0)
    g(num_gcd_steps(p))
    f(gcd_step_n(p, num_gcd_steps(p)).first)
    f(gcd(a, b))
}

theorem gcd_one_right(a: ℕ) {
    gcd(a, 1) = 1
}

theorem gcd_one_left(a: ℕ) {
    gcd(1, a) = 1
}

// Multiplying both arguments by m (non-zero) multiplies the GCD by m
theorem gcd_mul_left_nonzero(a: ℕ, b: ℕ, m: ℕ) {
    m != 0 implies m * gcd(a, b) = gcd(m * a, m * b)
} by {
    m.divides(m * a)
    m.divides(m * b)
    m.divides(gcd(m * a, m * b))
    let d: ℕ satisfy {
        m * d = gcd(m * a, m * b)
    }

    // Overall we will prove equality by proving both sides divide the other.
    // First we prove that d equals gcd(a, b), to prove that right divides left.
    (m * d).divides(m * a)
    d.divides(a)
    (m * d).divides(m * b)
    d.divides(b)
    d.divides(gcd(a, b))
    (m * d).divides(m * gcd(a, b))
    gcd(m * a, m * b).divides(m * gcd(a, b))

    // Now we prove left divides right.
    (m * gcd(a, b)).divides(m * a)
    (m * gcd(a, b)).divides(m * b)
    (m * gcd(a, b)).divides(gcd(m * a, m * b))
}

// Multiplying both arguments by m multiplies the GCD by m (including m=0)
theorem gcd_mul_left(a: ℕ, b: ℕ, m: ℕ) {
    m * gcd(a, b) = gcd(m * a, m * b)
} by {
    // Handle zero case separately
    if m = 0 {
        m * gcd(a, b) = 0
        gcd(m * a, m * b) = 0
    } else {
        // Non-zero case proved by gcd_mul_left_nonzero
        m * gcd(a, b) = gcd(m * a, m * b)
    }
}

// Right multiplication version (using commutativity)
theorem gcd_mul_right(a: ℕ, b: ℕ, m: ℕ) {
    gcd(a, b) * m = gcd(a * m, b * m)
} by {
    gcd_mul_left(a, b, m)
    gcd_comm(a, b)
    gcd_comm(m * a, m * b)
}

// If a = af * gcd(a,b) and b = bf * gcd(a,b), then gcd(af, bf) = 1
theorem cofactor(a: ℕ, b: ℕ, af: ℕ, bf: ℕ) {
    (
        gcd(a, b) != 0 and
        af * gcd(a, b) = a and
        bf * gcd(a, b) = b
    ) implies gcd(af, bf) = 1
} by {
    // gcd(af, bf) divides af, so it divides a = af * gcd(a,b)
    gcd(af, bf).divides(af)
    (gcd(a, b) * gcd(af, bf)).divides(a)
    // Similarly for b
    gcd(af, bf).divides(bf)
    (gcd(a, b) * gcd(af, bf)).divides(b)
    // So gcd(a,b) * gcd(af, bf) divides gcd(a,b), implying gcd(af, bf) = 1
    (gcd(a, b) * gcd(af, bf)).divides(gcd(a, b))
    (gcd(a, b) * gcd(af, bf)).divides(gcd(a, b) * 1)
    gcd(af, bf).divides(1)
    gcd(af, bf) = 1
}

// For prime p, either gcd(p,n) = 1 or p divides n
theorem gcd_of_prime(p: ℕ, n: ℕ) {
    p.is_prime implies gcd(p, n) = 1 or p.divides(n)
} by {
    // gcd(p,n) divides p, so p = d * gcd(p,n) for some d
    gcd(p, n).divides(p)
    let d: ℕ satisfy {
        d * gcd(p, n) = p
    }
    d != 0
    // If d = 1, then gcd(p,n) = p, so p divides n
    if d = 1 {
        gcd(p, n) = p
        p.divides(n)
    } else {
        // If d > 1 and gcd(p,n) > 1, then p would be composite (contradiction)
        if gcd(p, n) > 1 {
            d > 1
            p.is_composite
            false
        }
        // Otherwise, gcd(p,n) = 1
        gcd(p, n) != 0
        gcd(p, n) = 1
    }
}

// Euclid's lemma for primes: if prime a divides product b*c, then a divides b or a divides c
theorem euclids_lemma_prime(a: ℕ, b: ℕ, c: ℕ) {
    a.is_prime and a.divides(b * c) implies a.divides(b) or a.divides(c)
} by {
    // If a doesn't divide b, then gcd(a,b) = 1
    if not a.divides(b) {
        gcd(a, b) = 1
        // Use gcd multiplication property
        gcd(a * c, b * c) = gcd(a, b) * c
        gcd(a * c, b * c) = c
        // a divides both a*c and b*c, so a divides gcd(a*c, b*c) = c
        a.divides(a * c)
        a.divides(b * c)
        a.divides(gcd(a * c, b * c))
        a.divides(c)
    }
}

// If a prime divides another prime, they must be equal
theorem divides_prime(a: ℕ, b: ℕ) {
    a.is_prime and b.is_prime and a.divides(b) implies a = b
} by {
    a <= b
    // If a < b, then a would be a proper divisor of b, contradicting b is prime
    not (1 < a and a < b)
    a = b
}

theorem euclids_lemma_divides_primes(a: ℕ, b: ℕ, c: ℕ) {
    a.is_prime and b.is_prime and c.is_prime and a.divides(b * c) implies a = b or a = c
} 

theorem are_primes_decomposition(head: ℕ, tail: List[ℕ]) {
    are_primes(List.cons(head, tail)) iff head.is_prime and are_primes(tail)
} by {
    // Forward direction: if list has only primes, head is prime and tail has only primes
    if are_primes(List.cons(head, tail)) {
        head.is_prime
        forall(x: ℕ) {
            x ∈ tail implies x ∈ List.cons(head, tail)
            x ∈ tail implies x.is_prime
        }
        are_primes(tail)
    }
    // Reverse direction: if head is prime and tail has only primes, list has only primes
    if head.is_prime and are_primes(tail) {
        forall(x: ℕ) {
            x ∈ List.cons(head, tail) implies x = head or x ∈ tail
            x ∈ List.cons(head, tail) implies x.is_prime
        }
        are_primes(List.cons(head, tail))
    }
}

// If prime a divides product of list l, then a divides some element of l
theorem euclids_lemma_prime_divides_list(a: ℕ, l: List[ℕ]) {
    a.is_prime and a.divides(product(l)) implies exists(b: ℕ) {
        b ∈ l and a.divides(b)
    }
} by {
    define f(ps: List[ℕ]) -> Bool {
        euclids_lemma_prime_divides_list(a, ps)
    }
    // Base case: empty list, product = 1, no prime divides 1
    product(List[ℕ].nil) = 1
    not a.divides(1)
    f(List[ℕ].nil)

    // Inductive step: cons(head, tail)
    forall(head: ℕ, tail: List[ℕ]) {
        product(List.cons(head, tail)) = head * product(tail)
        if f(tail) {
            if a.divides(product(List.cons(head, tail))) {
                // By Euclid's lemma for primes
                a.divides(head) or a.divides(product(tail))
                if a.divides(head) {
                    exists(b: ℕ) {
                        b ∈ List.cons(head, tail) and a.divides(b)
                    }
                } else {
                    a.divides(product(tail))
                    let (n: ℕ) satisfy {
                        n ∈ tail and a.divides(n)
                    }
                    n ∈ List.cons(head, tail) and a.divides(n)
                    exists(b: ℕ) {
                        b ∈ List.cons(head, tail) and a.divides(b)
                    }
                }
                exists(b: ℕ) {
                    b ∈ List.cons(head, tail) and a.divides(b)
                }
                f(List.cons(head, tail))
            } else {
                euclids_lemma_prime_divides_list(a, List.cons(head, tail))

                f(List.cons(head, tail))
            }
            f(List.cons(head, tail))
        }
    }
    f(l)
}

// If prime a divides product of prime list l, then a is in l
theorem euclids_lemma_prime_divides_prime_list(a: ℕ, l: List[ℕ]) {
    a.is_prime and are_primes(l) and a.divides(product(l)) implies a ∈ l

} by {
    // Should follow from euclids_lemma_prime_divides_list and the fact that
    // if a prime divides another element of the list (all primes), they must be equal
    let (p: ℕ) satisfy {
        p ∈ l and a.divides(p)
    } 
    a = p
}

// Product of list equals x^count(x) times product of list with x removed
theorem remove_product(x: ℕ, l: List[ℕ]) {
    x^(l.count(x)) * product(l ∖ x) = product(l)
} by {
    // Induction on list structure
    define f(ns: List[ℕ]) -> Bool {
        x^(ns.count(x)) * product(ns ∖ x) = product(ns)
    }
    f(List[ℕ].nil)
    forall(head: ℕ, tail: List[ℕ]) {
        product(List.cons(head, tail)) = head * product(tail)
        if f(tail) {
            // Case: x is in the list
            if x ∈ List.cons(head, tail) {
                // Subcase: head is x
                if head = x {
                    List.cons(head, tail) ∖ x = tail ∖ x

                    List.cons(head, tail).count(x) = 1 + tail.count(x)

                    x^(List.cons(head, tail).count(x)) = x * x^(tail.count(x))

                    x^(tail.count(x)) * product(tail ∖ x) = product(tail)

                    x * x^(tail.count(x)) * product(List.cons(head, tail) ∖ x) = x * product(tail)

                    x^(List.cons(head, tail).count(x)) * product(List.cons(head, tail) ∖ x) = product(List.cons(head, tail))

                    f(List.cons(head, tail))
                } else {
                    // Subcase: head is not x, so x is in tail
                    x != head
                    x ∈ tail

                    List.cons(head, tail).count(x) = tail.count(x)

                    List.cons(head, tail) ∖ x = List.cons(head, tail ∖ x)

                    product(List.cons(head, tail) ∖ x) = head * product(tail ∖ x)

                    x^(tail.count(x)) * product(tail ∖ x) = product(tail)

                    product(List.cons(head, tail)) = head * x^(tail.count(x)) * product(tail ∖ x)

                    product(List.cons(head, tail)) = head * x^(List.cons(head, tail).count(x)) * product(tail ∖ x)

                    product(List.cons(head, tail)) = x^(List.cons(head, tail).count(x)) * product(List.cons(head, tail) ∖ x)

                    f(List.cons(head, tail))
                }
            } else {
                // Case: x is not in the list
                x ∉ List.cons(head, tail)
                List.cons(head, tail).count(x) = 0
                List.cons(head, tail) ∖ x = List.cons(head, tail)
                x^(List.cons(head, tail).count(x)) * product(List.cons(head, tail) ∖ x) = product(List.cons(head, tail))
                f(List.cons(head, tail))
            }
        }
    }
    f(l)
}

theorem prime_divides_prime_list_iff_contains(x: ℕ, l: List[ℕ], q: ℕ) {
    x.is_prime and x.divides(product(l)) and are_primes(l) implies l.count(x) != 0
} 

theorem remove_preserve_are_primes(x: ℕ, l: List[ℕ]) {
    are_primes(l) and x.is_prime implies are_primes(l ∖ x)
} by {
    forall(n: ℕ) {
        n ∈ l ∖ x implies n ∈ l
        n ∈ l ∖ x implies n.is_prime
    }
}

// half of theorem
theorem prime_decomposition_have_same_count_of_prime_helper(x: ℕ, l1: List[ℕ], l2: List[ℕ]) {
    x.is_prime and 
    are_primes(l1) and are_primes(l2) and
    product(l1) = product(l2) 
    implies l1.count(x) >= l2.count(x)
} by {
    x^(l1.count(x)) * product(l1 ∖ x) = product(l1)
    x^(l2.count(x)) * product(l2 ∖ x) = product(l2)
    if l1.count(x) < l2.count(x) {
        let n: ℕ satisfy {
            l1.count(x) + n = l2.count(x) and n != 0
        }
        x^(l2.count(x)) = x^(l1.count(x)) * x^n

        x^(l1.count(x)) * product(l1 ∖ x) = x^(l1.count(x)) * (x^n * product(l2 ∖ x))

        x^(l1.count(x)) != 0

        product(l1 ∖ x) = x^n * product(l2 ∖ x)

        1 <= n

        product(l1 ∖ x) = x * x^(n - 1) * product(l2 ∖ x)

        x.is_prime
        are_primes(l1 ∖ x)

        x.divides(product(l1 ∖ x))

        (l1 ∖ x).count(x) != 0

        false
    }
}

theorem prime_list_same_count_prime(x: ℕ, l1: List[ℕ], l2: List[ℕ]) {
    x.is_prime and 
    are_primes(l1) and are_primes(l2) and
    product(l1) = product(l2) 
    implies l1.count(x) = l2.count(x)
} by {
    l1.count(x) >= l2.count(x)
    l2.count(x) >= l1.count(x)
}

// A composite number cannot divide a prime
theorem composite_not_divides_prime(a: ℕ, p: ℕ) {
    a.is_composite and p.is_prime implies not a.divides(p)
} by {
    if a.divides(p) {
        let (b: ℕ, c: ℕ, n: ℕ) satisfy {
            a = b * c and
            (1 < b and b < a) and
            (1 < c and c < a) and
            a * n = p
        }
        // Then b * (c * n) = p with 1 < b < p
        b * (c * n) = p
        b < p
        // So b is a proper divisor of p, contradicting p is prime
        b.proper_divides(p)
        not p.is_prime
        false
    }
}

// If n is not prime and l contains only primes, then n doesn't appear in l
theorem not_prime_not_in_prime_list(n: ℕ, l: List[ℕ]) {
    not n.is_prime and are_primes(l) implies l.count(n) = 0
} by {
    // Case analysis: n <= 1 or n > 1 (hence composite)
    if n <= 1 {
        l.count(n) = 0
    } else {
        1 < n
        n.is_composite
        l.count(n) = 0
    }
}

// Uniqueness of prime factorization: any two prime factorizations of n are permutations
theorem prime_decomposition_uniqueness(n: ℕ, l1: List[ℕ], l2: List[ℕ]) {
    1 < n and
    are_primes(l1) and n = product(l1) and
    are_primes(l2) and n = product(l2) implies
    l1.is_permutation(l2)
} by {
    // Two lists are permutations iff they have the same count of every element
    forall(x: ℕ) {
        x.is_prime implies l1.count(x) = l2.count(x)
        not x.is_prime implies l1.count(x) = l2.count(x)
    }
}

// Product of empty list is 1
theorem nil_list_product_is_one {
    product(List[ℕ].nil) = 1
}

// Non-empty prime list has product > 1
theorem non_nil_prime_list_product_gt_one(l: List[ℕ]) {
    l != List[ℕ].nil and are_primes(l) implies 1 < product(l)
} by {
    // Induction on list structure
    define f(ps: List[ℕ]) -> Bool {
        non_nil_prime_list_product_gt_one(ps)
    }
    f(List[ℕ].nil)
    forall(head: ℕ, tail: List[ℕ]) {
        if f(tail) {
            if are_primes(List.cons(head, tail)) {
                if tail = List[ℕ].nil {
                    // Singleton list: product = head, and head > 1 (prime)
                    product(List.cons(head, tail)) = head
                    head.is_prime
                    1 < head
                    1 < product(List.cons(head, tail))
                } else {
                    // Non-singleton: both head > 1 and product(tail) > 1
                    1 < product(tail)
                    head.is_prime
                    1 < head
                    product(List.cons(head, tail)) = head * product(tail)
                    1 < product(List.cons(head, tail))
                }
                1 < product(List.cons(head, tail))
            }
            f(List.cons(head, tail))
        }
    }
    f(l)
}

theorem prime_list_product_gte_one(l: List[ℕ]) {
    are_primes(l) implies 1 <= product(l)
}

theorem prime_list_product_one_imp_nil(l: List[ℕ]) {
    are_primes(l) and product(l) = 1 implies l = List[ℕ].nil
}

theorem prime_list_product_gt_one_imp_non_nil(l: List[ℕ]) {
    are_primes(l) and product(l) > 1 implies l != List[ℕ].nil
}

attributes ℕ {
    define have_prime_decomp(self, l: List[ℕ]) -> Bool {
        are_primes(l) and self = product(l)
    }
}

theorem zero_have_no_prime_decomp(l: List[ℕ]) {
    not 0.have_prime_decomp(l)
}

theorem prime_list_divides_product(p: ℕ, l: List[ℕ]) {
    are_primes(l) and p ∈ l implies p.divides(product(l))
} by {
    if l = List[ℕ].nil { 
        not p ∈ l 
        false
    } else {
        l != List[ℕ].nil
        l.count(p) >= 1
        p^(l.count(p)) * product(l ∖ p) = product(l)
        l.count(p) - 1 + 1 = l.count(p)
        (p * p^(l.count(p) - 1)) * product(l ∖ p) = product(l)
        p.divides(product(l))
    }
}

// Prime numbers have unique prime decomposition as singleton list
theorem prime_have_singleton_prime_decomposition(x: ℕ, l: List[ℕ]) {
    x.is_prime and x.have_prime_decomp(l) implies l = List.singleton(x)
} by {
    // Can't have x appearing more than once (would make product too large)
    if l.count(x) > 1 {
        x^(l.count(x)) * product(l ∖ x) = product(l)
        product(l) = x
        x^(l.count(x)) > x
        false
    } else {
        // x must appear exactly once
        l.count(x) != 0
        l.count(x) = 1
        // Can't have any other element in the list (would divide x)
        if exists(y: ℕ) { y ∈ l and y != x } {
            let y: ℕ satisfy { y ∈ l and y != x }
            l.count(y) != 0
            y.is_prime
            y.divides(product(l))
            y.divides(x)
            false
        } else {
            forall(y: ℕ) { y ∈ l implies y = x }
            l = List.singleton(x)
        }
    }
}

// I have to use these helper, otherwise, the prover fails to search
define have_no_common_prime_factor(a: ℕ, b: ℕ) -> Bool {
    forall(la: List[ℕ], lb: List[ℕ], p: ℕ) {
        a.have_prime_decomp(la) and 
        b.have_prime_decomp(lb) implies 
        (not (p ∈ la and p ∈ lb))
    }
}

theorem have_no_common_prime_factor_helper(a: ℕ, b: ℕ) {
    forall(la: List[ℕ], lb: List[ℕ], p: ℕ) {
        a.have_prime_decomp(la) and 
        b.have_prime_decomp(lb) implies 
        (not (p ∈ la and p ∈ lb))
    } implies have_no_common_prime_factor(a, b)
}

// Numbers are relatively prime (coprime) if they share no prime factors
// prepare for the defition of rational number
define relative_prime(a: ℕ, b: ℕ) -> Bool {
    a != 0 and b != 0 and have_no_common_prime_factor(a, b)
}

// If a and b are relatively prime, their GCD is 1
theorem relative_prime_imp_gcd_one(a: ℕ, b: ℕ) {
    relative_prime(a, b) implies gcd(a, b) = 1
} by {
    gcd(a, b) != 0
    let (l: List[ℕ]) satisfy {
        gcd(a, b).have_prime_decomp(l)
    }
    // Assume gcd(a,b) > 1 for contradiction
    if gcd(a, b) != 1 {
        gcd(a, b) > 1
        l != List[ℕ].nil
        // GCD > 1 has a prime divisor
        let p: ℕ satisfy { p ∈ l and p.is_prime }
        p.divides(gcd(a, b))
        p.divides(a)
        p.divides(b)
        a != 0
        b != 0
        let (la: List[ℕ]) satisfy {
            a.have_prime_decomp(la)
        }
        let (lb: List[ℕ]) satisfy {
            b.have_prime_decomp(lb)
        }
        p ∈ la
        p ∈ lb
        // Contradicts a and b having no common prime factors
        not have_no_common_prime_factor(a, b)
        not relative_prime(a, b)
        false
    }
}

theorem gcd_one_imp_relative_prime_helper(a: ℕ, b: ℕ) {
    a != 0 and b != 0 and gcd(a, b) = 1 implies 
    a != 0 and b != 0 and forall(la: List[ℕ], lb: List[ℕ], p: ℕ) {
        a.have_prime_decomp(la) and 
        b.have_prime_decomp(lb) implies 
        (not (p ∈ la and p ∈ lb))
    }
} by {
    forall(la: List[ℕ], lb: List[ℕ], p: ℕ) {
        if a.have_prime_decomp(la) and 
        b.have_prime_decomp(lb) {
            if p ∈ la and p ∈ lb {
                p.is_prime
                p.divides(a)
                p.divides(b)
                p.divides(gcd(a, b))
                p = 1
                false
            }
            not (p ∈ la and p ∈ lb)
        }
    }
}

theorem gcd_one_imp_relative_prime(a: ℕ, b: ℕ) {
    (a != 0 and b != 0) and gcd(a, b) = 1 implies relative_prime(a, b) 
} by {
    a != 0
    b != 0
    forall(la: List[ℕ], lb: List[ℕ], p: ℕ) {
        (
            a.have_prime_decomp(la) and 
            b.have_prime_decomp(lb)
        ) implies (not (p ∈ la and p ∈ lb))
    }
    have_no_common_prime_factor_helper(a, b)
    have_no_common_prime_factor(a, b)  
}

theorem relative_prime_iff_gcd_one(a: ℕ, b: ℕ) {
    relative_prime(a, b) iff a != 0 and b != 0 and gcd(a, b) = 1
} by {
    relative_prime(a, b) implies a != 0 and b != 0 and gcd(a, b) = 1
    a != 0 and b != 0 and gcd(a, b) = 1 implies relative_prime(a, b)
}

// If l1 is a subset of l2 (both prime lists), then product(l1) divides product(l2)
theorem sub_prime_list_divides(l1: List[ℕ], l2: List[ℕ]) {
    are_primes(l1) and are_primes(l2) and l1 ⊆ l2 implies product(l1).divides(product(l2))
} by {
    // Induction on l1
    define f(l: List[ℕ]) -> Bool {
        are_primes(l) and are_primes(l2) and l ⊆ l2 implies product(l).divides(product(l2))
    }
    f(List[ℕ].nil)
    forall(head: ℕ, tail: List[ℕ]) {
        if f(tail) {
            if are_primes(List.cons(head, tail)) and are_primes(l2) and List.cons(head, tail) ⊆ l2 {
                let q1 = product(tail ∖ head)

                head^(tail.count(head)) * q1 = product(tail)

                let q2 = product(l2 ∖ head)

                head^(l2.count(head)) * q2 = product(l2)

                are_primes(tail)

                forall(p: ℕ) {
                    tail.count(p) <= List.cons(head, tail).count(p)
                    tail.count(p) <= l2.count(p)
                }

                product(tail).divides(product(l2))

                let q: ℕ satisfy {
                    product(tail) * q = product(l2)
                }

                head^(tail.count(head)) * q1 * q = head^(l2.count(head)) * q2

                List.cons(head, tail).count(head) = 1 + tail.count(head)

                tail.count(head) + 1 <= l2.count(head)

                (head^(tail.count(head) + 1)).divides(head^(l2.count(head)))

                (head^(tail.count(head) + 1)).divides(product(l2))

                let n: ℕ satisfy {
                    head^(tail.count(head) + 1) * n = product(l2)
                }

                head^(tail.count(head)) * (q1 * q) = head^(tail.count(head)) * (head * n)

                q1 * q = head * n

                head.divides(q1 * q)

                // head can't divide q1 (q1 has no head factors by construction)
                if head.divides(q1) {
                    head ∈ (tail ∖ head)
                    false
                }

                head.divides(q)

                let m: ℕ satisfy { q = head * m }

                head^(tail.count(head)) * q1 * (head * m) = head^(l2.count(head)) * q2

                head * (head^(tail.count(head)) * q1) * m = head^(l2.count(head)) * q2

                head * product(tail) * m = product(l2)

                product(List.cons(head, tail)) = head * product(tail)

                product(List.cons(head, tail)).divides(product(l2))

                f(List.cons(head, tail))
            }
            f(List.cons(head, tail))
        }
    }
    f(l1)
}

// If product(l1) divides product(l2) (both prime lists), then l1 is a subset of l2
theorem divides_imp_sub_prime_list(l1: List[ℕ], l2: List[ℕ]) {
    are_primes(l1) and are_primes(l2) and product(l1).divides(product(l2)) implies l1 ⊆ l2
} by {
    forall(p: ℕ) {
        p^(l1.count(p)) * product(l1 ∖ p) = product(l1)

        p^(l2.count(p)) * product(l2 ∖ p) = product(l2)

        (p^(l1.count(p))).divides(product(l2))

        if not p.is_prime {
            l1.count(p) = 0
            l2.count(p) = 0
            l1.count(p) <= l2.count(p)
        } else {
            p.is_prime
            if l1.count(p) = 0 {
                l1.count(p) <= l2.count(p)
            } else {
                l1.count(p) != 0
                l1.count(p) >= 1
                are_primes(l2 ∖ p)
                // p doesn't divide product(l2 ∖ p) since it has no p factors
                not p.divides(product(l2 ∖ p))

                // Assume for contradiction that l1 has more p's than l2
                if (l1.count(p) > l2.count(p)) {
                    let n: ℕ satisfy {
                        l1.count(p) = l2.count(p) + n and n != 0
                    }

                    let q: ℕ satisfy {
                        product(l1) * q = product(l2)
                    }

                    p^(l2.count(p)) * (p^n * product(l1 ∖ p) * q) = p^(l2.count(p)) * product(l2 ∖ p)

                    p^n * product(l1 ∖ p) * q = product(l2 ∖ p)

                    1 <= n

                    p * (p^(n - 1) * product(l1 ∖ p) * q) = product(l2 ∖ p)

                    // Contradiction: p divides product(l2 ∖ p)
                    p.divides(product(l2 ∖ p))

                    false
                }
                l1.count(p) <= l2.count(p)
            }
        }
    }
}

// General Euclid's lemma: if gcd(a,b)=1 and a divides b*c, then a divides c
theorem euclids_lemma(a: ℕ, b: ℕ, c: ℕ) {
    gcd(a, b) = 1 and a.divides(b * c) implies a.divides(c)
} by {
    // Handle edge cases where one or more arguments is zero
    if a = 0 {
        b = 1
        b * c = 0
        c = 0
        a.divides(c)
    }
    if b = 0 {
        a = 1
        a.divides(c)
    }
    if c = 0 {
        a.divides(c)
    }
    // Main case: all non-zero
    if a != 0 and b != 0 and c != 0 {
        let (la: List[ℕ]) satisfy {
            a.have_prime_decomp(la)
        }
        let (lb: List[ℕ]) satisfy {
            b.have_prime_decomp(lb)
        }
        let (lc: List[ℕ]) satisfy {
            c.have_prime_decomp(lc)
        }
        // la is a subset of lb+lc (since a divides b*c)
        forall(p: ℕ) {
            if p ∈ lb + lc {
                p ∈ lb or p ∈ lc
                are_primes(lb)
                are_primes(lc)
                p.is_prime
            }
        }
        are_primes(lb + lc)
        product(lb + lc) = product(lb) * product(lc)
        product(lb + lc) = b * c
        product(la) = a
        product(la).divides(product(lb + lc))
        divides_imp_sub_prime_list(la, lb + lc)
        // Show la is a subset of lc
        forall(p: ℕ) {
            la.count(p) <= (lb + lc).count(p)
            (lb + lc).count(p) = lb.count(p) + lc.count(p)
            if la.count(p) = 0 {
                la.count(p) <= lc.count(p)
            } else {
                la.count(p) != 0
                p.divides(a)
                // Since gcd(a,b)=1, p doesn't divide b
                not p.divides(b)
                lb.count(p) = 0
                la.count(p) <= lc.count(p)
            }
        }
        // Therefore la is subset of lc, so a divides c
        a.divides(c)
    }
}

// Todo: use unique list and power to represent prime list

// If prime p divides a^n (n > 0), then p divides a
theorem prime_divide_power(p: ℕ, a: ℕ, n: ℕ) {
    p.is_prime and n != 0 and p.divides(a^n) implies p.divides(a)
} by {
    // Induction on n
    define f(m: ℕ) -> Bool {
        p.is_prime and m != 0 and p.divides(a^m) implies p.divides(a)
    }
    f(0)
    forall(m: ℕ) {
        if f(m) {
            if p.divides(a^(m.suc)) {
                // a^(m+1) = a^m * a, so p divides a^m or a
                p.divides(a^m * a)
                p.divides(a^m) or p.divides(a)
                // If p divides a^m, by induction p divides a
                p.divides(a)
                f(m.suc)
            }
        }
    }
    f(n)
}

define have_common_prime_factor(a: ℕ, b: ℕ) -> Bool {
    exists(p: ℕ) {
        p.is_prime and p.divides(a) and p.divides(b)
    }
}

theorem not_have_no_common_prime_factor_imp_have_common_prime_facotr(a: ℕ, b: ℕ) {
    not have_no_common_prime_factor(a, b) implies have_common_prime_factor(a, b)
} by {
    let(la: List[ℕ], lb: List[ℕ], p: ℕ) satisfy {
        a.have_prime_decomp(la) and 
        b.have_prime_decomp(lb) and 
        p ∈ la and p ∈ lb
    }
    p.is_prime
    p.divides(a)
    p.divides(b)
}

// If a and b are relatively prime, then so are a^n and b^m (for n,m > 0)
theorem power_preserve_relative_prime(a: ℕ, b: ℕ, n: ℕ, m: ℕ) {
    relative_prime(a, b) and n != 0 and m != 0 implies relative_prime(a^n, b^m)
} by {
    a^n != 0
    b^n != 0
    // Proof by contradiction
    if not relative_prime(a^n, b^m) {
        not have_no_common_prime_factor(a^n, b^m)
        have_common_prime_factor(a^n, b^m)
        let c: ℕ satisfy {
            c.is_prime and c.divides(a^n) and c.divides(b^m)
        }
        // By prime_divide_power, if c divides a^n then c divides a
        c.divides(a)
        c.divides(b)
        not have_no_common_prime_factor(a, b)
        not relative_prime(a, b)
        false
    }
}

theorem power_preserve_gcd_one(a: ℕ, b: ℕ, n: ℕ, m: ℕ) {
    a != 0 and b != 0 and gcd(a, b) = 1 and n != 0 and m != 0 implies gcd(a^n, b^m) = 1
}

// If a divides b and gcd(a,b)=1, then a must be 1
theorem gcd_one_and_divide_imp_one(a: ℕ, b: ℕ) {
    a != 0 and gcd(a, b) = 1 and a.divides(b) implies a = 1
} by {
    // Proof by contradiction
    if a != 1 {
        a > 1
        // Since a divides both a and b, gcd(a,b) >= a
        a.divides(a)
        a.divides(b)
        gcd(a, b) >= a
        gcd(a, b) > 1
        false
    }
}