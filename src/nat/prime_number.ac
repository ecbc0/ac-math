from nat.nat_divide import ℕ, divides_suc
from nat.nat_base import true_below, strong_induction
// from list import List
numerals ℕ

attributes ℕ {
    define is_composite(self) -> Bool {
        exists(a: ℕ) {
            a.proper_divides(self)
        }
    }

    define is_prime(self) -> Bool {
        forall(a: ℕ) {
            self > 1 and not a.proper_divides(self)
        }
    }
}

attributes ℕ {
    define is_direct_composite(self) -> Bool {
        exists(a: ℕ, b: ℕ) {
            (1 < a and a < self) and
            (1 < b and b < self) and
            a ⋅ b = self
        }
    }

    define is_normal_composite(self) -> Bool {
        exists(a: ℕ, b: ℕ) {
            (1 < a) and
            (1 < b) and
            a ⋅ b = self
        }
    }
}

theorem composite_is_direct_composite(n: ℕ) {
    n.is_composite iff n.is_direct_composite
} by {
    if n.is_composite {
        let a: ℕ satisfy { a.proper_divides(n) }
        let b: ℕ satisfy { a ⋅ b = n }
        b.proper_divides(n)
        (
            (1 < a and a < n) and
            (1 < b and b < n) and
            a ⋅ b = n
        )
        n.is_direct_composite
    }

    n.is_direct_composite implies n.is_composite
}

theorem normal_composite_is_direct_composite(n: ℕ) {
    n.is_normal_composite iff n.is_direct_composite
} by {
    n.is_direct_composite implies n.is_normal_composite

    if n.is_normal_composite {
        let (a: ℕ, b: ℕ) satisfy {
            (1 < a) and
            (1 < b) and
            a ⋅ b = n
        }
        a != 0
        b != 0
        a <= n
        b <= n
        a != 1
        b != 1
        a != n
        b != n
        a < n
        b < n

        n.is_direct_composite
    }
}

theorem composite_is_normal_composite(n: ℕ) {
    n.is_composite iff n.is_normal_composite
}

theorem composite_is_not_prime(n: ℕ) {
    n.is_prime iff n > 1 and not n.is_composite
} by {
    n.is_prime implies not n.is_composite
}

theorem not_prime_iff_lte_one_or_composite(n: ℕ) {
    not n.is_prime iff n <= 1 or n.is_composite
} by {
    not n.is_prime implies n <= 1 or n.is_composite
    n <= 1 or n.is_composite implies not n.is_prime
}

theorem has_prime_divisor(n: ℕ) {
    1 < n implies exists(p: ℕ) {
        p.is_prime and p.divides(n)
    }
} by {
    forall(k: ℕ) {
        if true_below(has_prime_divisor, k) {
            if k.is_prime {
                k.divides(k)
                has_prime_divisor(k)
            }
            if k.is_composite {
                k.is_direct_composite
                let (b: ℕ, c: ℕ) satisfy {
                    1 < b and b < k and k = b ⋅ c
                }
                has_prime_divisor(b)
                let (p: ℕ) satisfy {
                    p.is_prime and p.divides(b)
                }
                p.divides(k)
                has_prime_divisor(k)
            }
            has_prime_divisor(k)
        }
    }
    has_prime_divisor(n)
}

from list import List, Add, sum

define all_prime(l: List[ℕ]) -> Bool {
    forall(n: ℕ) {
        n ∈ l implies n.is_prime
    }
}

theorem nil_list_all_prime {
    all_prime(List[ℕ].nil)
}

instance ℕ: Add {
    let add: (ℕ, ℕ) -> ℕ = ℕ.mul

    let 0 = ℕ.1
}

let product = sum[ℕ] 

theorem prime_decomposition(n: ℕ) {
    n != 0 implies exists(l: List[ℕ]) {
        all_prime(l) and n = product(l)
    }
} by {   
    forall(k: ℕ) {
        if true_below(prime_decomposition, k) {
            if k = 0 { prime_decomposition(k) }
            if k = 1 {
                all_prime(List[ℕ].nil)
                1 = product(List[ℕ].nil)

                prime_decomposition(k)
            }
            if k.is_prime {
                let l = List.singleton(k)
                product(l) = k
                forall(m: ℕ) {
                    m ∈ l implies m = k
                    k.is_prime
                    m ∈ l implies m.is_prime
                }
                all_prime(l)
                prime_decomposition(k)
            } 
            if k.is_composite {
                k.is_direct_composite
                let (a: ℕ, b: ℕ) satisfy {
                    (1 < a and a < k) and
                    (1 < b and b < k) and 
                    a ⋅ b = k
                }
                prime_decomposition(a)
                prime_decomposition(b)
                a != 0
                b != 0
                let la: List[ℕ] satisfy {
                    all_prime(la) and a = product(la)
                }
                let lb: List[ℕ] satisfy {
                    all_prime(lb) and b = product(lb)
                }
                let l = la + lb
                forall(x: ℕ) {
                    x ∈ la + lb implies x ∈ la or x ∈ lb
                    x ∈ la implies x.is_prime
                    x ∈ lb implies x.is_prime
                    x ∈ l implies x.is_prime
                }
                all_prime(l)
                product(la + lb) = a ⋅ b
                product(l) = k
                prime_decomposition(k)
            }
            prime_decomposition(k)
        }
    }
    prime_decomposition(n)
}

from nat.nat_combo import divides_factorial

theorem exists_infinite_primes(n: ℕ) {
    exists(p: ℕ) {
        p > n and p.is_prime
    }
} by {
    let m: ℕ = n.! + 1
    1 < m
    let (p: ℕ) satisfy {
        p.is_prime and p.divides(m)
    }
    p > 1
    p != 1
    if p <= n {
        divides_factorial(p, n)
        p.divides(n.!)
        p.divides(n.! + 1)
        not divides_suc(p, n.!)
        false
    }
    not (p <= n)
    p > n
}

// we need Euclid algorithm and gcd to prove uniqueness of prime_decomposition

structure Pair[T1, T2] {
    first: T1
    second: T2
}

/// Performs one step of the Euclidean algorithm for computing GCD.
/// Takes the pair (a, b) and replaces it with (b, a mod b).
define gcd_step(p: Pair[ℕ, ℕ]) -> Pair[ℕ, ℕ] {
    if p.second = 0 {
        p
    } else {
        Pair.new(p.second, p.first.mod(p.second))
    }
}

/// Performs n steps of the Euclidean GCD algorithm.
define gcd_step_n(p: Pair[ℕ, ℕ], n: ℕ) -> Pair[ℕ, ℕ] {
    match n {
        ℕ.0 {
            p
        }
        ℕ.suc(pred) {
            gcd_step(gcd_step_n(p, pred))
        }
    }
}

/// True if a predicate is false for all values below n.
define false_below(f: ℕ -> Bool, n: ℕ) -> Bool { 
    forall(x: ℕ) { x < n implies f(x) = false } 
}

theorem all_false_below(f: ℕ -> Bool) {
    forall(x: ℕ) { false_below(f, x) } implies forall(x: ℕ) { not f(x) }
}

/// True if m is the smallest natural number for which the predicate f is true.
define is_min(f: ℕ -> Bool, m: ℕ) -> Bool {
    f(m) = true and false_below(f, m)
}

// If f is true anywhere (somewhere) on the naturals, it has a min.
theorem has_min(f: ℕ -> Bool, n: ℕ) {
    f(n) implies exists(m: ℕ) { is_min(f, m) }
} by {
    define g(x: ℕ) -> Bool { has_min(f, x) }
    strong_induction(g)
    forall(k: ℕ) {
        if true_below(g, k) {
            if f(k) {
                if false_below(f, k) {
                    is_min(f, k)
                    has_min(f, k)
                } else {
                    exists(a: ℕ) { a < k and f(a) }
                    let a: ℕ satisfy { a < k and f(a) } 
                    g(a)
                    has_min(f, a)
                    has_min(f, k)
                }
            } else {
                // vacuous true
                has_min(f, k)
            }
            g(k)
        }
    }
    g(n)
}

// A decreasing_to_zero function strictly decreases until it hits zero.
define decreasing_to_zero(f: ℕ -> ℕ) -> Bool {
    forall(x: ℕ) {
        f(x) = 0 or f(x.suc) < f(x)
    }
}

theorem no_infinite_decreasing(f: ℕ -> ℕ) {
    exists(x: ℕ) { f(x) <= f(x.suc) }
} by {
    if not no_infinite_decreasing(f) {
        forall(x: ℕ) {
            not (f(x) <= f(x.suc))
            f(x.suc) < f(x)
        }
        // Intuitively, f(x.suc) < f(x) make the decreasing speed of f >= 1, so, start from f(0), after f(0) steps, we must have f(f(0)) <= 0 hence contradiction.
        let h = function(x: ℕ) { x + f(x) <= f(0) }
        ℕ.induction(h)
        0 + f(0) <= f(0)
        h(0)
        forall(x: ℕ) {
            if h(x) {
                x + f(x) <= f(0)
                not (f(x) <= f(x.suc))
                f(x.suc) < f(x)
                x + f(x.suc) < x + f(x)
                (x + f(x.suc)).suc <= x + f(x)
                x.suc + f(x.suc) <= x + f(x)
                x.suc + f(x.suc) <= f(0)
                h(x.suc)
            }
        }
        forall(x: ℕ) {
            h(x)
        }
        h(f(0).suc)
        f(0).suc + f(f(0).suc) <= f(0)
        f(0).suc <= f(0).suc + f(f(0).suc)
        f(0).suc <= f(0)
        false
    }
}

theorem dtz_terminates(f: ℕ -> ℕ) {
    decreasing_to_zero(f) implies exists(n: ℕ) { f(n) = 0 }
} by {
    let (n: ℕ) satisfy { f(n) <= f(n.suc) }
    f(n) = 0 or f(n.suc) < f(n)
    f(n) = 0
}

theorem gcd_terminates(p: Pair[ℕ, ℕ]) {
    exists(n: ℕ) { gcd_step_n(p, n).second = 0 }
} by {
    // prove that gcd_step_n(p, x).second decreasing_to_zero
    // use 
    //     gcd_step(p) = Pair.new(p.second, p.first.mod(p.second)) 
    // and 
    //     p.first.mod(p.second) < p.second
    let f = function(x: ℕ) { 
        gcd_step_n(p, x).second 
    }
    forall(x: ℕ) {
        if f(x) != 0 {
            let q = gcd_step_n(p, x)

            gcd_step_n(p, x.suc) = gcd_step(gcd_step_n(p, x))

            gcd_step_n(p, x.suc) = gcd_step(q)

            f(x.suc) = gcd_step_n(p, x.suc).second

            f(x.suc) = gcd_step(q).second

            q.second != 0

            gcd_step(q) = Pair.new(q.second, q.first.mod(q.second))
            
            q.first.mod(q.second) = gcd_step(q).second
            
            f(x.suc) = q.first.mod(q.second)
            
            f(x.suc) = q.first.mod(f(x))
            
            q.first.mod(f(x)) < f(x)
            
            f(x.suc) < f(x)
        }
    }
    decreasing_to_zero(f)
}

define gcd_termination(p: Pair[ℕ, ℕ]) -> (ℕ -> Bool) {
    function(n: ℕ) {
        gcd_step_n(p, n).second = 0
    }
}

let num_gcd_steps(p: Pair[ℕ, ℕ]) -> n: ℕ satisfy {
    is_min(gcd_termination(p), n)
} by {
    exists(k: ℕ) { gcd_termination(p, k) }
}

theorem num_gcd_steps_terminates(p: Pair[ℕ, ℕ]) {
    gcd_step_n(p, num_gcd_steps(p)).second = 0
} by {
    exists(n: ℕ) { is_min(gcd_termination(p), n) }
    let f = gcd_termination(p)
    is_min(f, num_gcd_steps(p))
    gcd_termination(p)(num_gcd_steps(p)) = true
}

define gcd_of_pair(p: Pair[ℕ, ℕ]) -> ℕ { gcd_step_n(p, num_gcd_steps(p)).first }

define gcd(a: ℕ, b: ℕ) -> ℕ { gcd_of_pair(Pair.new(a, b)) }

define divides_both(a: ℕ, p: Pair[ℕ, ℕ]) -> Bool {
    a.divides(p.first) and a.divides(p.second)
}

theorem divides_both_step(a: ℕ, p: Pair[ℕ, ℕ]) {
    divides_both(a, p) implies divides_both(a, gcd_step(p))
} by {
    a.divides(p.first)
    a.divides(p.second)
    a.divides(p.first.mod(p.second))
    if p.second = 0 {
        gcd_step(p) = p
        divides_both(a, gcd_step(p))
    } else {
        gcd_step(p) = Pair[ℕ, ℕ].new(p.second, p.first.mod(p.second))
        divides_both(a, gcd_step(p))
    }
}

theorem divides_gcd_step_n(d: ℕ, p: Pair[ℕ, ℕ], n: ℕ) {
    divides_both(d, p) implies divides_both(d, gcd_step_n(p, n))
} by {
    let f = function(x: ℕ) { 
        divides_both(d, gcd_step_n(p, x)) 
    }
    divides_both(d, gcd_step_n(p, 0))
    f(0)
    forall(x: ℕ) {
        if f(x) {
            divides_both(d, gcd_step_n(p, x))
            divides_both(d, gcd_step(gcd_step_n(p, x)))
            divides_both(d, gcd_step_n(p, x.suc))
            f(x.suc)
        }
    }
    divides_both(d, gcd_step_n(p, n))
}

theorem divides_gcd_of_pair(d: ℕ, p: Pair[ℕ, ℕ]) {
    divides_both(d, p) implies d.divides(gcd_of_pair(p))
} by {
    divides_both(d, gcd_step_n(p, num_gcd_steps(p)))

    d.divides(gcd_step_n(p, num_gcd_steps(p)).first)
}

theorem divides_gcd(d: ℕ, a: ℕ, b: ℕ) {
    d.divides(a) and d.divides(b) implies d.divides(gcd(a, b))
} by {
    d.divides(Pair[ℕ, ℕ].new(a, b).first)
    d.divides(Pair[ℕ, ℕ].new(a, b).second)
    divides_both(d, Pair[ℕ, ℕ].new(a, b))
    divides_gcd_of_pair(d, Pair[ℕ, ℕ].new(a, b))

    d.divides(gcd_of_pair(Pair[ℕ, ℕ].new(a, b)))
    d.divides(gcd(a, b))
}

theorem divides_both_unstep(a: ℕ, p: Pair[ℕ, ℕ]) {
    divides_both(a, gcd_step(p)) implies divides_both(a, p)
} by {
    if p.second = 0 {
        p = gcd_step(p)
        divides_both(a, p)
    } else {
        gcd_step(p) = Pair[ℕ, ℕ].new(p.second, p.first.mod(p.second))
        a.divides(gcd_step(p).first)
        a.divides(p.second)
        a.divides(gcd_step(p).second)
        a.divides(p.first.mod(p.second))
        a.divides(p.first)
        divides_both(a, p)
    }
}

theorem divides_gcd_step_n_converse(d: ℕ, p: Pair[ℕ, ℕ], n: ℕ) {
    divides_both(d, gcd_step_n(p, n)) implies divides_both(d, p)
} by {
    let f = function(x: ℕ) {
        divides_gcd_step_n_converse(d, p, x)
    }
    ℕ.induction(f)
    if divides_both(d, gcd_step_n(p, 0)) {
        divides_both(d, p)
    }
    divides_gcd_step_n_converse(d, p, 0)
    f(0)
    forall(x: ℕ) {
        if f(x) {
            if divides_both(d, gcd_step_n(p, x.suc)) {
                gcd_step_n(p, x.suc) = gcd_step(gcd_step_n(p, x))
                divides_both(d, gcd_step_n(p, x))
                divides_both(d, p)
            }
            divides_gcd_step_n_converse(d, p, x.suc)
            f(x.suc)
        }
    }
}

theorem divides_gcd_pair_converse(d: ℕ, p: Pair[ℕ, ℕ]) {
    d.divides(gcd_of_pair(p)) implies divides_both(d, p)
} by {
    gcd_of_pair(p) = gcd_step_n(p, num_gcd_steps(p)).first
    0 = gcd_step_n(p, num_gcd_steps(p)).second
    d.divides(gcd_step_n(p, num_gcd_steps(p)).first)
    d.divides(gcd_step_n(p, num_gcd_steps(p)).second)
    divides_both(d, gcd_step_n(p, num_gcd_steps(p)))
    divides_both(d, p)
}

theorem gcd_divides(d: ℕ, a: ℕ, b: ℕ) {
    d.divides(gcd(a, b)) implies d.divides(a) and d.divides(b)
} by {
    let p = Pair[ℕ, ℕ].new(a, b)
    p.first = a
    p.second = b
    d.divides(gcd_of_pair(p))
    divides_both(d, p)
    d.divides(p.first)
    d.divides(a)
    d.divides(p.second)
    d.divides(b)
    d.divides(a) and d.divides(b)
}

theorem gcd_divides_both(a: ℕ, b: ℕ) {
    gcd(a, b).divides(a) and gcd(a, b).divides(b)
} by {
    gcd(a, b).divides(gcd(a, b))
}

theorem gcd_is_gcd(a: ℕ, b: ℕ, d: ℕ) {
    a != 0 and b != 0 and d.divides(a) and d.divides(b) implies d <= gcd(a, b)
} by {
    gcd(a, b) != 0
    d.divides(gcd(a, b))
    d <= gcd(a, b)
}

theorem gcd_nonzero_left(a: ℕ, b: ℕ) {
    a != 0 or b != 0 implies gcd(a, b) != 0
} by {
    if gcd(a, b) = 0 {
        0.divides(a)
        0.divides(b)
        a = 0 and b = 0
        false
    }
}

theorem gcd_zero_right(a: ℕ) { gcd(a, 0) = a } by {
    a.divides(a)
    a.divides(0)
    a.divides(gcd(a, 0))
    gcd(a, 0).divides(a)
}

theorem gcd_zero_left(a: ℕ) { gcd(0, a) = a } by {
    gcd(a, 0).divides(0)
    gcd(a, 0).divides(a)
    gcd(a, 0).divides(gcd(0, a))
    a.divides(gcd(a, 0))
    nat_divide.divides_trans(a, gcd(a, 0), gcd(0, a))
    a.divides(gcd(0, a))
    gcd(0, a).divides(a)
}

theorem gcd_comm(a: ℕ, b: ℕ) { gcd(a, b) = gcd(b, a) } by {
    (
        a.divides(gcd(a, b)) and b.divides(gcd(a, b)) 
        iff 
        b.divides(gcd(a, b)) and a.divides(gcd(a, b))
    )
    gcd(b, a).divides(gcd(a, b))
    gcd(a, b).divides(gcd(b, a))
}

define mod_maintains(f: ℕ -> Bool) -> Bool {
    forall(a: ℕ, b: ℕ) { f(a) and f(b) implies f(a.mod(b)) }
}

theorem mod_maintains_imp_gcd(f: ℕ -> Bool, a: ℕ, b: ℕ) {
    mod_maintains(f) and f(a) and f(b) implies f(gcd(a, b))
} by {
    let p = Pair[ℕ, ℕ].new(a, b)
    let g = function(n: ℕ) {
        f(gcd_step_n(p, n).first) and f(gcd_step_n(p, n).second)
    }
    gcd_step_n(p, 0).first = a
    gcd_step_n(p, 0).second = b
    f(gcd_step_n(p, 0).second)
    f(gcd_step_n(p, 0).first)
    g(0)
    forall(x: ℕ) {
        if g(x) {
            gcd_step_n(p, x.suc) = gcd_step(gcd_step_n(p, x))
            f(gcd_step_n(p, x).first)
            f(gcd_step_n(p, x).second)

            if gcd_step_n(p, x).second = 0 {
                gcd_step_n(p, x.suc) = gcd_step_n(p, x)
                f(gcd_step_n(p, x.suc).first)
                f(gcd_step_n(p, x.suc).second)
                g(x.suc)
            } else {
                Pair.new(
                    gcd_step_n(p, x).second,
                    gcd_step_n(p, x).first.mod(gcd_step_n(p, x).second)
                ) = gcd_step(gcd_step_n(p, x))

                gcd_step_n(p, x.suc).first = gcd_step_n(p, x).second
                                
                gcd_step_n(p, x.suc).second = gcd_step_n(p, x).first.mod(gcd_step_n(p, x).second)
                
                f(gcd_step_n(p, x.suc).first)

                f(gcd_step_n(p, x).first.mod(gcd_step_n(p, x).second))
                
                f(gcd_step_n(p, x.suc).second)
                g(x.suc)
            }
        }
    }
    g(num_gcd_steps(p))
    f(gcd_step_n(p, num_gcd_steps(p)).first)
    f(gcd(a, b))
}

theorem gcd_one_right(a: ℕ) {
    gcd(a, 1) = 1
}

theorem gcd_one_left(a: ℕ) {
    gcd(1, a) = 1
}

theorem gcd_mul_left_nonzero(a: ℕ, b: ℕ, m: ℕ) {
    m != 0 implies m ⋅ gcd(a, b) = gcd(m ⋅ a, m ⋅ b)
} by {
    m.divides(m ⋅ a)
    m.divides(m ⋅ b)
    m.divides(gcd(m ⋅ a, m ⋅ b))
    let d: ℕ satisfy {
        m ⋅ d = gcd(m ⋅ a, m ⋅ b)
    }

    // Overall we will prove equality by proving both sides divide the other.
    // First we prove that d equals gcd(a, b), to prove that right divides left.
    (m ⋅ d).divides(m ⋅ a)
    d.divides(a)
    (m ⋅ d).divides(m ⋅ b)
    d.divides(b)
    d.divides(gcd(a, b))
    (m ⋅ d).divides(m ⋅ gcd(a, b))
    gcd(m ⋅ a, m ⋅ b).divides(m ⋅ gcd(a, b))

    // Now we prove left divides right.
    (m ⋅ gcd(a, b)).divides(m ⋅ a)
    (m ⋅ gcd(a, b)).divides(m ⋅ b)
    (m ⋅ gcd(a, b)).divides(gcd(m ⋅ a, m ⋅ b))
}

theorem gcd_mul_left(a: ℕ, b: ℕ, m: ℕ) {
    m ⋅ gcd(a, b) = gcd(m ⋅ a, m ⋅ b)
} by {
    if m = 0 {
        m ⋅ gcd(a, b) = 0
        gcd(m ⋅ a, m ⋅ b) = 0
    } else {
        m ⋅ gcd(a, b) = gcd(m ⋅ a, m ⋅ b)
    }
}

theorem gcd_mul_right(a: ℕ, b: ℕ, m: ℕ) {
    gcd(a, b) ⋅ m = gcd(a ⋅ m, b ⋅ m)
} by {
    gcd_mul_left(a, b, m)
    gcd_comm(a, b)
    gcd_comm(m ⋅ a, m ⋅ b)
}

theorem cofactor(a: ℕ, b: ℕ, af: ℕ, bf: ℕ) {
    (
        gcd(a, b) != 0 and
        af ⋅ gcd(a, b) = a and
        bf ⋅ gcd(a, b) = b
    ) implies gcd(af, bf) = 1
} by {
    gcd(af, bf).divides(af)
    (gcd(a, b) ⋅ gcd(af, bf)).divides(a)
    gcd(af, bf).divides(bf)
    (gcd(a, b) ⋅ gcd(af, bf)).divides(b)
    (gcd(a, b) ⋅ gcd(af, bf)).divides(gcd(a, b))
    (gcd(a, b) ⋅ gcd(af, bf)).divides(gcd(a, b) ⋅ 1)
    gcd(af, bf).divides(1)
    gcd(af, bf) = 1
}

theorem gcd_of_prime(p: ℕ, n: ℕ) {
    p.is_prime implies gcd(p, n) = 1 or p.divides(n)
} by {
    gcd(p, n).divides(p)
    let d: ℕ satisfy {
        d ⋅ gcd(p, n) = p
    }
    d != 0
    if d = 1 {
        gcd(p, n) = p
        p.divides(n)
    } else {
        if gcd(p, n) > 1 {
            d > 1
            p.is_composite
            false
        }
        gcd(p, n) != 0
        gcd(p, n) = 1
    }
}

theorem euclids_lemma_prime(a: ℕ, b: ℕ, c: ℕ) {
    a.is_prime and a.divides(b ⋅ c) implies a.divides(b) or a.divides(c)
} by {
    if not a.divides(b) {
        gcd(a, b) = 1
        gcd(a ⋅ c, b ⋅ c) = gcd(a, b) ⋅ c
        gcd(a ⋅ c, b ⋅ c) = c
        a.divides(a ⋅ c)
        a.divides(b ⋅ c)
        a.divides(gcd(a ⋅ c, b ⋅ c))
        a.divides(c)
    }
}

theorem divides_prime(a: ℕ, b: ℕ) {
    a.is_prime and b.is_prime and a.divides(b) implies a = b 
} by {
    a <= b
    not (1 < a and a < b)
    a = b    
}

theorem euclids_lemma_divides_primes(a: ℕ, b: ℕ, c: ℕ) {
    a.is_prime and b.is_prime and c.is_prime and a.divides(b ⋅ c) implies a = b or a = c
} 

theorem all_prime_decomposition(head: ℕ, tail: List[ℕ]) {
    all_prime(List.cons(head, tail)) iff head.is_prime and all_prime(tail)
} by {
    if all_prime(List.cons(head, tail)) {
        head.is_prime
        forall(x: ℕ) {
            x ∈ tail implies x ∈ List.cons(head, tail)
            x ∈ tail implies x.is_prime
        }
        all_prime(tail)
    }
    if head.is_prime and all_prime(tail) {
        forall(x: ℕ) {
            x ∈ List.cons(head, tail) implies x = head or x ∈ tail
            x ∈ List.cons(head, tail) implies x.is_prime
        }
        all_prime(List.cons(head, tail))
    }
}

theorem euclids_lemma_prime_divides_list(a: ℕ, l: List[ℕ]) {
    a.is_prime and a.divides(product(l)) implies exists(b: ℕ) {
        b ∈ l and a.divides(b)
    } 
} by {
    define f(ps: List[ℕ]) -> Bool {
        euclids_lemma_prime_divides_list(a, ps)
    }
    product(List[ℕ].nil) = 1
    not a.divides(1)
    f(List[ℕ].nil)

    forall(head: ℕ, tail: List[ℕ]) {
        product(List.cons(head, tail)) = head ⋅ product(tail)
        if f(tail) {
            if a.divides(product(List.cons(head, tail))) {
                a.divides(head) or a.divides(product(tail))
                if a.divides(head) { 
                    exists(b: ℕ) {
                        b ∈ List.cons(head, tail) and a.divides(b)
                    }
                } else {
                    a.divides(product(tail))
                    let (n: ℕ) satisfy {
                        n ∈ tail and a.divides(n)
                    }
                    n ∈ List.cons(head, tail) and a.divides(n)
                    exists(b: ℕ) {
                        b ∈ List.cons(head, tail) and a.divides(b)
                    }
                }
                exists(b: ℕ) {
                    b ∈ List.cons(head, tail) and a.divides(b)
                }
                f(List.cons(head, tail))
            } else {
                euclids_lemma_prime_divides_list(a, List.cons(head, tail))

                f(List.cons(head, tail))
            }
            f(List.cons(head, tail))
        }
    }
    f(l)
}

theorem euclids_lemma_prime_divides_prime_list(a: ℕ, l: List[ℕ]) {
    a.is_prime and all_prime(l) and a.divides(product(l)) implies exists(p: ℕ) {
        p ∈ l and a = p
    } 
} by {
    let (p: ℕ) satisfy {
        p ∈ l and a.divides(p)
    } 
    a = p
}

theorem remove_product(x: ℕ, l: List[ℕ]) {
    x^(l.count(x)) ⋅ product(l ∖ x) = product(l)
} by {
    define f(ns: List[ℕ]) -> Bool {
        x^(ns.count(x)) ⋅ product(ns ∖ x) = product(ns)
    }
    f(List[ℕ].nil)
    forall(head: ℕ, tail: List[ℕ]) {
        product(List.cons(head, tail)) = head ⋅ product(tail)        
        if f(tail) {
            if x ∈ List.cons(head, tail) {
                if head = x {
                    List.cons(head, tail) ∖ x = tail ∖ x

                    List.cons(head, tail).count(x) = 1 + tail.count(x)

                    x^(List.cons(head, tail).count(x)) = x ⋅ x^(tail.count(x))

                    x^(tail.count(x)) ⋅ product(tail ∖ x) = product(tail)

                    x ⋅ x^(tail.count(x)) ⋅ product(List.cons(head, tail) ∖ x) = x ⋅ product(tail)

                    x^(List.cons(head, tail).count(x)) ⋅ product(List.cons(head, tail) ∖ x) = product(List.cons(head, tail))

                    f(List.cons(head, tail))
                } else {
                    x != head
                    x ∈ tail

                    List.cons(head, tail).count(x) = tail.count(x)
                    
                    List.cons(head, tail) ∖ x = List.cons(head, tail ∖ x)

                    product(List.cons(head, tail) ∖ x) = head ⋅ product(tail ∖ x)

                    x^(tail.count(x)) ⋅ product(tail ∖ x) = product(tail)

                    product(List.cons(head, tail)) = head ⋅ x^(tail.count(x)) ⋅ product(tail ∖ x)

                    product(List.cons(head, tail)) = head ⋅ x^(List.cons(head, tail).count(x)) ⋅ product(tail ∖ x)

                    product(List.cons(head, tail)) = x^(List.cons(head, tail).count(x)) ⋅ product(List.cons(head, tail) ∖ x)

                    f(List.cons(head, tail))
                }
            } else {
                x ∉ List.cons(head, tail)
                List.cons(head, tail).count(x) = 0
                List.cons(head, tail) ∖ x = List.cons(head, tail)
                x^(List.cons(head, tail).count(x)) ⋅ product(List.cons(head, tail) ∖ x) = product(List.cons(head, tail))
                f(List.cons(head, tail))
            }
        }
    }
    f(l)
}

theorem prime_divides_prime_list_iff_contains(x: ℕ, l: List[ℕ], q: ℕ) {
    x.is_prime and x.divides(product(l)) and all_prime(l) implies l.count(x) != 0
} 

theorem remove_preserve_all_prime(x: ℕ, l: List[ℕ]) {
    all_prime(l) and x.is_prime implies all_prime(l ∖ x)
} by {
    forall(n: ℕ) {
        n ∈ l ∖ x implies n ∈ l
        n ∈ l ∖ x implies n.is_prime
    }
}

// half of theorem
theorem prime_decomposition_have_same_count_of_prime_helper(x: ℕ, l1: List[ℕ], l2: List[ℕ]) {
    x.is_prime and 
    all_prime(l1) and all_prime(l2) and
    product(l1) = product(l2) 
    implies l1.count(x) >= l2.count(x)
} by {
    x^(l1.count(x)) ⋅ product(l1 ∖ x) = product(l1)
    x^(l2.count(x)) ⋅ product(l2 ∖ x) = product(l2)
    if l1.count(x) < l2.count(x) {
        let n: ℕ satisfy {
            l1.count(x) + n = l2.count(x) and n != 0
        }
        x^(l2.count(x)) = x^(l1.count(x)) ⋅ x^n

        x^(l1.count(x)) ⋅ product(l1 ∖ x) = x^(l1.count(x)) ⋅ (x^n ⋅ product(l2 ∖ x))

        x^(l1.count(x)) != 0

        product(l1 ∖ x) = x^n ⋅ product(l2 ∖ x)

        1 <= n

        product(l1 ∖ x) = x ⋅ x^(n - 1) ⋅ product(l2 ∖ x)

        x.is_prime
        all_prime(l1 ∖ x)

        x.divides(product(l1 ∖ x))

        (l1 ∖ x).count(x) != 0

        false
    }
}

theorem prime_list_same_count_prime(x: ℕ, l1: List[ℕ], l2: List[ℕ]) {
    x.is_prime and 
    all_prime(l1) and all_prime(l2) and
    product(l1) = product(l2) 
    implies l1.count(x) = l2.count(x)
} by {
    l1.count(x) >= l2.count(x)
    l2.count(x) >= l1.count(x)
}

theorem composite_not_divides_prime(a: ℕ, p: ℕ) {
    a.is_composite and p.is_prime implies not a.divides(p)
} by {
    if a.divides(p) {
        let (b: ℕ, c: ℕ, n: ℕ) satisfy { 
            a = b ⋅ c and
            (1 < b and b < a) and 
            (1 < c and c < a) and
            a ⋅ n = p
        }
        b ⋅ (c ⋅ n) = p
        b < p
        b.proper_divides(p)
        not p.is_prime
        false
    }
}

theorem not_prime_not_in_prime_list(n: ℕ, l: List[ℕ]) {
    not n.is_prime and all_prime(l) implies l.count(n) = 0
} by {
    if n <= 1 {
        l.count(n) = 0
    } else {
        1 < n
        n.is_composite
        l.count(n) = 0
    }
}

theorem prime_decomposition_uniqueness(n: ℕ, l1: List[ℕ], l2: List[ℕ]) {
    1 < n and
    all_prime(l1) and n = product(l1) and
    all_prime(l2) and n = product(l2) implies 
    l1.is_permutation(l2)
} by {
    forall(x: ℕ) {
        x.is_prime implies l1.count(x) = l2.count(x)
        not x.is_prime implies l1.count(x) = l2.count(x)
    }
}

theorem nil_list_product_is_one {
    product(List[ℕ].nil) = 1
}

theorem non_nil_prime_list_product_gt_one(l: List[ℕ]) {
    l != List[ℕ].nil and all_prime(l) implies 1 < product(l)
} by {
    define f(ps: List[ℕ]) -> Bool {
        non_nil_prime_list_product_gt_one(ps)
    }
    f(List[ℕ].nil)
    forall(head: ℕ, tail: List[ℕ]) {
        if f(tail) {
            if all_prime(List.cons(head, tail)) {
                if tail = List[ℕ].nil {
                    product(List.cons(head, tail)) = head
                    head.is_prime
                    1 < head
                    1 < product(List.cons(head, tail))
                } else {
                    1 < product(tail)
                    head.is_prime
                    1 < head
                    product(List.cons(head, tail)) = head ⋅ product(tail)
                    1 < product(List.cons(head, tail))
                }
                1 < product(List.cons(head, tail))
            }
            f(List.cons(head, tail))
        }
    }
    f(l)
}

theorem prime_list_product_gte_one(l: List[ℕ]) {
    all_prime(l) implies 1 <= product(l)
}

theorem prime_list_product_one_imp_nil(l: List[ℕ]) {
    all_prime(l) and product(l) = 1 implies l = List[ℕ].nil
}

theorem prime_list_product_gt_one_imp_non_nil(l: List[ℕ]) {
    all_prime(l) and product(l) > 1 implies l != List[ℕ].nil
}

attributes ℕ {
    define have_prime_decomp(self, l: List[ℕ]) -> Bool {
        all_prime(l) and self = product(l)
    }
}

theorem zero_have_no_prime_decomp(l: List[ℕ]) {
    not 0.have_prime_decomp(l)
}

theorem prime_list_divides_product(p: ℕ, l: List[ℕ]) {
    all_prime(l) and p ∈ l implies p.divides(product(l))
} by {
    if l = List[ℕ].nil { 
        not p ∈ l 
        false
    } else {
        l != List[ℕ].nil
        l.count(p) >= 1
        p^(l.count(p)) ⋅ product(l ∖ p) = product(l)
        l.count(p) - 1 + 1 = l.count(p)
        (p ⋅ p^(l.count(p) - 1)) ⋅ product(l ∖ p) = product(l)
        p.divides(product(l))
    }
}

theorem prime_have_singleton_prime_decomposition(x: ℕ, l: List[ℕ]) {
    x.is_prime and x.have_prime_decomp(l) implies l = List.singleton(x)
} by {
    if l.count(x) > 1 {
        x^(l.count(x)) ⋅ product(l ∖ x) = product(l)
        product(l) = x
        x^(l.count(x)) > x
        false
    } else {
        l.count(x) != 0
        l.count(x) = 1
        if exists(y: ℕ) { y ∈ l and y != x } {
            let y: ℕ satisfy { y ∈ l and y != x }
            l.count(y) != 0
            y.is_prime
            y.divides(product(l))
            y.divides(x)
            false
        } else {
            forall(y: ℕ) { y ∈ l implies y = x }
            l = List.singleton(x)
        }
    }
}

// I have to use these helper, otherwise, the prover fails to search
define have_no_common_prime_factor(a: ℕ, b: ℕ) -> Bool {
    forall(la: List[ℕ], lb: List[ℕ], p: ℕ) {
        a.have_prime_decomp(la) and 
        b.have_prime_decomp(lb) implies 
        (not (p ∈ la and p ∈ lb))
    }
}

theorem have_no_common_prime_factor_helper(a: ℕ, b: ℕ) {
    forall(la: List[ℕ], lb: List[ℕ], p: ℕ) {
        a.have_prime_decomp(la) and 
        b.have_prime_decomp(lb) implies 
        (not (p ∈ la and p ∈ lb))
    } implies have_no_common_prime_factor(a, b)
}

// prepare for the defition of rational number
define relative_prime(a: ℕ, b: ℕ) -> Bool {
    a != 0 and b != 0 and have_no_common_prime_factor(a, b)
}

theorem relative_prime_imp_gcd_one(a: ℕ, b: ℕ) {
    relative_prime(a, b) implies gcd(a, b) = 1 
} by {
    gcd(a, b) != 0
    let (l: List[ℕ]) satisfy {
        gcd(a,b).have_prime_decomp(l)
    }
    if gcd(a, b) != 1 {
        gcd(a, b) > 1
        l != List[ℕ].nil
        let p: ℕ satisfy { p ∈ l and p.is_prime }
        p.divides(gcd(a, b))
        p.divides(a)
        p.divides(b)
        a != 0
        b != 0
        let (la: List[ℕ]) satisfy {
            a.have_prime_decomp(la)
        }
        let (lb: List[ℕ]) satisfy {
            b.have_prime_decomp(lb)
        }
        p ∈ la
        p ∈ lb
        not have_no_common_prime_factor(a, b)
        not relative_prime(a, b)
        false
    }
}

theorem gcd_one_imp_relative_prime_helper(a: ℕ, b: ℕ) {
    a != 0 and b != 0 and gcd(a, b) = 1 implies 
    a != 0 and b != 0 and forall(la: List[ℕ], lb: List[ℕ], p: ℕ) {
        a.have_prime_decomp(la) and 
        b.have_prime_decomp(lb) implies 
        (not (p ∈ la and p ∈ lb))
    }
} by {
    forall(la: List[ℕ], lb: List[ℕ], p: ℕ) {
        if a.have_prime_decomp(la) and 
        b.have_prime_decomp(lb) {
            if p ∈ la and p ∈ lb {
                p.is_prime
                p.divides(a)
                p.divides(b)
                p.divides(gcd(a, b))
                p = 1
                false
            }
            not (p ∈ la and p ∈ lb)
        }
    }
}

theorem gcd_one_imp_relative_prime(a: ℕ, b: ℕ) {
    (a != 0 and b != 0) and gcd(a, b) = 1 implies relative_prime(a, b) 
} by {
    a != 0
    b != 0
    forall(la: List[ℕ], lb: List[ℕ], p: ℕ) {
        (
            a.have_prime_decomp(la) and 
            b.have_prime_decomp(lb)
        ) implies (not (p ∈ la and p ∈ lb))
    }
    have_no_common_prime_factor_helper(a, b)
    have_no_common_prime_factor(a, b)  
}

theorem relative_prime_iff_gcd_one(a: ℕ, b: ℕ) {
    relative_prime(a, b) iff a != 0 and b != 0 and gcd(a, b) = 1
} by {
    relative_prime(a, b) implies a != 0 and b != 0 and gcd(a, b) = 1
    a != 0 and b != 0 and gcd(a, b) = 1 implies relative_prime(a, b)
}

theorem sub_prime_list_divides(l1: List[ℕ], l2: List[ℕ]) {
    all_prime(l1) and all_prime(l2) and forall(p: ℕ) {
        l1.count(p) <= l2.count(p)
    } implies product(l1).divides(product(l2))
} by {
    define f(l: List[ℕ]) -> Bool {
        all_prime(l) and all_prime(l2) and forall(p: ℕ) {
            l.count(p) <= l2.count(p)
        } implies product(l).divides(product(l2))    
    }
    f(List[ℕ].nil)
    forall(head: ℕ, tail: List[ℕ]) {
        if f(tail) {
            if all_prime(List.cons(head, tail)) and all_prime(l2) and forall(p: ℕ) {
                List.cons(head, tail).count(p) <= l2.count(p)
            } {
                let q1 = product(tail ∖ head) 
                    
                head^(tail.count(head)) ⋅ q1 = product(tail)

                let q2 = product(l2 ∖ head) 

                head^(l2.count(head)) ⋅ q2 = product(l2)

                all_prime(tail)

                forall(p: ℕ) {
                    tail.count(p) <= List.cons(head, tail).count(p)
                    tail.count(p) <= l2.count(p)
                }

                product(tail).divides(product(l2))

                let q: ℕ satisfy {
                    product(tail) ⋅ q = product(l2)
                }

                head^(tail.count(head)) ⋅ q1 ⋅ q = head^(l2.count(head)) ⋅ q2 

                List.cons(head, tail).count(head) = 1 + tail.count(head)

                tail.count(head) + 1 <= l2.count(head)

                (head^(tail.count(head) + 1)).divides(head^(l2.count(head)))

                (head^(tail.count(head) + 1)).divides(product(l2))

                let n: ℕ satisfy {
                    head^(tail.count(head) + 1) ⋅ n = product(l2)
                }

                head^(tail.count(head)) ⋅ (q1 ⋅ q) = head^(tail.count(head)) ⋅ (head ⋅ n)
                
                q1 ⋅ q = head ⋅ n

                head.divides(q1 ⋅ q)

                if head.divides(q1) {
                    head ∈ (tail ∖ head)
                    false
                }

                head.divides(q)

                let m: ℕ satisfy { q = head ⋅ m }

                head^(tail.count(head)) ⋅ q1 ⋅ (head ⋅ m) = head^(l2.count(head)) ⋅ q2

                head ⋅ (head^(tail.count(head)) ⋅ q1) ⋅ m = head^(l2.count(head)) ⋅ q2

                head ⋅ product(tail) ⋅ m = product(l2)

                product(List.cons(head, tail)) = head ⋅ product(tail)

                product(List.cons(head, tail)).divides(product(l2))

                f(List.cons(head, tail))
            }
            f(List.cons(head, tail))
        }
    }
    f(l1)
}

theorem divides_imp_sub_prime_list(l1: List[ℕ], l2: List[ℕ]) {
    all_prime(l1) and all_prime(l2) and product(l1).divides(product(l2)) implies forall(p: ℕ) {
        l1.count(p) <= l2.count(p)
    }
} by {
    forall(p: ℕ) {
        p^(l1.count(p)) ⋅ product(l1 ∖ p) = product(l1)

        p^(l2.count(p)) ⋅ product(l2 ∖ p) = product(l2)

        (p^(l1.count(p))).divides(product(l2))

        if not p.is_prime {
            l1.count(p) = 0
            l2.count(p) = 0
            l1.count(p) <= l2.count(p)
        } else {
            p.is_prime 
            if l1.count(p) = 0 {
                l1.count(p) <= l2.count(p)
            } else {
                l1.count(p) != 0 
                l1.count(p) >= 1
                all_prime(l2 ∖ p)
                not p.divides(product(l2 ∖ p))

                if (l1.count(p) > l2.count(p)) {
                    let n: ℕ satisfy { 
                        l1.count(p) = l2.count(p) + n and n != 0 
                    }

                    let q: ℕ satisfy {
                        product(l1) ⋅ q = product(l2)
                    }

                    p^(l2.count(p)) ⋅ (p^n ⋅ product(l1 ∖ p) ⋅ q) = p^(l2.count(p)) ⋅ product(l2 ∖ p)

                    p^n ⋅ product(l1 ∖ p) ⋅ q = product(l2 ∖ p)

                    1 <= n

                    p ⋅ (p^(n - 1) ⋅ product(l1 ∖ p) ⋅ q) = product(l2 ∖ p)

                    p.divides(product(l2 ∖ p))

                    false
                }
                l1.count(p) <= l2.count(p)
            }            
        }
    }
}

theorem euclids_lemma(a: ℕ, b: ℕ, c: ℕ) {
    gcd(a, b) = 1 and a.divides(b ⋅ c) implies a.divides(c)
} by {
    if a = 0 {
        b = 1
        b ⋅ c = 0
        c = 0
        a.divides(c)
    } 
    if b = 0 {
        a = 1
        a.divides(c)
    }
    if c = 0 {
        a.divides(c)
    } 
    if a != 0 and b != 0 and c != 0 {
        let (la: List[ℕ]) satisfy {
            a.have_prime_decomp(la)
        }
        let (lb: List[ℕ]) satisfy {
            b.have_prime_decomp(lb)
        }
        let (lc: List[ℕ]) satisfy {
            c.have_prime_decomp(lc)
        }
        forall(p: ℕ) {
            if p ∈ lb + lc {
                p ∈ lb or p ∈ lc
                all_prime(lb)
                all_prime(lc)
                p.is_prime
            }
        }
        all_prime(lb + lc)
        product(lb + lc) = product(lb) ⋅ product(lc)
        product(lb + lc) = b ⋅ c
        product(la) = a
        product(la).divides(product(lb + lc))
        divides_imp_sub_prime_list(la, lb + lc)
        forall(p: ℕ) {
            la.count(p) <= (lb + lc).count(p)
            (lb + lc).count(p) = lb.count(p) + lc.count(p)
            if la.count(p) = 0 {
                la.count(p) <= lc.count(p)
            } else {
                la.count(p) != 0
                p.divides(a)
                not p.divides(b)
                lb.count(p) = 0
                la.count(p) <= lc.count(p)
            }
        }
        a.divides(c)
    }
}