/// Natural numbers, the soul of arithmetic.
/// We build natural numbers from Acorn's inherent properties of inductive types.
inductive Nat {
    /// Zero is a natural number, because it's much more convenient this way.
    0

    /// The successor of a natural number is also a natural number.
    suc(Nat)
}

attributes Nat {
    let 1: Nat = Nat.0.suc
    let 2: Nat = Nat.1.suc
    let 3: Nat = Nat.2.suc
    let 4: Nat = Nat.3.suc
    let 5: Nat = Nat.4.suc
    let 6: Nat = Nat.5.suc
    let 7: Nat = Nat.6.suc
    let 8: Nat = Nat.7.suc
    let 9: Nat = Nat.8.suc
    let 10: Nat = Nat.9.suc

    /// Addition is defined recursively.
    define add(self, other: Nat) -> Nat {
        match other {
            Nat.0 {
                self
            }
            Nat.suc(pred) {
                (self + pred).suc
            }
        }
    }
}

numerals Nat

/// a + 0 = a is definition of `add`  
/// 0 + a = a is from most simple form of induction
theorem add_zero(a: Nat) { a + 0 = a and 0 + a = a } 

theorem one_plus_one { 1 + 1 = 2 } by {
    1 + 0.suc = 1.suc
}

theorem add_one(a: Nat) {
    a + 1 = a.suc
} by {
    a + 0.suc = (a + 0).suc
}

theorem add_suc(n1: Nat, n2: Nat) {
    n1 + n2.suc = n1.suc + n2
} by {
    define f(m: Nat) -> Bool {
        (n1 + m.suc) = (n1.suc + m)
    }
    f(0)
    forall(m: Nat) {
        if f(m) {
            // def of `add(n1, m.suc)`
            (n1 + (m.suc).suc) = (n1 + m.suc).suc
            // f(m)
            (n1 + m.suc).suc = (n1.suc + m).suc
            // def of `add(n1.suc, m.suc)`
            (n1.suc + m.suc) = (n1.suc + m).suc
            // induction on `m` success
            f(m.suc)
        }
    }
    f(n2)
}

theorem add_one_dual(a: Nat) {
    1 + a = a.suc
} by {
    add_suc(0, a)
    0.suc + a = (0 + a).suc
}

/// definition of add is commutative
theorem add_comm(a: Nat, b: Nat) { a + b = b + a } by {
    define f(n: Nat) -> Bool { add_comm(a, n) }
    a + 0 = 0 + a
    add_comm(a, 0)
    f(0)
    forall(n: Nat) {
        if f(n) {
            add_comm(a, n)
            a + n.suc = (a + n).suc
            // f(n)
            (a + n).suc = (n + a).suc
            // def of `add`
            n + a.suc = (n + a).suc
            add_suc(n, a)
            n + a.suc = n.suc + a
            // induction success
            add_comm(a, n.suc)
            f(n.suc)
        }
    }
    add_comm(a, b)
}

theorem add_assoc_one(a: Nat, b: Nat) { (a + b) + 1 = a + (b + 1) }

theorem add_assoc(a: Nat, b: Nat, c: Nat) { (a + b) + c = a + (b + c) } by {
    define f(n: Nat) -> Bool {
        add_assoc(a, b, n) // helper
    }
    f(0)
    forall(n: Nat){
        if f(n) {
            f(n + 1)
        }
    }
    add_assoc(a, b, c)
}

attributes Nat {
    /// Multiplication is defined recursively.
    define mul(self, b: Nat) -> Nat {
        match b {
            Nat.0 {
                0
            }
            Nat.suc(pred) {
                (self * pred) + self
            }
        }
    }

    /// The number formed by appending a digit to this one in base 10.
    define read(self, other: Nat) -> Nat {
        10 * self + other
    }
}

theorem mul_zero(a: Nat) { a * 0 = 0 and 0 * a = 0 } // 0 * a = 0 by easy induction

theorem mul_suc(a: Nat, b: Nat) {
    a * (b + 1) = a * b + a 
}

theorem mul_suc_dual(a: Nat, b: Nat) {
    (a + 1) * b = a * b + b
} by {
    define f(n: Nat) -> Bool {
        (a + 1) * n = a * n + n
    }
    f(0)
    forall(n: Nat) {
        if f(n) {
            (a + 1) * (n + 1) = (a + 1) * n + (a + 1)
            // f(n)
            (a + 1) * n + (a + 1) = (a * n + n) + (a + 1)
            // reorder and collect
            (a * n + a) + (n + 1) = (a * (n + 1)) + (n + 1)
            f(n + 1)
        }
    }
}

theorem mul_comm(a: Nat, b: Nat) { a * b = b * a } by {
    define f(n: Nat) -> Bool { mul_comm(a, n) }
    a * 0 = 0 * a
    mul_comm(a, 0)
    f(0)
    forall(n: Nat) {
        if f(n) {
            // def of mul
            a * (n + 1) = a * n + a
            // f(n) & add_comm
            a * n + a = n * a + a
            // mul_suc_dual
            (n + 1) * a = n * a + a
            f(n + 1)
        }
    }
    f(b)
    mul_comm(a, b)
}

theorem one_mul_one { 1 * 1 = 1 } 

theorem distrib(a: Nat, b: Nat, c: Nat) {
    a * (b + c) = a * b + a * c 
} by {
    define f(x: Nat) -> Bool { distrib(a, b, x) }
    f(0)
    forall(x: Nat) {
        if f(x) {
            distrib(a, b, x)
            a * (b + x) = a * b + a * x            
            mul_suc(a, b + x)
            distrib(a, b, x + 1)
        }
    }
    distrib(a, b, c)
}

theorem distrib_dual(a: Nat, b: Nat, c: Nat) {
    (a + b) * c = a * c + b * c
} // by mul_comm

theorem mul_assoc(a: Nat, b: Nat, c: Nat) { (a * b) * c = a * (b * c) } by {
    define f(x: Nat) -> Bool { mul_assoc(a, b, x) }
    f(0)
    forall(x: Nat) {
        if f(x) {
            (a * b) * x = a * (b * x)
            mul_suc(a * b, x)
            f(x + 1)
        }
    }
    mul_assoc(a, b, c)
}

theorem mul_one(a: Nat) { a * 1 = a } by {
    (a * 0) + a = a
}

theorem mul_one_dual(a: Nat) { 1 * a = a }

theorem suc_ne(a: Nat) { a.suc != a } by {
    suc_ne(0) // by property of inductive
    forall(n: Nat) {
        if suc_ne(n) {
            n.suc != n
            n.suc.suc != n.suc // by property of inductive
            suc_ne(n.suc)
        }
    }
    suc_ne(a)
}

theorem suc_cancels(a: Nat, b: Nat) { a + 1 = b + 1 implies a = b } by {
    if a != b {
        a.suc != b.suc // property of inductive
    }
}

/// 0 is the identity of add: 0 + n = n = n + 0
theorem add_identity(a: Nat, b: Nat) { a + b = b implies a = 0 } by {
    define f(x: Nat) -> Bool { add_identity(a, x) }
    f(0)
    forall(x: Nat) {
        if f(x) {
            suc_cancels(a + x, x)
            f(x + 1)
        }
    }
    add_identity(a, b)
}

theorem add_identity_dual(a: Nat, b: Nat) { b + a = b implies a = 0 }

theorem add_cancels(a: Nat, b: Nat, c: Nat) { a + c = b + c implies a = b } by {
    define f(n: Nat) -> Bool { add_cancels(a, b, n) }
    f(0)
    forall(n: Nat) {
        if f(n) {
            add_cancels(a, b, n)
            suc_cancels(a + n, b + n)
            add_cancels(a, b, n + 1)
        }
    }
    add_cancels(a, b, c)
}

theorem add_cancels_dual(a: Nat, b: Nat, c: Nat) { c + a = c + b implies a = b }

theorem suc_positive(n: Nat) {
    n.suc != 0
} // by definition of inductive, "0 is not suc of any natural number"

theorem nonzero_add_to_nonzero(a: Nat, b: Nat) {
    (a != 0 or b != 0) implies a + b != 0
} by {
    if a != 0 {
        let n: Nat satisfy { a = n + 1 }
        a + b = (n + b).suc
        a + b != 0
    }

    if b != 0 {
        let n: Nat satisfy { b = n + 1 }
        a + b = (a + n).suc
        a + b != 0
    }
}

theorem add_to_zero(a: Nat, b: Nat) {
    a + b = 0 implies (a = 0 and b = 0)
} 

// Ordering

attributes Nat {
    /// `a < b` if there's a positive natural number that can be added to `a` to get `b`.
    define lt(self, other: Nat) -> Bool {
        exists(n: Nat) {
            n != 0 and self + n = other
        }
    }
    define lte(self, other: Nat) -> Bool {
        exists(c: Nat) {
            self < other or self = other
        }
    }
    define gt(self, other: Nat) -> Bool {
        other < self
    }
    define gte(self, other: Nat) -> Bool {
        other <= self
    }
}

theorem lt_trans(a: Nat, b: Nat, c: Nat) { a < b and b < c implies a < c } by {
    let n1: Nat satisfy { a + n1 = b and n1 != 0 }
    let n2: Nat satisfy { b + n2 = c and n1 != 0 }
    a + (n1 + n2) = c
    a < c
}

from order import Partial_Order, Linear_Order
from util import is_transitive, is_acyclic, is_trichotomy

theorem nat_is_transitive {
    is_transitive(Nat.lt)
}

theorem lt_and_eq_is_different_thing(a: Nat) {
    not (a < a)
} by {
    if (a < a) {
        let n: Nat satisfy { n != 0 and a + n = a }
        not add_identity(a, a + n)
        false
    }
}

theorem lt_acyclic(a: Nat, b: Nat) {
    not (a < b and b < a)
} 

theorem nat_is_acyclic {
    is_acyclic(Nat.lt)
}

instance Nat: Partial_Order {
    let lt = Nat.lt
}

theorem only_zero_lte_zero(a: Nat) {
    a <= 0 implies a = 0
} by {
    exists(n: Nat) { a + n = 0 }
}

theorem not_lt_zero(a: Nat) {
    not a < 0
} by {
    if a < 0 {
        a != 0
        false
    }
}

theorem zero_or_suc(a: Nat) {
    a = 0 or exists(b: Nat) { a = b + 1 }
}

theorem lt_cancel_suc(a: Nat, b: Nat) {
    a + 1 < b + 1 implies a < b
} by {
    let n: Nat satisfy {
        a + 1 + n = b + 1
    }
    suc_cancels(a + n, b)
    a + n = b
}

theorem lte_cancel_suc(a: Nat, b: Nat) { a + 1 <= b + 1 implies a <= b } 

theorem lt_and_lte(a: Nat, b: Nat, c: Nat) { a < b and b <= c implies a < c } 

theorem lte_and_lt(a: Nat, b: Nat, c: Nat) { a <= b and b < c implies a < c } 

theorem lte_trans(a: Nat, b: Nat, c: Nat) { a <= b and b <= c implies a <= c } 

theorem lt_suc_left(a: Nat, b: Nat) { 
    a < b implies a + 1 <= b 
} by {
    if a < b {    
        let (n: Nat) satisfy { a + n = b and n != 0 }
        let (m: Nat) satisfy { n = m + 1 }
        if m = 0 {
            a + 1 = b
        } else {
            m != 0
            a + m + 1 = b
            a + 1 < b
        }
        a + 1 <= b
    }
}

theorem lt_suc_right(a: Nat, b: Nat) { a < b + 1 implies a <= b } by {
    if a < b + 1 {
        let (n: Nat) satisfy { a + n = b + 1 and n != 0 }
        let (m: Nat) satisfy { n = m + 1 }
        a + m = b
        if m = 0 {
            a = b
        } else {
            a < b
        }
    } 
}

theorem lt_add_left(a: Nat, b: Nat, c: Nat) { 
    a < b implies a + c < b + c 
} by {
    let (n: Nat) satisfy { a + n = b }
    a + c + n = b + c
}

theorem trichotomy(a: Nat, b: Nat) { a < b or b < a or a = b } by {
    define f(x: Nat) -> Bool { trichotomy(a, x) }
    0 = a or 0 < a
    f(0)
    forall(x: Nat) {
        if f(x) {
            trichotomy(a, x)
            a < x or x < a or a = x
            if a <= x {
                a < x + 1
                trichotomy(a, x + 1)
            }
            if x < a {
                x + 1 <= a
                trichotomy(a, x + 1)
            }
            trichotomy(a, x + 1)
        }
    }
    trichotomy(a, b)
}

theorem nat_is_trichotomy {
    is_trichotomy(Nat.lt)
}

instance Nat: Linear_Order

theorem lt_suc_left_augment(a: Nat, b: Nat) { 
    a < b iff a + 1 <= b 
} by {
    a < b implies a + 1 <= b
    if a = b {
        a + 1 > b
    }
    if a > b {
        a + 1 > b
    }
}

theorem lt_suc_right_augment(a: Nat, b: Nat) { 
    a < b + 1 iff a <= b 
} by {
    a < b + 1 implies a <= b
    if a = b + 1 {
        a > b
    } 
    if a > b + 1 {
        a > b
    }
}

theorem gt_suc_left(a: Nat, b: Nat) { a + 1 > b iff a >= b } 

theorem gt_suc_right(a: Nat, b: Nat) { a > b implies a >= b + 1 } 

theorem division_theorem(m: Nat, n: Nat) {
    0 < n implies exists(q: Nat, r: Nat) {
        r < n and m = q * n + r
    }
} by {
    define f(x: Nat) -> Bool { division_theorem(x, n) }
    if 0 < n {
        0 = 0 * n + 0
    }
    division_theorem(0, n)
    f(0)
    forall(x: Nat) {
        if f(x) {
            division_theorem(x, n)
            let (q: Nat, r: Nat) satisfy {
                r < n and x = q * n + r
            }
            if r + 1 = n {
                x + 1 = (q * n + r) + 1
                x + 1 = q * n + (r + 1)
                x + 1 = q * n + n
                x + 1 = (q + 1) * n + 0
                division_theorem(x + 1, n)
            } else {
                r + 1 < n
                x + 1 = q * n + r + 1
                division_theorem(x + 1, n)
            }
            division_theorem(x + 1, n)
        }
    }
    division_theorem(m, n)
}

attributes Nat {
    define divides(self, a: Nat) -> Bool {
        a != 0 and exists(b: Nat) { 
            (1 < self and self < a) and
            self * b = a 
        }
    }
}

theorem mul_to_nonzero(a: Nat, b: Nat) { a != 0 and b != 0 implies a * b != 0 } by {
    let b_pred: Nat satisfy { b_pred + 1 = b }
    a * b = a * b_pred + a
} 

theorem mul_to_zero(a: Nat, b: Nat) { a * b = 0 implies a = 0 or b = 0 } 

theorem mul_increase(a: Nat, b: Nat) {
    a != 0 and 1 < b implies a < a * b
} by {
    let (b_pred: Nat) satisfy { b_pred + 1 = b and b_pred != 0 }
    a * b = a * b_pred + a
}

theorem factor_lt(a: Nat, b: Nat, n: Nat) {
    (n != 0 and a * b = n) implies a <= n
} by {
    if (n != 0 and a * b = n) {
        a != 0
        b != 0
        if b = 1 { a = n }
        if b > 1 { 
            a < a * b 
            a < n
        }
        a <= n
    }
}

theorem another_also_divides(n: Nat, a: Nat, b: Nat) {
    a.divides(n) and n = a * b implies b.divides(n) 
} by {
    if b = 0 { 
        n = 0 
        false
    }
    if b = 1 { 
        a = n
        false
    }
    if b >= n {
        let m: Nat satisfy { a = 1 + m and m != 0 }
        a * b = b + m * b
        m * b != 0
        a * b > n 
        false
    }
    1 < b and b < n
}

theorem divides_trans(a1: Nat, a2: Nat, a3: Nat) {
    a1.divides(a2) and a2.divides(a3) implies a1.divides(a3)
} by {
    let (b1: Nat) satisfy { a1 * b1 = a2 }
    let (b2: Nat) satisfy { a2 * b2 = a3 }
    a1 * (b1 * b2) = a3
}

// This is a "bounded" version of subtraction that returns 0 instead of negative numbers.
let bounded_sub(a: Nat, b: Nat) -> d: Nat satisfy {
    if a < b {
        d = 0
    } else {
        d + b = a
    }
} by {
    if a < b {
        0 = 0
    } else {
        b <= a
        let d: Nat satisfy { d + b = a }
    }
}

attributes Nat {
    /// Subtraction on natural numbers is defined oddly; it "caps out" at zero.
    /// If `self < b`, then `self - b = 0`.
    /// It would be better to define this as "not valid" on some inputs, but
    /// the language doesn't make that convenient yet.
    define sub(self, b: Nat) -> Nat { bounded_sub(self, b) }
}

attributes Nat {
    define factorial(self) -> Nat {
        match self {
            Nat.0 {
                1
            }
            Nat.suc(pred) {
                self * pred.factorial
            }
        }
    }
    let ! = Nat.factorial
}

theorem test_factorial { 
    3.! = 6 
} by {
    3.! = (3 * 2.!) 
    2.! = (2 * 1.!)
    1.! = 1
    2 * 1 = 2
    3 * 2 = (3 + 3)
    3 * 2 = 6
}

// 0 ~ n-1
// possibly related to stack overflow
define element_in_finite_index(n: Nat, a: Nat) -> Bool {
    if n = 0 { 
        false 
    } else { 
        a < n 
    }
}

from set import Set, Map, Product, empty, universe, cardinal_lt_power, is_surjective

theorem nat_power_set_uncountable(f: Nat -> Set[Nat]) {
    not is_surjective(f)
} by {
    cardinal_lt_power[Nat](f)
}

define finite_index(n: Nat) -> Set[Nat] {
    Set[Nat].new(element_in_finite_index(n))
}

theorem non_index_is_empty { finite_index(0) = empty[Nat] }

attributes Set[K] {
    define is_finite_set(self) -> Bool {
        if self = empty[K] {
            true
        } else {
            exists(num: Nat, m: Map[Nat, K]) {
                m.in_space = finite_index(num) and
                m.out_space = self and
                m.is_bijective
            }
        }
    }
}

// possibly related to stack overflow
// structure Finite[K] {
//     s: Set[K]
// } constraint {
//     s.is_finite_set
// } 