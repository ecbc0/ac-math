/// Natural numbers, the soul of arithmetic.
/// We build natural numbers from Acorn's inherent properties of inductive types.
inductive ℕ {
    /// Zero is a natural number, because it's much more convenient this way.
    0

    /// The successor of a natural number is also a natural number.
    suc(ℕ)
}

attributes ℕ {
    let 1: ℕ = ℕ.0.suc
    let 2: ℕ = ℕ.1.suc
    let 3: ℕ = ℕ.2.suc
    let 4: ℕ = ℕ.3.suc
    let 5: ℕ = ℕ.4.suc
    let 6: ℕ = ℕ.5.suc
    let 7: ℕ = ℕ.6.suc
    let 8: ℕ = ℕ.7.suc
    let 9: ℕ = ℕ.8.suc
    let 10: ℕ = ℕ.9.suc

    /// Addition is defined recursively.
    define add(self, other: ℕ) -> ℕ {
        match other {
            ℕ.0 {
                self
            }
            ℕ.suc(pred) {
                (self + pred).suc
            }
        }
    }
}

numerals ℕ

/// a + 0 = a is definition of `add`  
/// 0 + a = a is from most simple form of induction
theorem add_zero(a: ℕ) { a + 0 = a and 0 + a = a } 

theorem one_plus_one { 1 + 1 = 2 } by {
    1 + 0.suc = 1.suc
}

theorem add_one_right(a: ℕ) {
    a + 1 = a.suc
} by {
    a + 0.suc = (a + 0).suc
}

theorem add_suc(n1: ℕ, n2: ℕ) {
    n1 + n2.suc = n1.suc + n2
} by {
    define f(m: ℕ) -> Bool {
        (n1 + m.suc) = (n1.suc + m)
    }
    f(0)
    forall(m: ℕ) {
        if f(m) {
            // def of `add(n1, m.suc)`
            (n1 + (m.suc).suc) = (n1 + m.suc).suc
            // f(m)
            (n1 + m.suc).suc = (n1.suc + m).suc
            // def of `add(n1.suc, m.suc)`
            (n1.suc + m.suc) = (n1.suc + m).suc
            // induction on `m` success
            f(m.suc)
        }
    }
    f(n2)
}

theorem add_one_left(a: ℕ) {
    1 + a = a.suc
} by {
    add_suc(0, a)
    0.suc + a = (0 + a).suc
}

/// definition of add is commutative
theorem add_comm(a: ℕ, b: ℕ) { a + b = b + a } by {
    define f(n: ℕ) -> Bool { add_comm(a, n) }
    a + 0 = 0 + a
    add_comm(a, 0)
    f(0)
    forall(n: ℕ) {
        if f(n) {
            add_comm(a, n)
            a + n.suc = (a + n).suc
            // f(n)
            (a + n).suc = (n + a).suc
            // def of `add`
            n + a.suc = (n + a).suc
            add_suc(n, a)
            n + a.suc = n.suc + a
            // induction success
            add_comm(a, n.suc)
            f(n.suc)
        }
    }
    add_comm(a, b)
}

theorem add_assoc_one(a: ℕ, b: ℕ) { (a + b) + 1 = a + (b + 1) }

theorem add_assoc(a: ℕ, b: ℕ, c: ℕ) { (a + b) + c = a + (b + c) } by {
    define f(n: ℕ) -> Bool {
        add_assoc(a, b, n) // helper
    }
    f(0)
    forall(n: ℕ){
        if f(n) {
            f(n + 1)
        }
    }
    add_assoc(a, b, c)
}

attributes ℕ {
    /// Multiplication is defined recursively.
    define mul(self, b: ℕ) -> ℕ {
        match b {
            ℕ.0 {
                0
            }
            ℕ.suc(pred) {
                (self ⋅ pred) + self
            }
        }
    }

    /// The number formed by appending a digit to this one in base 10.
    define read(self, other: ℕ) -> ℕ {
        10 ⋅ self + other
    }
}

theorem mul_zero(a: ℕ) { a ⋅ 0 = 0 and 0 ⋅ a = 0 } // 0 ⋅ a = 0 by easy induction

theorem mul_suc_right(a: ℕ, b: ℕ) {
    a ⋅ (b + 1) = a ⋅ b + a 
}

theorem mul_suc_left(a: ℕ, b: ℕ) {
    (a + 1) ⋅ b = a ⋅ b + b
} by {
    define f(n: ℕ) -> Bool {
        (a + 1) ⋅ n = a ⋅ n + n
    }
    f(0)
    forall(n: ℕ) {
        if f(n) {
            (a + 1) ⋅ (n + 1) = (a + 1) ⋅ n + (a + 1)
            // f(n)
            (a + 1) ⋅ n + (a + 1) = (a ⋅ n + n) + (a + 1)
            // reorder and collect
            (a ⋅ n + a) + (n + 1) = (a ⋅ (n + 1)) + (n + 1)
            f(n + 1)
        }
    }
}

theorem mul_comm(a: ℕ, b: ℕ) { a ⋅ b = b ⋅ a } by {
    define f(n: ℕ) -> Bool { mul_comm(a, n) }
    a ⋅ 0 = 0 ⋅ a
    mul_comm(a, 0)
    f(0)
    forall(n: ℕ) {
        if f(n) {
            // def of mul
            a ⋅ (n + 1) = a ⋅ n + a
            // f(n) & add_comm
            a ⋅ n + a = n ⋅ a + a
            // mul_suc
            (n + 1) ⋅ a = n ⋅ a + a
            f(n + 1)
        }
    }
    f(b)
    mul_comm(a, b)
}

theorem one_mul_one { 1 ⋅ 1 = 1 } 

theorem distrib_right(a: ℕ, b: ℕ, c: ℕ) {
    a ⋅ (b + c) = a ⋅ b + a ⋅ c 
} by {
    define f(x: ℕ) -> Bool { distrib_right(a, b, x) }
    f(0)
    forall(x: ℕ) {
        if f(x) {
            distrib_right(a, b, x)
            a ⋅ (b + x) = a ⋅ b + a ⋅ x            
            mul_suc_right(a, b + x)
            distrib_right(a, b, x + 1)
        }
    }
    distrib_right(a, b, c)
}

theorem distrib_left(a: ℕ, b: ℕ, c: ℕ) {
    (a + b) ⋅ c = a ⋅ c + b ⋅ c
} // by mul_comm

theorem mul_assoc(a: ℕ, b: ℕ, c: ℕ) { (a ⋅ b) ⋅ c = a ⋅ (b ⋅ c) } by {
    define f(x: ℕ) -> Bool { mul_assoc(a, b, x) }
    f(0)
    forall(x: ℕ) {
        if f(x) {
            (a ⋅ b) ⋅ x = a ⋅ (b ⋅ x)
            mul_suc_right(a ⋅ b, x)
            f(x + 1)
        }
    }
    mul_assoc(a, b, c)
}

theorem mul_one_right(a: ℕ) { a ⋅ 1 = a } by {
    (a ⋅ 0) + a = a
}

theorem mul_one_left(a: ℕ) { 1 ⋅ a = a }

theorem suc_ne(a: ℕ) { a.suc != a } by {
    suc_ne(0) // by property of inductive
    forall(n: ℕ) {
        if suc_ne(n) {
            n.suc != n
            n.suc.suc != n.suc // by property of inductive
            suc_ne(n.suc)
        }
    }
    suc_ne(a)
}

theorem suc_cancels(a: ℕ, b: ℕ) { a + 1 = b + 1 implies a = b } by {
    if a != b {
        a.suc != b.suc // property of inductive
    }
}

/// 0 is the identity of add: 0 + n = n = n + 0
theorem add_identity_left(a: ℕ, b: ℕ) { a + b = b implies a = 0 } by {
    define f(x: ℕ) -> Bool { add_identity_left(a, x) }
    f(0)
    forall(x: ℕ) {
        if f(x) {
            suc_cancels(a + x, x)
            f(x + 1)
        }
    }
    add_identity_left(a, b)
}

theorem add_identity_right(a: ℕ, b: ℕ) { b + a = b implies a = 0 }

theorem add_cancels_right(a: ℕ, b: ℕ, c: ℕ) { a + c = b + c implies a = b } by {
    define f(n: ℕ) -> Bool { add_cancels_right(a, b, n) }
    f(0)
    forall(n: ℕ) {
        if f(n) {
            add_cancels_right(a, b, n)
            suc_cancels(a + n, b + n)
            add_cancels_right(a, b, n + 1)
        }
    }
    add_cancels_right(a, b, c)
}

theorem add_cancels_left(a: ℕ, b: ℕ, c: ℕ) { c + a = c + b implies a = b }

theorem suc_positive(n: ℕ) {
    n.suc != 0
} // by definition of inductive, "0 is not suc of any natural number"

theorem nonzero_add_to_nonzero(a: ℕ, b: ℕ) {
    (a != 0 or b != 0) implies a + b != 0
} by {
    if a != 0 {
        let n: ℕ satisfy { a = n + 1 }
        a + b = (n + b).suc
        a + b != 0
    }

    if b != 0 {
        let n: ℕ satisfy { b = n + 1 }
        a + b = (a + n).suc
        a + b != 0
    }
}

theorem add_to_zero(a: ℕ, b: ℕ) {
    a + b = 0 implies (a = 0 and b = 0)
} 

// Ordering

attributes ℕ {
    /// `a < b` if there's a positive natural number that can be added to `a` to get `b`.
    define lt(self, other: ℕ) -> Bool {
        exists(n: ℕ) {
            n != 0 and self + n = other
        }
    }
    define lte(self, other: ℕ) -> Bool {
        exists(c: ℕ) {
            self < other or self = other
        }
    }
    define gt(self, other: ℕ) -> Bool {
        other < self
    }
    define gte(self, other: ℕ) -> Bool {
        other <= self
    }
}

theorem non_zero_gte_one(n: ℕ) {
    n != 0 implies n >= 1
}

theorem lt_trans(a: ℕ, b: ℕ, c: ℕ) { a < b and b < c implies a < c } by {
    let n1: ℕ satisfy { a + n1 = b and n1 != 0 }
    let n2: ℕ satisfy { b + n2 = c and n1 != 0 }
    a + (n1 + n2) = c
    a < c
}

from order import Partial_Order, Linear_Order
from util import is_transitive, is_acyclic, is_trichotomy

theorem nat_is_transitive {
    is_transitive(ℕ.lt)
}

theorem lt_and_eq_is_different_thing(a: ℕ) {
    not (a < a)
} by {
    if (a < a) {
        let n: ℕ satisfy { n != 0 and a + n = a }
        not add_identity_right(a, a + n)
        false
    }
}

theorem lt_acyclic(a: ℕ, b: ℕ) {
    not (a < b and b < a)
} 

theorem nat_is_acyclic {
    is_acyclic(ℕ.lt)
}

instance ℕ: Partial_Order {
    let lt = ℕ.lt
}

theorem only_zero_lte_zero(a: ℕ) {
    a <= 0 implies a = 0
} by {
    exists(n: ℕ) { a + n = 0 }
}

theorem not_lt_zero(a: ℕ) {
    not a < 0
} by {
    if a < 0 {
        a != 0
        false
    }
}

theorem zero_or_suc(a: ℕ) {
    a = 0 or exists(b: ℕ) { a = b + 1 }
}

theorem lt_cancel_suc(a: ℕ, b: ℕ) {
    a + 1 < b + 1 implies a < b
} by {
    let n: ℕ satisfy {
        a + 1 + n = b + 1
    }
    suc_cancels(a + n, b)
    a + n = b
}

theorem lte_cancel_suc(a: ℕ, b: ℕ) { a + 1 <= b + 1 implies a <= b } 

theorem lt_and_lte(a: ℕ, b: ℕ, c: ℕ) { a < b and b <= c implies a < c } 

theorem lte_and_lt(a: ℕ, b: ℕ, c: ℕ) { a <= b and b < c implies a < c } 

theorem lte_trans(a: ℕ, b: ℕ, c: ℕ) { a <= b and b <= c implies a <= c } 

theorem lt_suc_left(a: ℕ, b: ℕ) { 
    a < b implies a + 1 <= b 
} by {
    if a < b {    
        let (n: ℕ) satisfy { a + n = b and n != 0 }
        let (m: ℕ) satisfy { n = m + 1 }
        if m = 0 {
            a + 1 = b
        } else {
            m != 0
            a + m + 1 = b
            a + 1 < b
        }
        a + 1 <= b
    }
}

theorem lt_suc_right(a: ℕ, b: ℕ) { a < b + 1 implies a <= b } by {
    if a < b + 1 {
        let (n: ℕ) satisfy { a + n = b + 1 and n != 0 }
        let (m: ℕ) satisfy { n = m + 1 }
        a + m = b
        if m = 0 {
            a = b
        } else {
            a < b
        }
    } 
}

theorem lt_add_left(a: ℕ, b: ℕ, c: ℕ) { 
    a < b implies a + c < b + c 
} by {
    let (n: ℕ) satisfy { a + n = b }
    a + c + n = b + c
}

theorem trichotomy(a: ℕ, b: ℕ) { a < b or b < a or a = b } by {
    define f(x: ℕ) -> Bool { trichotomy(a, x) }
    0 = a or 0 < a
    f(0)
    forall(x: ℕ) {
        if f(x) {
            trichotomy(a, x)
            a < x or x < a or a = x
            if a <= x {
                a < x + 1
                trichotomy(a, x + 1)
            }
            if x < a {
                x + 1 <= a
                trichotomy(a, x + 1)
            }
            trichotomy(a, x + 1)
        }
    }
    trichotomy(a, b)
}

theorem nat_is_trichotomy {
    is_trichotomy(ℕ.lt)
}

instance ℕ: Linear_Order

theorem lt_suc_left_augment(a: ℕ, b: ℕ) { 
    a < b iff a + 1 <= b 
} by {
    a < b implies a + 1 <= b
    if a = b {
        a + 1 > b
    }
    if a > b {
        a + 1 > b
    }
}

theorem lt_suc_right_augment(a: ℕ, b: ℕ) { 
    a < b + 1 iff a <= b 
} by {
    a < b + 1 implies a <= b
    if a = b + 1 {
        a > b
    } 
    if a > b + 1 {
        a > b
    }
}

theorem gt_suc_left(a: ℕ, b: ℕ) { a + 1 > b iff a >= b } 

theorem gt_suc_right(a: ℕ, b: ℕ) { a > b implies a >= b + 1 } 

theorem mul_to_nonzero(a: ℕ, b: ℕ) { 
    a != 0 and b != 0 implies a ⋅ b != 0 
} by {
    let b_pred: ℕ satisfy { b_pred + 1 = b }
    a ⋅ b = a ⋅ b_pred + a
} 

theorem mul_to_zero(a: ℕ, b: ℕ) { 
    a ⋅ b = 0 implies a = 0 or b = 0 
} 

theorem mul_to_zero_imp_rev(a: ℕ, b: ℕ) { 
    a = 0 or b = 0 implies a ⋅ b = 0  
}

theorem mul_increase(a: ℕ, b: ℕ) {
    a != 0 and 1 < b implies a < a ⋅ b
} by {
    let (b_pred: ℕ) satisfy { b_pred + 1 = b and b_pred != 0 }
    a ⋅ b = a ⋅ b_pred + a
}

theorem lt_imp_lt_suc(a: ℕ, b: ℕ) { 
    a <= b implies a < b + 1 
} by {
    let (c: ℕ) satisfy { a + c = b }
    a + (c + 1) = b + 1
    c + 1 != 0
}

theorem lt_mul_both_left(a: ℕ, b: ℕ, c: ℕ) { 
    a != 0 and b < c implies a ⋅ b < a ⋅ c 
} by {
    let (n: ℕ) satisfy { b + n = c and n != 0 }
    a ⋅ (b + n) = a ⋅ c
    a ⋅ b + a ⋅ n = a ⋅ c
    a ⋅ n != 0
    a ⋅ b < a ⋅ c
}

theorem lte_mul_both_left(a: ℕ, b: ℕ, c: ℕ) { 
    b <= c implies a ⋅ b <= a ⋅ c 
} by {
    let (n: ℕ) satisfy { b + n = c }
    a ⋅ (b + n) = a ⋅ c
    a ⋅ b + a ⋅ n = a ⋅ c
    a ⋅ b <= a ⋅ c
}

theorem gt_mul_both_left(a: ℕ, b: ℕ, c: ℕ) { 
    a != 0 and b > c implies a ⋅ b > a ⋅ c 
} 

theorem gte_mul_both_left(a: ℕ, b: ℕ, c: ℕ) { 
    b >= c implies a ⋅ b >= a ⋅ c 
}

// helper for proof search
theorem lt_mul_both_right(a: ℕ, b: ℕ, c: ℕ) { 
    a != 0 and b < c implies b ⋅ a < c ⋅ a 
}

theorem lte_mul_both_right(a: ℕ, b: ℕ, c: ℕ) { 
    b <= c implies b ⋅ a <= c ⋅ a 
}

theorem gt_mul_both_right(a: ℕ, b: ℕ, c: ℕ) { 
    a != 0 and b > c implies b ⋅ a > c ⋅ a 
}

theorem gte_mul_both_right(a: ℕ, b: ℕ, c: ℕ) { 
    b >= c implies b ⋅ a >= c ⋅ a 
}

theorem lt_cancel_mul(a: ℕ, b: ℕ, c: ℕ) { 
    a != 0 and a ⋅ b < a ⋅ c implies b < c 
} by {
    if b >= c {
        a ⋅ c <= a ⋅ b
        false
    }
}

theorem lte_cancel_mul(a: ℕ, b: ℕ, c: ℕ) { 
    a != 0 and a ⋅ b <= a ⋅ c implies b <= c 
} by {
    if b > c {
        a ⋅ c > a ⋅ b
        false
    }
}

theorem mul_preserve_gt_one(a: ℕ, b: ℕ) {
    a > 1 and b > 1 implies a ⋅ b > 1
}

theorem mul_identity(a: ℕ, b: ℕ) {
    b != 0 and a ⋅ b = b implies a = 1
} by {
    b = 1 ⋅ b
    a <= 1
    a >= 1
    a = 1
}

theorem mul_cancel(a: ℕ, b: ℕ, c: ℕ) {
    a != 0 and a ⋅ b = a ⋅ c implies b = c
} 

theorem mul_to_one(a: ℕ, b: ℕ) { 
    a ⋅ b = 1 implies a = 1 and b = 1
} by {
    1 != 0
    a != 0
    b != 0
    if a > 1 {
        a ⋅ b > 1 ⋅ b
        a ⋅ b > b
        false
    }
    a = 1
    b = 1
}

theorem lte_mul(a: ℕ, b: ℕ) { b != 0 implies a <= a ⋅ b } by {
    not b < 0.suc
    not (b < 1)
    1 <= b
    a ⋅ 1 <= a ⋅ b
}

theorem cross_sum_lte(a1: ℕ, a2: ℕ, b1: ℕ, b2: ℕ) { a1 + b1 = a2 + b2 and a1 <= a2 implies b2 <= b1 } by {
    let (n: ℕ) satisfy { a1 + n = a2 }
    a1 + b1 = a1 + n + b2
    a1 + b1 = a1 + (n + b2)
    b1 = n + b2
    b2 <= b1
}

// This is a "bounded" version of subtraction that returns 0 instead of negative numbers.
let bounded_sub(a: ℕ, b: ℕ) -> n: ℕ satisfy {
    if a < b {
        n = 0
    } else {
        n + b = a
    }
} by {
    if a < b {
        0 = 0
    } else {
        b <= a
        let n: ℕ satisfy { n + b = a }
    }
}

attributes ℕ {
    /// Subtraction on natural numbers is defined oddly; it "caps out" at zero.
    /// If `self < b`, then `self - b = 0`.
    /// It would be better to define this as "not valid" on some inputs, but
    /// the language doesn't make that convenient yet.
    define sub(self, b: ℕ) -> ℕ { bounded_sub(self, b) }
}

theorem sub_lt(a: ℕ, b: ℕ) { a < b implies a - b = 0 }

theorem add_sub_left(a: ℕ, b: ℕ) {
    b <= a implies (a - b) + b = a
} 

theorem add_sub_right(a: ℕ, b: ℕ) { 
    (a + b) - b = a 
} by {
    b <= a + b
    ((a + b) - b) + b = a + b
}

theorem add_sub_comm_add(a: ℕ, b: ℕ, c: ℕ) {
    b >= c implies (a + b) - c = a + (b - c) 
} by {
    a + (b - c) + c = a + b
}

theorem add_sub_comm_sub(a: ℕ, b: ℕ, c: ℕ) {
    a >= c implies (a + b) - c = (a - c) + b 
} 

theorem sub_decrease(a: ℕ, b: ℕ) {
    a - b <= a
} by {
    if a < b { 
        a - b = 0
        0 <= a 
        a - b <= a
    }
    if a >= b { 
        (a - b) + b = a 
        a - b <= a
    }
}

theorem sub_self(a: ℕ) { a - a = 0 }

theorem sub_zero(a: ℕ) { a - 0 = a }

theorem add_imp_sub(a: ℕ, b: ℕ, c: ℕ) { a + b = c implies c - b = a }

theorem sub_distrib_right(a: ℕ, b: ℕ, c: ℕ) {
    a ⋅ (b - c) = a ⋅ b - a ⋅ c
} by {
    if a = 0 {
        a ⋅ (b - c) = a ⋅ b - a ⋅ c
        sub_distrib_right(a, b, c)
    } else {
        if b < c {
            a ⋅ b < a ⋅ c
            a ⋅ b - a ⋅ c = 0
            b - c = 0
            a ⋅ (b - c) = a ⋅ b - a ⋅ c
            sub_distrib_right(a, b, c)
        }
        if not (b < c) {
            b - c + c = b
            a ⋅ (b - c) + a ⋅ c = a ⋅ b
            a ⋅ (b - c) = a ⋅ b - a ⋅ c
            sub_distrib_right(a, b, c)
        }
        sub_distrib_right(a, b, c)
    }
    sub_distrib_right(a, b, c)
}

theorem sub_distrib_left(a: ℕ, b: ℕ, c: ℕ) {
    (a - b) ⋅ c = a ⋅ c - b ⋅ c
} 

// Misc helpers
theorem two_neq_zero {
    2 != 0
}
theorem three_neq_zero {
    3 != 0
}

attributes ℕ {
    /// Note that 0^0 = 1.
    define pow(self, b: ℕ) -> ℕ {
        match b {
            ℕ.0 {
                1
            }
            ℕ.suc(pred) {
                self ⋅ self.pow(pred)
            }
        }
    }
}

theorem pow_zero(a: ℕ) {
    a^0 = 1
}

theorem pow_one(a: ℕ) {
    a^1 = a
} by {
    a^1 = a ⋅ a^0
    a^0 = 1
}

theorem pow_add(a: ℕ, b: ℕ, c: ℕ) {
    a^(b + c) = a^b ⋅ a^c
} by {
    // Inductive step
    let f: ℕ -> Bool = function(x: ℕ) {
        a^(b + x) = a^b ⋅ a^x
    }
    f(0)
    forall(x: ℕ) {
        if f(x) {
            a^(b + x) = a^b ⋅ a^x
            
            b + (x + 1) = (b + x) + 1

            a^((b + x) + 1) = a^b ⋅ (a^x ⋅ a^1)

            f(x + 1)
        }
    }
    f(c)
}

theorem pow_mul(a: ℕ, b: ℕ, c: ℕ) {
    a^(b ⋅ c) = (a^b)^c
} by {
    // Inductive step
    let f: ℕ -> Bool = function(x: ℕ) {
        a^(b ⋅ x) = (a^b)^x
    }
    f(0)
    forall(x: ℕ) {
        if f(x) {
            a^(b ⋅ x) = (a^b)^x
            b ⋅ (x + 1) = b ⋅ x + b
            a^(b ⋅ (x + 1)) = a^(b ⋅ x) ⋅ a^b
            a^b = (a^b)^1
            a^(b ⋅ (x + 1)) = (a^b)^(x + 1)
            f(x + 1)
        }
    }
    f(c)
}

theorem zero_pow(n: ℕ) {
    n != 0 implies 0^n = 0
} by {
    let b: ℕ satisfy {
        n = b.suc
    } // 0^(b.suc) = 0^b ⋅ 0^1 with 0^1 = 0
}

theorem one_pow(n: ℕ) {
    1^n = 1
} by {
    one_pow(0)
    one_pow(n) // induction 1^n = 1^(n - 1) ⋅ 1 with 1^(n - 1) = 1
}

theorem pow_gte_one(a: ℕ, b: ℕ) {
    a != 0 implies 1 <= a^b
} by {
    // Induction step
    let f: ℕ -> Bool = function(x: ℕ) {
        1 <= a^x
    }
    f(0)
    forall(x: ℕ) {
        if f(x) {
            1 <= a^x
            a^x <= a^(x + 1)
            1 <= a^(x + 1)
            f(x + 1)
        }
    }
    f(b)
}

theorem pow_gt_one(a: ℕ, b: ℕ) {
    1 < a and b != 0 implies 1 < a^b
} by {
    let b_pred: ℕ satisfy {
        b = b_pred + 1
    }
    a^b = a ⋅ a^(b_pred)
    a^(b_pred) >= 1
    a > 1
    a ⋅ a^(b_pred) > 1
    a^b > 1
}

theorem pow_ne_zero(a: ℕ, b: ℕ) {
    a != 0 implies a^b != 0
} by {
    1 <= a^b
}

theorem lt_imp_pow_lt(a: ℕ, b1: ℕ, b2: ℕ) {
    1 < a and b1 < b2 implies a^b1 < a^b2
} by {
    let n: ℕ satisfy {
        b1 + n = b2 and n != 0
    }
    a^b2 = a^b1 ⋅ a^n
    a^b1 != 0
    1 < a
    1 < a^n
    a^b2 > a^b1
}

theorem lte_imp_pow_lte(a: ℕ, b1: ℕ, b2: ℕ) {
    a != 0 and b1 <= b2 implies a^b1 <= a^b2
} by {
    let n: ℕ satisfy {
        b1 + n = b2
    }
    a^b2 = a^b1 ⋅ a^n
    a^n != 0
    a^b2 >= a^b1
}

theorem lte_pow(a: ℕ, b: ℕ) {
    a != 0 and b != 0 implies a <= a^b
}

theorem pow_lt_imp_lt(a: ℕ, b1: ℕ, b2: ℕ) {
    1 < a and a^b1 < a^b2
    implies
    b1 < b2
}

theorem pow_lte_imp_lte(a: ℕ, b1: ℕ, b2: ℕ) {
    1 < a and a^b1 <= a^b2
    implies
    b1 <= b2
}

theorem pow_eq_one_imp(a: ℕ, b: ℕ) {
    a != 1 and a^b = 1 implies b = 0
} by {
    if b != 0 {
        let b_pred: ℕ satisfy {
            b = b_pred + 1
        }
        a^b = a ⋅ a^(b_pred)
        a^b != 1
        false
    }
}

theorem sq_eq_mul(a: ℕ) {
    a^2 = a ⋅ a
}

define true_below(f: ℕ -> Bool, n: ℕ) -> Bool {
    forall(x: ℕ) { x < n implies f(x) }
}

theorem strong_induction(f: ℕ -> Bool) {
    forall(k: ℕ) {
        true_below(f, k) implies f(k)
    } implies forall(n: ℕ) { f(n) }
} by {
    // under "strong_induction" assumption: 
    //     forall(k: ℕ) {
    //       true_below(f, k) => f(k)
    //     }
    // try to prove that 
    //     true_below(f, x) => true_below(f, x.suc)
    // then by induction, we get 
    //     forall(x: ℕ) { true_below(f, x) }
    // then obviously 
    //     forall(n: ℕ) { f(n) }
    define g(x: ℕ) -> Bool {
        true_below(f, x)
    }
    true_below(f, 0)
    g(0)
    forall(x: ℕ) {
        if g(x) {
            true_below(f, x)
            f(x)
            forall(y: ℕ) {
                if y < x.suc {
                    if y < x {
                        f(y)
                    }
                    if not (y < x) {
                        y = x
                        f(y)
                    }
                    f(y)
                }
            }
            true_below(f, x.suc)
            g(x.suc)
        }
    }
    forall(x: ℕ) {
        g(x)
    }
    forall(n: ℕ) {
        g(n.suc)
        true_below(f, n.suc)
        f(n)
    }
}

theorem gte_each_of_three(a: ℕ, b: ℕ, c: ℕ) {
    exists(n: ℕ) {
        a <= n and b <= n and c <= n
    }
} by {
    let n: ℕ = a + b + c
    a <= n 
    b <= n
    c <= n
}

theorem gt_each_of_three(a: ℕ, b: ℕ, c: ℕ) {
    exists(n: ℕ) {
        a < n and b < n and c < n
    }
} by {
    let n: ℕ = (a + b + c) + 1
    a < n
    b < n
    c < n
}

// Single-digit addition facts should probably just be theorems.
theorem one_plus_two {
    1 + 2 = 3
}

theorem one_plus_three {
    1 + 3 = 4
}

theorem one_plus_four {
    1 + 4 = 5
}

theorem one_plus_five {
    1 + 5 = 6
}

theorem one_plus_six {
    1 + 6 = 7
}

theorem one_plus_seven {
    1 + 7 = 8
}

theorem one_plus_eight {
    1 + 8 = 9
}

theorem one_plus_nine {
    1 + 9 = 10
}

theorem one_sub_one {
    1 - 1 = 0
}

theorem two_sub_one {
    2 - 1 = 1
}

theorem three_sub_one {
    3 - 1 = 2
}

theorem four_sub_one {
    4 - 1 = 3
}

theorem five_sub_one {
    5 - 1 = 4
}

theorem six_sub_one {
    6 - 1 = 5
}

theorem seven_sub_one {
    7 - 1 = 6
}

theorem eight_sub_one {
    8 - 1 = 7
}

theorem nine_sub_one {
    9 - 1 = 8
}

theorem ten_sub_one {
    10 - 1 = 9
}

from set import Set, is_surjective, cardinal_lt_power

theorem nat_power_set_uncountable(f: ℕ -> Set[ℕ]) {
    not is_surjective(f)
} by {
    cardinal_lt_power[ℕ](f)
}