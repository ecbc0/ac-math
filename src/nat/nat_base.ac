/// Natural numbers, the soul of arithmetic.
/// We build natural numbers from Acorn's inherent properties of inductive types.
inductive Nat {
    /// Zero is a natural number, because it's much more convenient this way.
    0

    /// The successor of a natural number is also a natural number.
    suc(Nat)
}

attributes Nat {
    let 1: Nat = Nat.0.suc
    let 2: Nat = Nat.1.suc
    let 3: Nat = Nat.2.suc
    let 4: Nat = Nat.3.suc
    let 5: Nat = Nat.4.suc
    let 6: Nat = Nat.5.suc
    let 7: Nat = Nat.6.suc
    let 8: Nat = Nat.7.suc
    let 9: Nat = Nat.8.suc
    let 10: Nat = Nat.9.suc

    /// Addition is defined recursively.
    define add(self, other: Nat) -> Nat {
        match other {
            Nat.0 {
                self
            }
            Nat.suc(pred) {
                (self + pred).suc
            }
        }
    }
}

numerals Nat

/// a + 0 = a is definition of `add`  
/// 0 + a = a is from most simple form of induction
theorem add_zero(a: Nat) { a + 0 = a and 0 + a = a } 

theorem one_plus_one { 1 + 1 = 2 } by {
    1 + 0.suc = 1.suc
}

theorem add_one_right(a: Nat) {
    a + 1 = a.suc
} by {
    a + 0.suc = (a + 0).suc
}

theorem add_suc(n1: Nat, n2: Nat) {
    n1 + n2.suc = n1.suc + n2
} by {
    define f(m: Nat) -> Bool {
        (n1 + m.suc) = (n1.suc + m)
    }
    f(0)
    forall(m: Nat) {
        if f(m) {
            // def of `add(n1, m.suc)`
            (n1 + (m.suc).suc) = (n1 + m.suc).suc
            // f(m)
            (n1 + m.suc).suc = (n1.suc + m).suc
            // def of `add(n1.suc, m.suc)`
            (n1.suc + m.suc) = (n1.suc + m).suc
            // induction on `m` success
            f(m.suc)
        }
    }
    f(n2)
}

theorem add_one_left(a: Nat) {
    1 + a = a.suc
} by {
    add_suc(0, a)
    0.suc + a = (0 + a).suc
}

/// definition of add is commutative
theorem add_comm(a: Nat, b: Nat) { a + b = b + a } by {
    define f(n: Nat) -> Bool { add_comm(a, n) }
    a + 0 = 0 + a
    add_comm(a, 0)
    f(0)
    forall(n: Nat) {
        if f(n) {
            add_comm(a, n)
            a + n.suc = (a + n).suc
            // f(n)
            (a + n).suc = (n + a).suc
            // def of `add`
            n + a.suc = (n + a).suc
            add_suc(n, a)
            n + a.suc = n.suc + a
            // induction success
            add_comm(a, n.suc)
            f(n.suc)
        }
    }
    add_comm(a, b)
}

theorem add_assoc_one(a: Nat, b: Nat) { (a + b) + 1 = a + (b + 1) }

theorem add_assoc(a: Nat, b: Nat, c: Nat) { (a + b) + c = a + (b + c) } by {
    define f(n: Nat) -> Bool {
        add_assoc(a, b, n) // helper
    }
    f(0)
    forall(n: Nat){
        if f(n) {
            f(n + 1)
        }
    }
    add_assoc(a, b, c)
}

attributes Nat {
    /// Multiplication is defined recursively.
    define mul(self, b: Nat) -> Nat {
        match b {
            Nat.0 {
                0
            }
            Nat.suc(pred) {
                (self * pred) + self
            }
        }
    }

    /// The number formed by appending a digit to this one in base 10.
    define read(self, other: Nat) -> Nat {
        10 * self + other
    }
}

theorem mul_zero(a: Nat) { a * 0 = 0 and 0 * a = 0 } // 0 * a = 0 by easy induction

theorem mul_suc_right(a: Nat, b: Nat) {
    a * (b + 1) = a * b + a 
}

theorem mul_suc_left(a: Nat, b: Nat) {
    (a + 1) * b = a * b + b
} by {
    define f(n: Nat) -> Bool {
        (a + 1) * n = a * n + n
    }
    f(0)
    forall(n: Nat) {
        if f(n) {
            (a + 1) * (n + 1) = (a + 1) * n + (a + 1)
            // f(n)
            (a + 1) * n + (a + 1) = (a * n + n) + (a + 1)
            // reorder and collect
            (a * n + a) + (n + 1) = (a * (n + 1)) + (n + 1)
            f(n + 1)
        }
    }
}

theorem mul_comm(a: Nat, b: Nat) { a * b = b * a } by {
    define f(n: Nat) -> Bool { mul_comm(a, n) }
    a * 0 = 0 * a
    mul_comm(a, 0)
    f(0)
    forall(n: Nat) {
        if f(n) {
            // def of mul
            a * (n + 1) = a * n + a
            // f(n) & add_comm
            a * n + a = n * a + a
            // mul_suc
            (n + 1) * a = n * a + a
            f(n + 1)
        }
    }
    f(b)
    mul_comm(a, b)
}

theorem one_mul_one { 1 * 1 = 1 } 

theorem distrib_right(a: Nat, b: Nat, c: Nat) {
    a * (b + c) = a * b + a * c 
} by {
    define f(x: Nat) -> Bool { distrib_right(a, b, x) }
    f(0)
    forall(x: Nat) {
        if f(x) {
            distrib_right(a, b, x)
            a * (b + x) = a * b + a * x            
            mul_suc_right(a, b + x)
            distrib_right(a, b, x + 1)
        }
    }
    distrib_right(a, b, c)
}

theorem distrib_left(a: Nat, b: Nat, c: Nat) {
    (a + b) * c = a * c + b * c
} // by mul_comm

theorem mul_assoc(a: Nat, b: Nat, c: Nat) { (a * b) * c = a * (b * c) } by {
    define f(x: Nat) -> Bool { mul_assoc(a, b, x) }
    f(0)
    forall(x: Nat) {
        if f(x) {
            (a * b) * x = a * (b * x)
            mul_suc_right(a * b, x)
            f(x + 1)
        }
    }
    mul_assoc(a, b, c)
}

theorem mul_one_right(a: Nat) { a * 1 = a } by {
    (a * 0) + a = a
}

theorem mul_one_left(a: Nat) { 1 * a = a }

theorem suc_ne(a: Nat) { a.suc != a } by {
    suc_ne(0) // by property of inductive
    forall(n: Nat) {
        if suc_ne(n) {
            n.suc != n
            n.suc.suc != n.suc // by property of inductive
            suc_ne(n.suc)
        }
    }
    suc_ne(a)
}

theorem suc_cancels(a: Nat, b: Nat) { a + 1 = b + 1 implies a = b } by {
    if a != b {
        a.suc != b.suc // property of inductive
    }
}

/// 0 is the identity of add: 0 + n = n = n + 0
theorem add_identity_left(a: Nat, b: Nat) { a + b = b implies a = 0 } by {
    define f(x: Nat) -> Bool { add_identity_left(a, x) }
    f(0)
    forall(x: Nat) {
        if f(x) {
            suc_cancels(a + x, x)
            f(x + 1)
        }
    }
    add_identity_left(a, b)
}

theorem add_identity_right(a: Nat, b: Nat) { b + a = b implies a = 0 }

theorem add_cancels_right(a: Nat, b: Nat, c: Nat) { a + c = b + c implies a = b } by {
    define f(n: Nat) -> Bool { add_cancels_right(a, b, n) }
    f(0)
    forall(n: Nat) {
        if f(n) {
            add_cancels_right(a, b, n)
            suc_cancels(a + n, b + n)
            add_cancels_right(a, b, n + 1)
        }
    }
    add_cancels_right(a, b, c)
}

theorem add_cancels_left(a: Nat, b: Nat, c: Nat) { c + a = c + b implies a = b }

theorem suc_positive(n: Nat) {
    n.suc != 0
} // by definition of inductive, "0 is not suc of any natural number"

theorem nonzero_add_to_nonzero(a: Nat, b: Nat) {
    (a != 0 or b != 0) implies a + b != 0
} by {
    if a != 0 {
        let n: Nat satisfy { a = n + 1 }
        a + b = (n + b).suc
        a + b != 0
    }

    if b != 0 {
        let n: Nat satisfy { b = n + 1 }
        a + b = (a + n).suc
        a + b != 0
    }
}

theorem add_to_zero(a: Nat, b: Nat) {
    a + b = 0 implies (a = 0 and b = 0)
} 

// Ordering

attributes Nat {
    /// `a < b` if there's a positive natural number that can be added to `a` to get `b`.
    define lt(self, other: Nat) -> Bool {
        exists(n: Nat) {
            n != 0 and self + n = other
        }
    }
    define lte(self, other: Nat) -> Bool {
        exists(c: Nat) {
            self < other or self = other
        }
    }
    define gt(self, other: Nat) -> Bool {
        other < self
    }
    define gte(self, other: Nat) -> Bool {
        other <= self
    }
}

theorem non_zero_gte_one(n: Nat) {
    n != 0 implies n >= 1
}

theorem lt_trans(a: Nat, b: Nat, c: Nat) { a < b and b < c implies a < c } by {
    let n1: Nat satisfy { a + n1 = b and n1 != 0 }
    let n2: Nat satisfy { b + n2 = c and n1 != 0 }
    a + (n1 + n2) = c
    a < c
}

from order import Partial_Order, Linear_Order
from util import is_transitive, is_acyclic, is_trichotomy

theorem nat_is_transitive {
    is_transitive(Nat.lt)
}

theorem lt_and_eq_is_different_thing(a: Nat) {
    not (a < a)
} by {
    if (a < a) {
        let n: Nat satisfy { n != 0 and a + n = a }
        not add_identity_right(a, a + n)
        false
    }
}

theorem lt_acyclic(a: Nat, b: Nat) {
    not (a < b and b < a)
} 

theorem nat_is_acyclic {
    is_acyclic(Nat.lt)
}

instance Nat: Partial_Order {
    let lt = Nat.lt
}

theorem only_zero_lte_zero(a: Nat) {
    a <= 0 implies a = 0
} by {
    exists(n: Nat) { a + n = 0 }
}

theorem not_lt_zero(a: Nat) {
    not a < 0
} by {
    if a < 0 {
        a != 0
        false
    }
}

theorem zero_or_suc(a: Nat) {
    a = 0 or exists(b: Nat) { a = b + 1 }
}

theorem lt_cancel_suc(a: Nat, b: Nat) {
    a + 1 < b + 1 implies a < b
} by {
    let n: Nat satisfy {
        a + 1 + n = b + 1
    }
    suc_cancels(a + n, b)
    a + n = b
}

theorem lte_cancel_suc(a: Nat, b: Nat) { a + 1 <= b + 1 implies a <= b } 

theorem lt_and_lte(a: Nat, b: Nat, c: Nat) { a < b and b <= c implies a < c } 

theorem lte_and_lt(a: Nat, b: Nat, c: Nat) { a <= b and b < c implies a < c } 

theorem lte_trans(a: Nat, b: Nat, c: Nat) { a <= b and b <= c implies a <= c } 

theorem lt_suc_left(a: Nat, b: Nat) { 
    a < b implies a + 1 <= b 
} by {
    if a < b {    
        let (n: Nat) satisfy { a + n = b and n != 0 }
        let (m: Nat) satisfy { n = m + 1 }
        if m = 0 {
            a + 1 = b
        } else {
            m != 0
            a + m + 1 = b
            a + 1 < b
        }
        a + 1 <= b
    }
}

theorem lt_suc_right(a: Nat, b: Nat) { a < b + 1 implies a <= b } by {
    if a < b + 1 {
        let (n: Nat) satisfy { a + n = b + 1 and n != 0 }
        let (m: Nat) satisfy { n = m + 1 }
        a + m = b
        if m = 0 {
            a = b
        } else {
            a < b
        }
    } 
}

theorem lt_add_left(a: Nat, b: Nat, c: Nat) { 
    a < b implies a + c < b + c 
} by {
    let (n: Nat) satisfy { a + n = b }
    a + c + n = b + c
}

theorem trichotomy(a: Nat, b: Nat) { a < b or b < a or a = b } by {
    define f(x: Nat) -> Bool { trichotomy(a, x) }
    0 = a or 0 < a
    f(0)
    forall(x: Nat) {
        if f(x) {
            trichotomy(a, x)
            a < x or x < a or a = x
            if a <= x {
                a < x + 1
                trichotomy(a, x + 1)
            }
            if x < a {
                x + 1 <= a
                trichotomy(a, x + 1)
            }
            trichotomy(a, x + 1)
        }
    }
    trichotomy(a, b)
}

theorem nat_is_trichotomy {
    is_trichotomy(Nat.lt)
}

instance Nat: Linear_Order

theorem lt_suc_left_augment(a: Nat, b: Nat) { 
    a < b iff a + 1 <= b 
} by {
    a < b implies a + 1 <= b
    if a = b {
        a + 1 > b
    }
    if a > b {
        a + 1 > b
    }
}

theorem lt_suc_right_augment(a: Nat, b: Nat) { 
    a < b + 1 iff a <= b 
} by {
    a < b + 1 implies a <= b
    if a = b + 1 {
        a > b
    } 
    if a > b + 1 {
        a > b
    }
}

theorem gt_suc_left(a: Nat, b: Nat) { a + 1 > b iff a >= b } 

theorem gt_suc_right(a: Nat, b: Nat) { a > b implies a >= b + 1 } 

theorem mul_to_nonzero(a: Nat, b: Nat) { 
    a != 0 and b != 0 implies a * b != 0 
} by {
    let b_pred: Nat satisfy { b_pred + 1 = b }
    a * b = a * b_pred + a
} 

theorem mul_to_zero(a: Nat, b: Nat) { 
    a * b = 0 implies a = 0 or b = 0 
} 

theorem mul_increase(a: Nat, b: Nat) {
    a != 0 and 1 < b implies a < a * b
} by {
    let (b_pred: Nat) satisfy { b_pred + 1 = b and b_pred != 0 }
    a * b = a * b_pred + a
}

theorem lt_imp_lt_suc(a: Nat, b: Nat) { 
    a <= b implies a < b + 1 
} by {
    let (c: Nat) satisfy { a + c = b }
    a + (c + 1) = b + 1
    c + 1 != 0
}

theorem lt_mul_both_left(a: Nat, b: Nat, c: Nat) { 
    a != 0 and b < c implies a * b < a * c 
} by {
    let (n: Nat) satisfy { b + n = c and n != 0 }
    a * (b + n) = a * c
    a * b + a * n = a * c
    a * n != 0
    a * b < a * c
}

theorem lte_mul_both_left(a: Nat, b: Nat, c: Nat) { 
    b <= c implies a * b <= a * c 
} by {
    let (n: Nat) satisfy { b + n = c }
    a * (b + n) = a * c
    a * b + a * n = a * c
    a * b <= a * c
}

theorem gt_mul_both_left(a: Nat, b: Nat, c: Nat) { 
    a != 0 and b > c implies a * b > a * c 
} 

theorem gte_mul_both_left(a: Nat, b: Nat, c: Nat) { 
    b >= c implies a * b >= a * c 
}

// helper for proof search
theorem lt_mul_both_right(a: Nat, b: Nat, c: Nat) { 
    a != 0 and b < c implies b * a < c * a 
}

theorem lte_mul_both_right(a: Nat, b: Nat, c: Nat) { 
    b <= c implies b * a <= c * a 
}

theorem gt_mul_both_right(a: Nat, b: Nat, c: Nat) { 
    a != 0 and b > c implies b * a > c * a 
}

theorem gte_mul_both_right(a: Nat, b: Nat, c: Nat) { 
    b >= c implies b * a >= c * a 
}

theorem lt_cancel_mul(a: Nat, b: Nat, c: Nat) { 
    a != 0 and a * b < a * c implies b < c 
} by {
    if b >= c {
        a * c <= a * b
        false
    }
}

theorem lte_cancel_mul(a: Nat, b: Nat, c: Nat) { 
    a != 0 and a * b <= a * c implies b <= c 
} by {
    if b > c {
        a * c > a * b
        false
    }
}

theorem mul_preserve_gt_one(a: Nat, b: Nat) {
    a > 1 and b > 1 implies a * b > 1
}

theorem mul_identity(a: Nat, b: Nat) {
    b != 0 and a * b = b implies a = 1
} by {
    b = 1 * b
    a <= 1
    a >= 1
    a = 1
}

theorem mul_cancel(a: Nat, b: Nat, c: Nat) {
    a != 0 and a * b = a * c implies b = c
} 

theorem mul_to_one(a: Nat, b: Nat) { 
    a * b = 1 implies a = 1 and b = 1
} by {
    1 != 0
    a != 0
    b != 0
    if a > 1 {
        a * b > 1 * b
        a * b > b
        false
    }
    a = 1
    b = 1
}

theorem lte_mul(a: Nat, b: Nat) { b != 0 implies a <= a * b } by {
    not b < 0.suc
    not (b < 1)
    1 <= b
    a * 1 <= a * b
}

theorem cross_sum_lte(a1: Nat, a2: Nat, b1: Nat, b2: Nat) { a1 + b1 = a2 + b2 and a1 <= a2 implies b2 <= b1 } by {
    let (n: Nat) satisfy { a1 + n = a2 }
    a1 + b1 = a1 + n + b2
    a1 + b1 = a1 + (n + b2)
    b1 = n + b2
    b2 <= b1
}

// This is a "bounded" version of subtraction that returns 0 instead of negative numbers.
let bounded_sub(a: Nat, b: Nat) -> n: Nat satisfy {
    if a < b {
        n = 0
    } else {
        n + b = a
    }
} by {
    if a < b {
        0 = 0
    } else {
        b <= a
        let n: Nat satisfy { n + b = a }
    }
}

attributes Nat {
    /// Subtraction on natural numbers is defined oddly; it "caps out" at zero.
    /// If `self < b`, then `self - b = 0`.
    /// It would be better to define this as "not valid" on some inputs, but
    /// the language doesn't make that convenient yet.
    define sub(self, b: Nat) -> Nat { bounded_sub(self, b) }
}

theorem sub_lt(a: Nat, b: Nat) { a < b implies a - b = 0 }

theorem add_sub_left(a: Nat, b: Nat) {
    b <= a implies (a - b) + b = a
} 

theorem add_sub_right(a: Nat, b: Nat) { 
    (a + b) - b = a 
} by {
    b <= a + b
    ((a + b) - b) + b = a + b
}

theorem add_sub_comm_add(a: Nat, b: Nat, c: Nat) {
    b >= c implies (a + b) - c = a + (b - c) 
} by {
    a + (b - c) + c = a + b
}

theorem add_sub_comm_sub(a: Nat, b: Nat, c: Nat) {
    a >= c implies (a + b) - c = (a - c) + b 
} 

theorem sub_decrease(a: Nat, b: Nat) {
    a - b <= a
} by {
    if a < b { 
        a - b = 0
        0 <= a 
        a - b <= a
    }
    if a >= b { 
        (a - b) + b = a 
        a - b <= a
    }
}

theorem sub_self(a: Nat) { a - a = 0 }

theorem sub_zero(a: Nat) { a - 0 = a }

theorem add_imp_sub(a: Nat, b: Nat, c: Nat) { a + b = c implies c - b = a }

theorem sub_distrib_right(a: Nat, b: Nat, c: Nat) {
    a * (b - c) = a * b - a * c
} by {
    if a = 0 {
        a * (b - c) = a * b - a * c
        sub_distrib_right(a, b, c)
    } else {
        if b < c {
            a * b < a * c
            a * b - a * c = 0
            b - c = 0
            a * (b - c) = a * b - a * c
            sub_distrib_right(a, b, c)
        }
        if not (b < c) {
            b - c + c = b
            a * (b - c) + a * c = a * b
            a * (b - c) = a * b - a * c
            sub_distrib_right(a, b, c)
        }
        sub_distrib_right(a, b, c)
    }
    sub_distrib_right(a, b, c)
}

theorem sub_distrib_left(a: Nat, b: Nat, c: Nat) {
    (a - b) * c = a * c - b * c
} 

// Misc helpers
theorem two_neq_zero {
    2 != 0
}
theorem three_neq_zero {
    3 != 0
}

attributes Nat {
    /// Note that 0^0 = 1.
    define pow(self, b: Nat) -> Nat {
        match b {
            Nat.0 {
                1
            }
            Nat.suc(pred) {
                self * self.pow(pred)
            }
        }
    }
}

theorem pow_zero(a: Nat) {
    a^0 = 1
}

theorem pow_one(a: Nat) {
    a^1 = a
} by {
    a^1 = a * a^0
    a^0 = 1
}

theorem pow_add(a: Nat, b: Nat, c: Nat) {
    a^(b + c) = a^b * a^c
} by {
    // Inductive step
    let f: Nat -> Bool = function(x: Nat) {
        a^(b + x) = a^b * a^x
    }
    f(0)
    forall(x: Nat) {
        if f(x) {
            a^(b + x) = a^b * a^x
            
            b + (x + 1) = (b + x) + 1

            a^((b + x) + 1) = a^b * (a^x * a^1)

            f(x + 1)
        }
    }
    f(c)
}

theorem pow_mul(a: Nat, b: Nat, c: Nat) {
    a^(b * c) = (a^b)^c
} by {
    // Inductive step
    let f: Nat -> Bool = function(x: Nat) {
        a^(b * x) = (a^b)^x
    }
    f(0)
    forall(x: Nat) {
        if f(x) {
            a^(b * x) = (a^b)^x
            b * (x + 1) = b * x + b
            a^(b * (x + 1)) = a^(b * x) * a^b
            a^b = (a^b)^1
            a^(b * (x + 1)) = (a^b)^(x + 1)
            f(x + 1)
        }
    }
    f(c)
}

theorem zero_pow(n: Nat) {
    n != 0 implies 0^n = 0
} by {
    let b: Nat satisfy {
        n = b.suc
    } // 0^(b.suc) = 0^b * 0^1 with 0^1 = 0
}

theorem one_pow(n: Nat) {
    1^n = 1
} by {
    one_pow(0)
    one_pow(n) // induction 1^n = 1^(n - 1) * 1 with 1^(n - 1) = 1
}

theorem pow_gte_one(a: Nat, b: Nat) {
    a != 0 implies 1 <= a^b
} by {
    // Induction step
    let f: Nat -> Bool = function(x: Nat) {
        1 <= a^x
    }
    f(0)
    forall(x: Nat) {
        if f(x) {
            1 <= a^x
            a^x <= a^(x + 1)
            1 <= a^(x + 1)
            f(x + 1)
        }
    }
    f(b)
}

theorem pow_gt_one(a: Nat, b: Nat) {
    1 < a and b != 0 implies 1 < a^b
} by {
    let b_pred: Nat satisfy {
        b = b_pred + 1
    }
    a^b = a * a^(b_pred)
    a^(b_pred) >= 1
    a > 1
    a * a^(b_pred) > 1
    a^b > 1
}

theorem pow_ne_zero(a: Nat, b: Nat) {
    a != 0 implies a^b != 0
} by {
    1 <= a^b
}

theorem lt_imp_pow_lt(a: Nat, b1: Nat, b2: Nat) {
    1 < a and b1 < b2 implies a^b1 < a^b2
} by {
    let n: Nat satisfy {
        b1 + n = b2 and n != 0
    }
    a^b2 = a^b1 * a^n
    a^b1 != 0
    1 < a
    1 < a^n
    a^b2 > a^b1
}

theorem lte_imp_pow_lte(a: Nat, b1: Nat, b2: Nat) {
    a != 0 and b1 <= b2 implies a^b1 <= a^b2
} by {
    let n: Nat satisfy {
        b1 + n = b2
    }
    a^b2 = a^b1 * a^n
    a^n != 0
    a^b2 >= a^b1
}

theorem lte_pow(a: Nat, b: Nat) {
    a != 0 and b != 0 implies a <= a^b
}

theorem pow_lt_imp_lt(a: Nat, b1: Nat, b2: Nat) {
    1 < a and a^b1 < a^b2
    implies
    b1 < b2
}

theorem pow_lte_imp_lte(a: Nat, b1: Nat, b2: Nat) {
    1 < a and a^b1 <= a^b2
    implies
    b1 <= b2
}

theorem pow_eq_one_imp(a: Nat, b: Nat) {
    a != 1 and a^b = 1 implies b = 0
} by {
    if b != 0 {
        let b_pred: Nat satisfy {
            b = b_pred + 1
        }
        a^b = a * a^(b_pred)
        a^b != 1
        false
    }
}

theorem sq_eq_mul(a: Nat) {
    a^2 = a * a
}

define true_below(f: Nat -> Bool, n: Nat) -> Bool {
    forall(x: Nat) { x < n implies f(x) }
}

theorem strong_induction(f: Nat -> Bool) {
    forall(k: Nat) {
        true_below(f, k) implies f(k)
    } implies forall(n: Nat) { f(n) }
} by {
    // under "strong_induction" assumption: 
    //     forall(k: Nat) {
    //       true_below(f, k) => f(k)
    //     }
    // try to prove that 
    //     true_below(f, x) => true_below(f, x.suc)
    // then by induction, we get 
    //     forall(x: Nat) { true_below(f, x) }
    // then obviously 
    //     forall(n: Nat) { f(n) }
    define g(x: Nat) -> Bool {
        true_below(f, x)
    }
    true_below(f, 0)
    g(0)
    forall(x: Nat) {
        if g(x) {
            true_below(f, x)
            f(x)
            forall(y: Nat) {
                if y < x.suc {
                    if y < x {
                        f(y)
                    }
                    if not (y < x) {
                        y = x
                        f(y)
                    }
                    f(y)
                }
            }
            true_below(f, x.suc)
            g(x.suc)
        }
    }
    forall(x: Nat) {
        g(x)
    }
    forall(n: Nat) {
        g(n.suc)
        true_below(f, n.suc)
        f(n)
    }
}

theorem gte_each_of_three(a: Nat, b: Nat, c: Nat) {
    exists(n: Nat) {
        a <= n and b <= n and c <= n
    }
} by {
    let n: Nat = a + b + c
    a <= n 
    b <= n
    c <= n
}

theorem gt_each_of_three(a: Nat, b: Nat, c: Nat) {
    exists(n: Nat) {
        a < n and b < n and c < n
    }
} by {
    let n: Nat = (a + b + c) + 1
    a < n
    b < n
    c < n
}

// Single-digit addition facts should probably just be theorems.
theorem one_plus_two {
    1 + 2 = 3
}

theorem one_plus_three {
    1 + 3 = 4
}

theorem one_plus_four {
    1 + 4 = 5
}

theorem one_plus_five {
    1 + 5 = 6
}

theorem one_plus_six {
    1 + 6 = 7
}

theorem one_plus_seven {
    1 + 7 = 8
}

theorem one_plus_eight {
    1 + 8 = 9
}

theorem one_plus_nine {
    1 + 9 = 10
}

theorem one_sub_one {
    1 - 1 = 0
}

theorem two_sub_one {
    2 - 1 = 1
}

theorem three_sub_one {
    3 - 1 = 2
}

theorem four_sub_one {
    4 - 1 = 3
}

theorem five_sub_one {
    5 - 1 = 4
}

theorem six_sub_one {
    6 - 1 = 5
}

theorem seven_sub_one {
    7 - 1 = 6
}

theorem eight_sub_one {
    8 - 1 = 7
}

theorem nine_sub_one {
    9 - 1 = 8
}

theorem ten_sub_one {
    10 - 1 = 9
}

from set import Set, is_surjective, cardinal_lt_power

theorem nat_power_set_uncountable(f: Nat -> Set[Nat]) {
    not is_surjective(f)
} by {
    cardinal_lt_power[Nat](f)
}