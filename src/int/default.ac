import nat.nat_base
from nat.prime_number import Nat, mod_maintains
from int.int_base import Int, from_nat, abs, abs_neg, abs_zero, neg_neg, neg_sub, nonzero_pos_or_neg, sub_eq_zero, sub_nat, lt_trans, neg_lt_zero

numerals Int

theorem mul_from_nat(j: Nat, k: Nat) { 
    from_nat(j) * from_nat(k) = from_nat(j * k)
}

theorem abs_zero_imp_zero(a: Int) {
    abs(a) = Nat.0 implies a = 0
} 

theorem mul_zero_imp_factor_zero(a: Int, b: Int) { a * b = 0 implies a = 0 or b = 0 } by {
    abs(a) * abs(b) = Nat.0
    abs(a) = Nat.0 or abs(b) = Nat.0
}

theorem mul_pos_pos(a: Int, b: Int) {
    a > 0 and b > 0 implies (a * b) > 0
} by {
    a >= 0
    b >= 0
    (a * b) >= 0
    a != 0
    b != 0
    a * b != 0
}

theorem mul_pos_neg(a: Int, b: Int) {
    a > 0 and b < 0 implies (a * b) < 0
} by {
    a != 0
    b != 0
    a * b != 0
}

theorem mul_neg_pos(a: Int, b: Int) {
    a < 0 and b > 0 implies (a * b) < 0
}

theorem mul_neg_neg(a: Int, b: Int) {
    a < 0 and b < 0 implies (a * b) > 0
} by {
    a != 0
    b != 0
    a * b != 0
}

theorem int_mul_nat_mul(a: Int, j: Nat, k: Nat) { 
    a.mul_nat(j * k) = a * from_nat(j) * from_nat(k)
} by {
    if a > 0 {
        a.mul_nat(j * k) = from_nat(abs(a) * j * k)
        a.mul_nat(j * k) = from_nat(abs(a)) * from_nat(j) * from_nat(k)
        from_nat(abs(a)) = a

        a.mul_nat(j * k) = a * from_nat(j) * from_nat(k)
    } else {
        a.mul_nat(j * k) = -(from_nat(abs(a) * j * k))
        a.mul_nat(j * k) = -(from_nat(abs(a)) * from_nat(j) * from_nat(k))
        from_nat(abs(a)) = -a


        a.mul_nat(j * k) = a * from_nat(j) * from_nat(k)
    }
}

theorem mul_int_nat_nat_assoc(a: Int, j: Nat, k: Nat) { 
    a.mul_nat(j * k) = (a.mul_nat(j)).mul_nat(k) 
} by {
    a.mul_nat(j * k) = a * from_nat(j) * from_nat(k)
}

theorem mul_int_int_nat_assoc(a: Int, b: Int, n: Nat) { 
    (a * b).mul_nat(n) = a * (b.mul_nat(n)) 
} by {
    if b >= 0 {
        (a * b).mul_nat(n) = (a * from_nat(abs(b))) * from_nat(n)
        (a * b).mul_nat(n) = a * (from_nat(abs(b)) * from_nat(n))
        (a * b).mul_nat(n) = a * (b.mul_nat(n))
    } else {
        (-b) > 0
        (a * b).mul_nat(n) = -(a * -b) * from_nat(n)
        (a * b).mul_nat(n) = -(a * from_nat(abs(-b))) * from_nat(n)
        (a * b).mul_nat(n) = -(a * (from_nat(abs(-b)) * from_nat(n)))
        (a * b).mul_nat(n) = -(a * (-b).mul_nat(n))
        (a * b).mul_nat(n) = a * (b.mul_nat(n))
    }
}

theorem mul_assoc(a: Int, b: Int, c: Int) { 
    a * b * c = a * (b * c) 
} by {
    if c >= 0 {
        a * b * c = a * b * (from_nat(abs(c)))
        a * b * c = a * (b * from_nat(abs(c)))

        a * b * c = a * (b * c) 

    } else {
        (-c) > 0

        a * b * -c = a * b * (from_nat(abs(-c)))
        a * b * -c = a * (b * from_nat(abs(-c)))

        a * b * c = a * (b * c) 
    }
}

theorem nonpos_lt_pos(a: Int, b: Int) {
    a <= 0 and b > 0 implies a < b
} by {
    (b - a) > 0
}

theorem neg_lt_nonneg(a: Int, b: Int) { 
    a < 0 and b >= 0 implies a < b 
}

theorem nonpos_lte_nonneg(a: Int, b: Int) {
    a <= 0 and b >= 0 implies a <= b
} by {
    if a = 0 and b = 0 { 
        a <= b 
    } 
    if a < 0 { 
        a <= b 
    }
    if b > 0 { 
        a <= b 
    }
}

theorem lte_abs(a: Int) { a <= from_nat(abs(a)) } by {
    if a > 0 {
        a <= from_nat(abs(a))
    } else {
        a <= 0
        a <= from_nat(abs(a))
    }
}

theorem lt_add_left(a: Int, b: Int, c: Int) { 
    b < c implies a + b < a + c 
} by {
    (c - b) > 0
    (a + c) - (a + b) = c - b
    ((a + c) - (a + b)) > 0
}

theorem lte_add_left(a: Int, b: Int, c: Int) { 
    b <= c implies a + b <= a + c 
}

theorem lt_add_right(a: Int, b: Int, c: Int) { 
    b < c implies b + a < c + a 
} 

theorem lte_add_right(a: Int, b: Int, c: Int) { 
    b <= c implies b + a <= c + a 
}

theorem lt_sub(a: Int, b: Int, c: Int) { 
    a < b + c implies a - b < c 
} by {
    a + -b < b + c + -b
}

theorem lte_sub(a: Int, b: Int, c: Int) { 
    a <= b + c implies a - b <= c 
} by {
    if a = b + c {
        a - b = c
        a - b <= c
    } else {
        a - b < c
        a - b <= c
    }
}

theorem gt_sub(a: Int, b: Int, c: Int) { 
    a > b + c implies a - b > c 
} by {
    a + -b > b + c + -b
}

theorem gte_sub(a: Int, b: Int, c: Int) { 
    a >= b + c implies a - b >= c 
} by {
    if a = b + c {
        a - b = c
        a - b >= c
    } else {
        a - b > c
        a - b >= c
    }
}

theorem abs_add_nonneg(a: Int, b: Int) {
    a >= 0 and b >= 0 implies abs(a + b) = abs(a) + abs(b)
} by {
    from_nat(abs(a)) = a
    from_nat(abs(b)) = b
    from_nat(abs(a)) + from_nat(abs(b)) = from_nat(abs(a) + abs(b))
}

theorem abs_add_nonpos(a: Int, b: Int) {
    a <= 0 and b <= 0 implies abs(a + b) = abs(a) + abs(b)
} by {
    (-a) >= 0
    (-b) >= 0
}

// One case of the triangle inequality
theorem triangle_nonpos_lte_nonneg(a: Int, b: Int) {
    a >= 0 and b <= 0 and abs(b) <= abs(a) implies abs(a + b) <= abs(a) + abs(b)
} by {
    let (n: Nat) satisfy { n + abs(b) = abs(a) }
    from_nat(n) + from_nat(abs(b)) = from_nat(abs(a))
    from_nat(n) + -b = from_nat(abs(a))
    from_nat(n) + -b = a
    a + b = from_nat(n)
    abs(a + b) = n
    n <= abs(a)
    abs(a) <= abs(a) + abs(b)
    n <= abs(a) + abs(b)
}

theorem triangle_nonneg_nonpos(a: Int, b: Int) {
    a >= 0 and b <= 0 implies abs(a + b) <= abs(a) + abs(b)
} by {
    if abs(b) <= abs(a) {
        abs(a + b) <= abs(a) + abs(b)
    } else {
        abs(a) <= abs(b)
        abs(-a) <= abs(-b)
        (-b) >= 0
        (-a) <= 0
        abs(-b + -a) <= abs(-b) + abs(-a)

        abs(a + b) <= abs(a) + abs(b)
    }
}

theorem triangle_ineq(a: Int, b: Int) { 
    abs(a + b) <= abs(a) + abs(b) 
} by {
    if a < 0 {
        if b < 0 {
            abs(a + b) <= abs(a) + abs(b)
        } else {
            abs(b + a) <= abs(b) + abs(a)
            abs(a + b) <= abs(a) + abs(b)
        }
    } else {
        if b < 0 {
            abs(a + b) <= abs(a) + abs(b)
        } else {
            abs(a + b) <= abs(a) + abs(b)
        }
    }
}

theorem nat_lt_embed(a: Nat, b: Nat) {
    a < b iff from_nat(a) < from_nat(b)
} by {
    if a < b {
        let n: Nat satisfy { b = a + n and n != Nat.0 }
        from_nat(b) = from_nat(a) + from_nat(n)
        from_nat(n) > 0

        from_nat(a) < from_nat(b)
    }
    if not a < b {
        a >= b
        let n: Nat satisfy { a = b + n }
        from_nat(a) = from_nat(b) + from_nat(n)
        0 <= from_nat(n)

        from_nat(a) >= from_nat(b)
        not from_nat(a) < from_nat(b)
    }
}

theorem nat_lte_embed(a: Nat, b: Nat) {
    a <= b iff from_nat(a) <= from_nat(b)
} by {
    a <= b implies from_nat(a) <= from_nat(b)
}

theorem pos_neg_lt_abs(a: Int, b: Int) {
    a < from_nat(abs(b)) and -a < from_nat(abs(b)) implies abs(a) < abs(b)
} by {
    if a > 0 {
        a = from_nat(abs(a))
        from_nat(abs(a)) < from_nat(abs(b))
        abs(a) < abs(b)
    }
    if -a > 0 {
        -a = from_nat(abs(-a))
        from_nat(abs(-a)) < from_nat(abs(b))
        abs(-a) < abs(b)
        abs(a) < abs(b)        
    }
}

theorem pos_neg_lte_abs(a: Int, b: Int) {
    a <= from_nat(abs(b)) and -a <= from_nat(abs(b)) implies abs(a) <= abs(b)
} by {
    if a > 0 {
        a = from_nat(abs(a))
        from_nat(abs(a)) <= from_nat(abs(b))
        abs(a) <= abs(b)
    }
    if -a > 0 {
        -a = from_nat(abs(-a))
        from_nat(abs(-a)) <= from_nat(abs(b))
        abs(-a) <= abs(b)
        abs(a) <= abs(b)        
    }
}

theorem triangle_ineq_sub(a: Int, b: Int) { 
    abs(from_nat(abs(a)) - from_nat(abs(b))) <= abs(a - b)
} by {
    // prove |a| <= |(a - b) + b| => |a| - |b| <= |a - b|
    abs(a) = abs((a - b) + b)
    abs(a) <= abs(a - b) + abs(b)

    from_nat(abs(a)) <= from_nat(abs(a - b)) + from_nat(abs(b))
    
    from_nat(abs(a)) - from_nat(abs(b)) <= from_nat(abs(a - b))

    // prove |b| <= |(a - b) + a| => |b| - |a| <= |a - b|
    abs(b) = abs((b - a) + a)
    abs(b) <= abs(b - a) + abs(a)

    from_nat(abs(b)) <= from_nat(abs(b - a)) + from_nat(abs(a))
    
    from_nat(abs(b)) - from_nat(abs(a)) <= from_nat(abs(b - a))
}

theorem lt_mul_pos(a: Int, b: Int, c: Int) { 
    a < b and c > 0 implies a * c < b * c 
} by {
    b * c - a * c = (b - a) * c
    (b - a) > 0
    (b * c - a * c) > 0
}

theorem lt_mul_neg(a: Int, b: Int, c: Int) { 
    a < b and c < 0 implies b * c < a * c 
} by {
    a * c - b * c = c * (a - b)
    (a - b) < 0
    (c * (a - b)) > 0
    (a * c - b * c) > 0
}

theorem lte_trans(a: Int, b: Int, c: Int) { 
    a <= b and b <= c implies a <= c 
} by {
    if a = b {
        if b = c {
            a <= c
        } else {
            a <= c
        }
    } else {
        if b = c {
            a <= c
        } else {
            lt_trans(a, b, c)
            a <= c
        }
    }
}

theorem lt_and_lte(a: Int, b: Int, c: Int) { a < b and b <= c implies a < c } by {
    if b = c {
        a < c
    } else {
        a < c
    }
}

theorem lte_and_lt(a: Int, b: Int, c: Int) { a <= b and b < c implies a < c } by {
    if a = b {
        a < c
    } else {
        a < c
    }
}

// Units and dividing

define is_unit(a: Int) -> Bool { abs(a) = Nat.1 }

theorem two_units(u: Int) { 
    is_unit(u) implies u = 1 or u = -1
} by {
    abs(u) = Nat.1
    if u > 0 {
        u = from_nat(abs(u))
        u = from_nat(Nat.1)
        1 = Int.pos_suc(Nat.0)
        Int.pos_suc(Nat.0) = from_nat(Nat.0.suc)
        1 = from_nat(Nat.1)
        u = 1
    } else {
        -u > 0
        -u = from_nat(abs(-u))
        -u = from_nat(Nat.1)
        1 = Int.pos_suc(Nat.0)
        Int.pos_suc(Nat.0) = from_nat(Nat.0.suc)
        1 = from_nat(Nat.1)
        -u = 1
        u = -1
    }
}

theorem unit_squared(u: Int) { 
    is_unit(u) implies u * u = 1 
} by {
    if u = 1 {
        u * u = 1
    } else {
        u * u = 1
    }
}

theorem mul_units(u: Int, v: Int) { 
    is_unit(u) and is_unit(v) implies is_unit(u * v) 
} by {
    abs(u * v) = abs(u) * abs(v)
    abs(u) = Nat.1
    abs(v) = Nat.1
    abs(u * v) = Nat.1
}

define unit_sign(a: Int) -> Int {
    match a {
        0 {
            0
        }
        Int.pos_suc(pred) {
            1
        }
        Int.neg_suc(pred) {
            -1
        }
    }
}

theorem unit_sign_is_unit(a: Int) { 
    a != 0 implies is_unit(unit_sign(a)) 
} by {
    if a < 0 {
        unit_sign(a) = -(1)
        abs(-(1)) = Nat.1
        is_unit(unit_sign(a))
    } else {
        unit_sign(a) = 1
        abs(1) = Nat.1
        is_unit(unit_sign(a))
    }
}

theorem abs_decomp(a: Int) { 
    unit_sign(a) * from_nat(abs(a)) = a 
} by {
    if a = 0 {
        unit_sign(a) = 0
        unit_sign(a) * from_nat(abs(a)) = a 
    }
    if a < 0 {
        unit_sign(a) = -(1)
        unit_sign(a) * from_nat(abs(a)) = a
    } 
    if a > 0 {
        unit_sign(a) = 1
        unit_sign(a) * from_nat(abs(a)) = a
    }
}

theorem abs_alt_decomp(a: Int) {
    unit_sign(a) * a = from_nat(abs(a)) 
} by {
    if a = 0 {
        unit_sign(a) * a = from_nat(abs(a))
    } else {
        unit_sign(a) * a = unit_sign(a) * (unit_sign(a) * from_nat(abs(a)))
        unit_sign(a) * unit_sign(a) = 1
        unit_sign(a) * a = 1 * from_nat(abs(a))
    }
}

attributes Int {
    define divides(self, other: Int) -> Bool {
        exists(d: Int) { d * self = other }
    }
}

theorem div_trans(a: Int, b: Int, c: Int) {
    a.divides(b) and b.divides(c) implies a.divides(c)
} by {
    let (d: Int) satisfy { d * a = b }
    let (e: Int) satisfy { e * b = c }
    e * (d * a) = c
    e * d * a = c
    a.divides(c)
}

theorem div_imp_div_abs(a: Int, b: Int) {
    a.divides(b) implies abs(a).divides(abs(b))
} by {
    let (d: Int) satisfy { d * a = b }
    abs(d) * abs(a) = abs(b)
    abs(a).divides(abs(b))
}

theorem div_from_nat(j: Nat, k: Nat) {
    j.divides(k) implies from_nat(j).divides(from_nat(k))
} by {
    let (n: Nat) satisfy { n * j = k }
    from_nat(n) * from_nat(j) = from_nat(k)
    from_nat(j).divides(from_nat(k))
}

theorem div_abs(a: Int) {
    a.divides(from_nat(abs(a)))
} by {
    from_nat(abs(a)) = a * unit_sign(a)
}

theorem div_abs_imp_div(a: Int, b: Int) { 
    abs(a).divides(abs(b)) implies a.divides(b) 
} by {
    a.divides(from_nat(abs(a)))
    from_nat(abs(a)).divides(from_nat(abs(b)))
    from_nat(abs(b)).divides(b)
}

theorem abs_eq_imp_unit(a: Int, b: Int) {
    a != 0 and b != 0 and abs(a) = abs(b) implies exists(u: Int) { is_unit(u) and u * a = b }
} by {
    a = unit_sign(a) * from_nat(abs(a))
    b = unit_sign(b) * from_nat(abs(b))
    let u = unit_sign(a) * unit_sign(b)
    is_unit(u)
    u * a = b
}

theorem abs_eq_imp_div(a: Int, b: Int) { 
    a != 0 and b != 0 and abs(a) = abs(b) implies a.divides(b) 
} by {
    exists(u: Int) { is_unit(u) and u * a = b }
}

theorem div_pos_imp_lte(a: Int, b: Int) { a.divides(b) and b > 0 implies a <= b } by {
    abs(a).divides(abs(b))
    from_nat(abs(a)) <= from_nat(abs(b))
    from_nat(abs(a)) <= b
    a <= from_nat(abs(a))
    a <= b
}

theorem lt_mul_both(a: Int, b: Int, c: Int) {
    a > 0 and b < c implies a * b < a * c
}

theorem lte_mul_both(a: Int, b: Int, c: Int) {
    a > 0 and b <= c implies a * b <= a * c
}

theorem lt_mul_both_neg(a: Int, b: Int, c: Int) {
    a < 0 and b < c implies a * b > a * c
} by {
    a * c < b * a
}

theorem lte_mul_both_neg(a: Int, b: Int, c: Int) {
    a < 0 and b <= c implies a * b >= a * c
}

theorem lt_cancel_mul(a: Int, b: Int, c: Int) {
    a > 0 and a * b < a * c implies b < c
} 

theorem lte_cancel_mul(a: Int, b: Int, c: Int) {
    a > 0 and a * b <= a * c implies b <= c
} 

theorem lt_cancel_mul_neg(a: Int, b: Int, c: Int) {
    a < 0 and a * b < a * c implies b > c
} 

theorem lte_cancel_mul_neg(a: Int, b: Int, c: Int) {
    a < 0 and a * b <= a * c implies b >= c
}

theorem mul_pos_cancel_left(a: Int, b: Int, c: Int) {
    a > 0 and a * b = a * c implies b = c
} 

theorem mul_pos_cancel_right(a: Int, b: Int, c: Int) {
    a > 0 and b * a = c * a implies b = c
}

theorem mul_neg_cancel_left(a: Int, b: Int, c: Int) {
    a < 0 and a * b = a * c implies b = c
} 

theorem mul_neg_cancel_right(a: Int, b: Int, c: Int) {
    a < 0 and b * a = c * a implies b = c
}

theorem mul_cancel_left(a: Int, b: Int, c: Int) {
    a != 0 and a * b = a * c implies b = c
} 

theorem mul_cancel_right(a: Int, b: Int, c: Int) {
    a != 0 and b * a = c * a implies b = c
}

theorem divides_cancel_left(a: Int, b: Int, c: Int) {
    a != 0 and (a * b).divides(a * c) implies b.divides(c)
} by {
    let d: Int satisfy {
        a * b * d = a * c
    }
    a * (b * d) = a * c
    b * d = c
}

theorem divides_cancel_right(a: Int, b: Int, c: Int) {
    a != 0 and (b * a).divides(c * a) implies b.divides(c)
}

theorem divides_mul_left(a: Int, b: Int, m: Int) {
    a.divides(b) implies (m * a).divides(m * b)
} by {
    let d: Int satisfy {
        d * a = b
    }
    m * d * a = m * b
}

theorem divides_mul_right(a: Int, b: Int, m: Int) {
    a.divides(b) implies (a * m).divides(b * m)
}

theorem one_plus_one {
    1 + 1 = 2
} by {
    2 = from_nat(Nat.1 + Nat.1)
}

theorem times_two(a: Int) {
    2 * a = a + a
} by {
    2 = 1 + 1
    2 * a = (1 + 1) * a
    2 * a = 1 * a + 1 * a
}

theorem add_lte(a: Int, b: Int, c: Int, d: Int) {
    a <= b and c <= d implies a + c <= b + d
} by {
    b + c <= b + d
    a + c <= b + c
    lte_trans(a + c, b + c, b + d)
}

theorem plus_abs_gte_zero(n: Int) {
    n + from_nat(abs(n)) >= 0
} by {
    if n < 0 {
        from_nat(abs(n)) = -n
        n + from_nat(abs(n)) = 0
    } else {
        n + from_nat(abs(n)) = n + n
        n + from_nat(abs(n)) >= 0
    }
}

attributes Int {
    /// Note that 0^0 = 1.
    /// TODO: we should be able to inherit `pow` from some underlying algebraic structure.
    define pow(self, b: Nat) -> Int {
        match b {
            Nat.0 {
                1
            }
            Nat.suc(pred) {
                self * self.pow(pred)
            }
        }
    }
}

theorem pow_one(a: Int) {
    a^(Nat.1) = a
} by {
    a * a^(Nat.0) = a
    a^(Nat.0.suc) = a
}

theorem pow_zero(a: Int) {
    a^(Nat.0) = 1
}

theorem pow_add(a: Int, b: Nat, c: Nat) {
    a^(b + c) = a^b * a^c
} by {
    // Inductive step
    let f = function(x: Nat) {
        a^(b + x) = a^b * a^x
    }
    f(Nat.0)
    forall(x: Nat) {
        if f(x) {
            a^(b + x) = a^b * a^x
            a^(b + x.suc) = a^b * a^(x.suc)
            f(x.suc)
        }
    }
    f(c)
}

theorem pow_mul(a: Int, b: Nat, c: Nat) {
    a^(b * c) = (a^b)^c
} by {
    // Inductive step
    let f = function(x: Nat) {
        a^(b * x) = (a^b)^x
    }
    f(Nat.0)
    forall(x: Nat) {
        if f(x) {
            a^(b * x) = (a^b)^x
            a^(b * x.suc) = (a^b)^(x.suc)
            f(x.suc)
        }
    }
    f(c)
}

theorem zero_pow(n: Nat) {
    n != Nat.0 implies 0^n = 0
} by {
    let b: Nat satisfy {
        n = b.suc
    }
}

theorem one_pow(n: Nat) {
    1^n = 1
} by {
    one_pow(Nat.0)
    one_pow(n)
}

theorem pos_pow(a: Int, n: Nat) {
    a > 0 implies a^n > 0
} by {
    let f = function(x: Nat) {
        a^x > 0
    }
    f(Nat.0)
    f(n)
}

theorem sq_eq_mul(a: Int) {
    a * a = a^(Nat.2)
}

theorem sq_pos(a: Int) {
    a != 0 implies a^(Nat.2) > 0
}

theorem pow_abs_eq_abs_pow(a: Int, n: Nat) {
    abs(a^n) = abs(a)^n
} by {
    let f = function(x: Nat) {
        abs(a^x) = abs(a)^x
    }
    f(Nat.0)
    forall(x: Nat) {
        if f(x) {
            abs(a^x) = abs(a)^x
            abs(a^(x.suc)) = abs(a)^(x.suc)
            f(x.suc)
        }
    }
    f(n)
}

attributes Int {
    /// The absolute value of an integer.
    define abs(self) -> Int {
        from_nat(abs(self))
    }
}

theorem member_abs_neg(a: Int) {
    a < 0 implies a.abs = -a
}

theorem member_abs_nonneg(a: Int) {
    a >= 0 implies a.abs = a
}

theorem member_abs_pos(a: Int) {
    a > 0 implies a.abs = a
}

theorem member_abs_nonpos(a: Int) {
    a <= 0 implies a.abs = -a
}

theorem member_triangle(a: Int, b: Int) {
    (a + b).abs <= a.abs + b.abs
} by {
    abs(a + b) <= abs(a) + abs(b)
}
