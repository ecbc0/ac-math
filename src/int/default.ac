from nat.prime_number import ℕ, mod_maintains, gcd as nat_gcd, relative_prime as nat_relative_prime
from int.int_base import ℤ, from_nat, abs, abs_neg, abs_zero, neg_neg, nonzero_pos_or_neg, sub_eq_zero, sub_nat, lt_trans, neg_lt_zero
from type_class.ordered_ring import triangle_ineq, triangle_ineq_sub

numerals ℤ

theorem mul_from_nat(j: ℕ, k: ℕ) { 
    from_nat(j) ⋅ from_nat(k) = from_nat(j ⋅ k)
}

theorem abs_zero_imp_zero(a: ℤ) {
    abs(a) = ℕ.0 implies a = 0
} 

theorem mul_to_zero(a: ℤ, b: ℤ) { a ⋅ b = 0 implies a = 0 or b = 0 } by {
    abs(a) ⋅ abs(b) = ℕ.0
    abs(a) = ℕ.0 or abs(b) = ℕ.0
}

theorem mul_pos_pos(a: ℤ, b: ℤ) {
    a > 0 and b > 0 implies (a ⋅ b) > 0
} by {
    a >= 0
    b >= 0
    (a ⋅ b) >= 0
    a != 0
    b != 0
    a ⋅ b != 0
}

theorem mul_pos_pos_iff(a: ℤ, b: ℤ) {
    a > 0 implies (b > 0 iff (a ⋅ b) > 0)
} by {
    if b > 0 {
        a ⋅ b > 0
    } else {
        b <= 0
        a ⋅ b <= 0
    }
}

theorem mul_pos_pos_raw(a: ℤ, b: ℤ) {
    a.is_positive and b.is_positive implies (a ⋅ b).is_positive
}

theorem mul_pos_neg(a: ℤ, b: ℤ) {
    a > 0 and b < 0 implies (a ⋅ b) < 0
} by {
    a != 0
    b != 0
    a ⋅ b != 0
}

theorem mul_neg_pos(a: ℤ, b: ℤ) {
    a < 0 and b > 0 implies (a ⋅ b) < 0
}

theorem mul_neg_neg(a: ℤ, b: ℤ) {
    a < 0 and b < 0 implies (a ⋅ b) > 0
} by {
    a != 0
    b != 0
    a ⋅ b != 0
}

theorem mul_nonneg_nonneg_nonneg(a: ℤ, b: ℤ) {
    a >= 0 and b >= 0 implies (a ⋅ b) >= 0
} 

theorem mul_nonneg_nonpos_nonpos(a: ℤ, b: ℤ) {
    a >= 0 and b <= 0 implies (a ⋅ b) <= 0
} 

theorem mul_nonneg_nonpos_nonpos_raw(a: ℤ, b: ℤ) {
    not a.is_negative and not b.is_positive implies not (a ⋅ b).is_positive
}

theorem mul_nonpos_nonneg_nonpos(a: ℤ, b: ℤ) {
    a <= 0 and b >= 0 implies (a ⋅ b) <= 0
} 

theorem mul_nonpos_nonpos_nonneg(a: ℤ, b: ℤ) {
    a <= 0 and b <= 0 implies (a ⋅ b) >= 0
} 

theorem int_mul_nat_mul(a: ℤ, j: ℕ, k: ℕ) { 
    a.mul_nat(j ⋅ k) = a ⋅ from_nat(j) ⋅ from_nat(k)
} by {
    if a > 0 {
        a.mul_nat(j ⋅ k) = from_nat(abs(a) ⋅ j ⋅ k)
        a.mul_nat(j ⋅ k) = from_nat(abs(a)) ⋅ from_nat(j) ⋅ from_nat(k)
        from_nat(abs(a)) = a

        a.mul_nat(j ⋅ k) = a ⋅ from_nat(j) ⋅ from_nat(k)
    } else {
        a.mul_nat(j ⋅ k) = -(from_nat(abs(a) ⋅ j ⋅ k))
        a.mul_nat(j ⋅ k) = -(from_nat(abs(a)) ⋅ from_nat(j) ⋅ from_nat(k))
        from_nat(abs(a)) = -a


        a.mul_nat(j ⋅ k) = a ⋅ from_nat(j) ⋅ from_nat(k)
    }
}

theorem mul_int_nat_nat_assoc(a: ℤ, j: ℕ, k: ℕ) { 
    a.mul_nat(j ⋅ k) = (a.mul_nat(j)).mul_nat(k) 
} by {
    a.mul_nat(j ⋅ k) = a ⋅ from_nat(j) ⋅ from_nat(k)
}

theorem mul_int_int_nat_assoc(a: ℤ, b: ℤ, n: ℕ) { 
    (a ⋅ b).mul_nat(n) = a ⋅ (b.mul_nat(n)) 
} by {
    if b >= 0 {
        (a ⋅ b).mul_nat(n) = (a ⋅ from_nat(abs(b))) ⋅ from_nat(n)
        (a ⋅ b).mul_nat(n) = a ⋅ (from_nat(abs(b)) ⋅ from_nat(n))
        (a ⋅ b).mul_nat(n) = a ⋅ (b.mul_nat(n))
    } else {
        (-b) > 0
        (a ⋅ b).mul_nat(n) = -(a ⋅ -b) ⋅ from_nat(n)
        (a ⋅ b).mul_nat(n) = -(a ⋅ from_nat(abs(-b))) ⋅ from_nat(n)
        (a ⋅ b).mul_nat(n) = -(a ⋅ (from_nat(abs(-b)) ⋅ from_nat(n)))
        (a ⋅ b).mul_nat(n) = -(a ⋅ (-b).mul_nat(n))
        (a ⋅ b).mul_nat(n) = a ⋅ (b.mul_nat(n))
    }
}

theorem mul_assoc(a: ℤ, b: ℤ, c: ℤ) { 
    a ⋅ b ⋅ c = a ⋅ (b ⋅ c) 
} by {
    if c >= 0 {
        a ⋅ b ⋅ c = a ⋅ b ⋅ (from_nat(abs(c)))
        a ⋅ b ⋅ c = a ⋅ (b ⋅ from_nat(abs(c)))

        a ⋅ b ⋅ c = a ⋅ (b ⋅ c) 

    } else {
        (-c) > 0

        a ⋅ b ⋅ -c = a ⋅ b ⋅ (from_nat(abs(-c)))
        a ⋅ b ⋅ -c = a ⋅ (b ⋅ from_nat(abs(-c)))

        a ⋅ b ⋅ c = a ⋅ (b ⋅ c) 
    }
}

from type_class.mul import Mul
from type_class.ring import Ring

instance ℤ: Mul {
    let mul = ℤ.mul

    let 1 = ℤ.1
}

instance ℤ: Ring 

theorem nonpos_lt_pos(a: ℤ, b: ℤ) {
    a <= 0 and b > 0 implies a < b
} 

theorem neg_lt_nonneg(a: ℤ, b: ℤ) { 
    a < 0 and b >= 0 implies a < b 
}

theorem nonpos_lte_nonneg(a: ℤ, b: ℤ) {
    a <= 0 and b >= 0 implies a <= b
} 

theorem lte_abs(a: ℤ) { a <= from_nat(abs(a)) } by {
    if a > 0 {
        a <= from_nat(abs(a))
    } else {
        a <= 0
        a <= from_nat(abs(a))
    }
}

theorem lt_add_left(a: ℤ, b: ℤ, c: ℤ) { 
    b < c implies a + b < a + c 
} 

from type_class.ordered_ring import Ordered_Add, Ordered_Ring

instance ℤ: Ordered_Add

instance ℤ: Ordered_Ring 

theorem lte_add_left(a: ℤ, b: ℤ, c: ℤ) { 
    b <= c implies a + b <= a + c 
}

theorem lt_add_right(a: ℤ, b: ℤ, c: ℤ) { 
    b < c implies b + a < c + a 
} 

theorem lte_add_right(a: ℤ, b: ℤ, c: ℤ) { 
    b <= c implies b + a <= c + a 
}

theorem lt_sub(a: ℤ, b: ℤ, c: ℤ) { 
    a < b + c implies a - b < c 
} 

theorem lte_sub(a: ℤ, b: ℤ, c: ℤ) { 
    a <= b + c implies a - b <= c 
} 

theorem gt_sub(a: ℤ, b: ℤ, c: ℤ) { 
    a > b + c implies a - b > c 
} 

theorem gte_sub(a: ℤ, b: ℤ, c: ℤ) { 
    a >= b + c implies a - b >= c 
} 

theorem abs_add_nonneg(a: ℤ, b: ℤ) {
    a >= 0 and b >= 0 implies abs(a + b) = abs(a) + abs(b)
} by {
    from_nat(abs(a)) = a
    from_nat(abs(b)) = b
    from_nat(abs(a)) + from_nat(abs(b)) = from_nat(abs(a) + abs(b))
}

theorem abs_add_nonpos(a: ℤ, b: ℤ) {
    a <= 0 and b <= 0 implies abs(a + b) = abs(a) + abs(b)
} by {
    (-a) >= 0
    (-b) >= 0
}

theorem nat_lt_embed(a: ℕ, b: ℕ) {
    a < b iff from_nat(a) < from_nat(b)
} by {
    if a < b {
        let n: ℕ satisfy { b = a + n and n != ℕ.0 }
        from_nat(b) = from_nat(a) + from_nat(n)
        from_nat(n) > 0

        from_nat(a) < from_nat(b)
    }
    if not a < b {
        a >= b
        let n: ℕ satisfy { a = b + n }
        from_nat(a) = from_nat(b) + from_nat(n)
        0 <= from_nat(n)

        from_nat(a) >= from_nat(b)
        not from_nat(a) < from_nat(b)
    }
}

theorem nat_lte_embed(a: ℕ, b: ℕ) {
    a <= b iff from_nat(a) <= from_nat(b)
} by {
    a <= b implies from_nat(a) <= from_nat(b)
}

theorem pos_neg_lt_abs(a: ℤ, b: ℤ) {
    a < from_nat(abs(b)) and -a < from_nat(abs(b)) implies abs(a) < abs(b)
} by {
    if a > 0 {
        a = from_nat(abs(a))
        from_nat(abs(a)) < from_nat(abs(b))
        abs(a) < abs(b)
    }
    if -a > 0 {
        -a = from_nat(abs(-a))
        from_nat(abs(-a)) < from_nat(abs(b))
        abs(-a) < abs(b)
        abs(a) < abs(b)        
    }
}

theorem pos_neg_lte_abs(a: ℤ, b: ℤ) {
    a <= from_nat(abs(b)) and -a <= from_nat(abs(b)) implies abs(a) <= abs(b)
} by {
    if a > 0 {
        a = from_nat(abs(a))
        from_nat(abs(a)) <= from_nat(abs(b))
        abs(a) <= abs(b)
    }
    if -a > 0 {
        -a = from_nat(abs(-a))
        from_nat(abs(-a)) <= from_nat(abs(b))
        abs(-a) <= abs(b)
        abs(a) <= abs(b)        
    }
}

theorem lt_mul_pos(a: ℤ, b: ℤ, c: ℤ) { 
    a < b and c > 0 implies a ⋅ c < b ⋅ c 
} 

theorem lt_mul_neg(a: ℤ, b: ℤ, c: ℤ) { 
    a < b and c < 0 implies b ⋅ c < a ⋅ c 
} 

theorem lt_and_lte(a: ℤ, b: ℤ, c: ℤ) { a < b and b <= c implies a < c } 

theorem lte_and_lt(a: ℤ, b: ℤ, c: ℤ) { a <= b and b < c implies a < c } 

theorem lte_trans(a: ℤ, b: ℤ, c: ℤ) { 
    a <= b and b <= c implies a <= c 
} 

// Units and dividing

define is_unit(a: ℤ) -> Bool { abs(a) = ℕ.1 }

theorem two_units(u: ℤ) { 
    is_unit(u) implies u = 1 or u = -1
} by {
    abs(u) = ℕ.1
    if u > 0 {
        u = from_nat(abs(u))
        u = from_nat(ℕ.1)
        1 = ℤ.pos_suc(ℕ.0)
        ℤ.pos_suc(ℕ.0) = from_nat(ℕ.0.suc)
        1 = from_nat(ℕ.1)
        u = 1
    } else {
        -u > 0
        -u = from_nat(abs(-u))
        -u = from_nat(ℕ.1)
        1 = ℤ.pos_suc(ℕ.0)
        ℤ.pos_suc(ℕ.0) = from_nat(ℕ.0.suc)
        1 = from_nat(ℕ.1)
        -u = 1
        u = -1
    }
}

theorem unit_squared(u: ℤ) { 
    is_unit(u) implies u ⋅ u = 1 
} by {
    if u = 1 {
        u ⋅ u = 1
    } else {
        u ⋅ u = 1
    }
}

theorem mul_units(u: ℤ, v: ℤ) { 
    is_unit(u) and is_unit(v) implies is_unit(u ⋅ v) 
} by {
    abs(u ⋅ v) = abs(u) ⋅ abs(v)
    abs(u) = ℕ.1
    abs(v) = ℕ.1
    abs(u ⋅ v) = ℕ.1
}

define unit_sign(a: ℤ) -> ℤ {
    match a {
        0 {
            0
        }
        ℤ.pos_suc(pred) {
            1
        }
        ℤ.neg_suc(pred) {
            -1
        }
    }
}

theorem unit_sign_order_rep(a: ℤ) {
    if a < 0 {
        unit_sign(a) = -1
    } else {
        if a > 0 {
            unit_sign(a) = 1
        }
    }
} by {
    if a < 0 {
        let pred: ℕ satisfy { a = ℤ.neg_suc(pred) }
        unit_sign(a) = -1
    } else {
        if a > 0 {
            let pred: ℕ satisfy { a = ℤ.pos_suc(pred) }
            unit_sign(a) = 1 
        }
    }
}

theorem unit_sign_is_unit(a: ℤ) { 
    a != 0 implies is_unit(unit_sign(a)) 
} by {
    if a < 0 {
        unit_sign(a) = -(1)
        abs(-(1)) = ℕ.1
        is_unit(unit_sign(a))
    } else {
        unit_sign(a) = 1
        abs(1) = ℕ.1
        is_unit(unit_sign(a))
    }
}

theorem abs_decomp(a: ℤ) { 
    unit_sign(a) ⋅ from_nat(abs(a)) = a 
} by {
    if a = 0 {
        unit_sign(a) = 0
        unit_sign(a) ⋅ from_nat(abs(a)) = a 
    }
    if a < 0 {
        unit_sign(a) = -(1)
        unit_sign(a) ⋅ from_nat(abs(a)) = a
    } 
    if a > 0 {
        unit_sign(a) = 1
        unit_sign(a) ⋅ from_nat(abs(a)) = a
    }
}

theorem abs_alt_decomp(a: ℤ) {
    unit_sign(a) ⋅ a = from_nat(abs(a)) 
} by {
    if a = 0 {
        unit_sign(a) ⋅ a = from_nat(abs(a))
    } else {
        unit_sign(a) ⋅ a = unit_sign(a) ⋅ (unit_sign(a) ⋅ from_nat(abs(a)))
        unit_sign(a) ⋅ unit_sign(a) = 1
        unit_sign(a) ⋅ a = 1 ⋅ from_nat(abs(a))
    }
}

attributes ℤ {
    define divides(self, other: ℤ) -> Bool {
        exists(d: ℤ) { d ⋅ self = other }
    }
}

theorem div_trans(a: ℤ, b: ℤ, c: ℤ) {
    a.divides(b) and b.divides(c) implies a.divides(c)
} by {
    let (d: ℤ) satisfy { d ⋅ a = b }
    let (e: ℤ) satisfy { e ⋅ b = c }
    e ⋅ (d ⋅ a) = c
    e ⋅ d ⋅ a = c
    a.divides(c)
}

theorem div_imp_div_abs(a: ℤ, b: ℤ) {
    a.divides(b) implies abs(a).divides(abs(b))
} by {
    let (d: ℤ) satisfy { d ⋅ a = b }
    abs(d) ⋅ abs(a) = abs(b)
    abs(a).divides(abs(b))
}

theorem div_from_nat(j: ℕ, k: ℕ) {
    j.divides(k) implies from_nat(j).divides(from_nat(k))
} by {
    let (n: ℕ) satisfy { n ⋅ j = k }
    from_nat(n) ⋅ from_nat(j) = from_nat(k)
    from_nat(j).divides(from_nat(k))
}

theorem div_abs(a: ℤ) {
    a.divides(from_nat(abs(a)))
} by {
    from_nat(abs(a)) = a ⋅ unit_sign(a)
}

theorem div_abs_imp_div(a: ℤ, b: ℤ) { 
    abs(a).divides(abs(b)) implies a.divides(b) 
} by {
    a.divides(from_nat(abs(a)))
    from_nat(abs(a)).divides(from_nat(abs(b)))
    from_nat(abs(b)).divides(b)
}

theorem abs_eq_imp_unit(a: ℤ, b: ℤ) {
    a != 0 and b != 0 and abs(a) = abs(b) implies exists(u: ℤ) { is_unit(u) and u ⋅ a = b }
} by {
    a = unit_sign(a) ⋅ from_nat(abs(a))
    b = unit_sign(b) ⋅ from_nat(abs(b))
    let u = unit_sign(a) ⋅ unit_sign(b)
    is_unit(u)
    u ⋅ a = b
}

theorem abs_eq_imp_div(a: ℤ, b: ℤ) { 
    a != 0 and b != 0 and abs(a) = abs(b) implies a.divides(b) 
} by {
    exists(u: ℤ) { is_unit(u) and u ⋅ a = b }
}

theorem div_pos_imp_lte(a: ℤ, b: ℤ) { a.divides(b) and b > 0 implies a <= b } by {
    abs(a).divides(abs(b))
    from_nat(abs(a)) <= from_nat(abs(b))
    from_nat(abs(a)) <= b
    a <= from_nat(abs(a))
    a <= b
}

theorem lt_mul_both(a: ℤ, b: ℤ, c: ℤ) {
    a > 0 and b < c implies a ⋅ b < a ⋅ c
}

theorem lte_mul_both(a: ℤ, b: ℤ, c: ℤ) {
    a > 0 and b <= c implies a ⋅ b <= a ⋅ c
}

theorem lt_mul_both_neg(a: ℤ, b: ℤ, c: ℤ) {
    a < 0 and b < c implies a ⋅ b > a ⋅ c
} by {
    a ⋅ c < b ⋅ a
}

theorem lte_mul_both_neg(a: ℤ, b: ℤ, c: ℤ) {
    a < 0 and b <= c implies a ⋅ b >= a ⋅ c
}

theorem lt_cancel_mul(a: ℤ, b: ℤ, c: ℤ) {
    a > 0 and a ⋅ b < a ⋅ c implies b < c
} 

theorem lte_cancel_mul(a: ℤ, b: ℤ, c: ℤ) {
    a > 0 and a ⋅ b <= a ⋅ c implies b <= c
} 

theorem lt_cancel_mul_neg(a: ℤ, b: ℤ, c: ℤ) {
    a < 0 and a ⋅ b < a ⋅ c implies b > c
} 

theorem lte_cancel_mul_neg(a: ℤ, b: ℤ, c: ℤ) {
    a < 0 and a ⋅ b <= a ⋅ c implies b >= c
}

theorem mul_pos_cancel_left(a: ℤ, b: ℤ, c: ℤ) {
    a > 0 and a ⋅ b = a ⋅ c implies b = c
} 

theorem mul_pos_cancel_right(a: ℤ, b: ℤ, c: ℤ) {
    a > 0 and b ⋅ a = c ⋅ a implies b = c
}

theorem mul_neg_cancel_left(a: ℤ, b: ℤ, c: ℤ) {
    a < 0 and a ⋅ b = a ⋅ c implies b = c
} 

theorem mul_neg_cancel_right(a: ℤ, b: ℤ, c: ℤ) {
    a < 0 and b ⋅ a = c ⋅ a implies b = c
}

theorem mul_cancel_left(a: ℤ, b: ℤ, c: ℤ) {
    a != 0 and a ⋅ b = a ⋅ c implies b = c
} 

theorem mul_cancel_right(a: ℤ, b: ℤ, c: ℤ) {
    a != 0 and b ⋅ a = c ⋅ a implies b = c
}

theorem divides_cancel_left(a: ℤ, b: ℤ, c: ℤ) {
    a != 0 and (a ⋅ b).divides(a ⋅ c) implies b.divides(c)
} by {
    let d: ℤ satisfy {
        a ⋅ b ⋅ d = a ⋅ c
    }
    a ⋅ (b ⋅ d) = a ⋅ c
    b ⋅ d = c
}

theorem divides_cancel_right(a: ℤ, b: ℤ, c: ℤ) {
    a != 0 and (b ⋅ a).divides(c ⋅ a) implies b.divides(c)
}

theorem divides_mul_left(a: ℤ, b: ℤ, m: ℤ) {
    a.divides(b) implies (m ⋅ a).divides(m ⋅ b)
} by {
    let d: ℤ satisfy {
        d ⋅ a = b
    }
    m ⋅ d ⋅ a = m ⋅ b
}

theorem divides_mul_right(a: ℤ, b: ℤ, m: ℤ) {
    a.divides(b) implies (a ⋅ m).divides(b ⋅ m)
}

theorem one_plus_one {
    1 + 1 = 2
} by {
    2 = from_nat(ℕ.1 + ℕ.1)
}

theorem times_two(a: ℤ) {
    2 ⋅ a = a + a
} by {
    2 = 1 + 1
    2 ⋅ a = (1 + 1) ⋅ a
    2 ⋅ a = 1 ⋅ a + 1 ⋅ a
}

theorem add_lte(a: ℤ, b: ℤ, c: ℤ, d: ℤ) {
    a <= b and c <= d implies a + c <= b + d
} by {
    b + c <= b + d
    a + c <= b + c
    lte_trans(a + c, b + c, b + d)
}

theorem plus_abs_gte_zero(n: ℤ) {
    n + from_nat(abs(n)) >= 0
} by {
    if n < 0 {
        from_nat(abs(n)) = -n
        n + from_nat(abs(n)) = 0
    } else {
        n + from_nat(abs(n)) = n + n
        n + from_nat(abs(n)) >= 0
    }
}

// for definition of ^, see mul.ac
theorem pow_one(a: ℤ) {
    a^(ℕ.1) = a
} 

theorem pow_zero(a: ℤ) {
    a^(ℕ.0) = 1
}

theorem pow_add(a: ℤ, b: ℕ, c: ℕ) {
    a^(b + c) = a^b ⋅ a^c
} 

theorem pow_mul(a: ℤ, b: ℕ, c: ℕ) {
    a^(b ⋅ c) = (a^b)^c
} 

theorem zero_pow(n: ℕ) {
    n != ℕ.0 implies 0^n = 0
} 

theorem one_pow(n: ℕ) {
    1^n = 1
} 

theorem pos_pow(a: ℤ, n: ℕ) {
    a > 0 implies a^n > 0
} by {
    let f = function(x: ℕ) {
        a^x > 0
    }
    f(ℕ.0)
    f(n)
}

theorem square_eq_mul(a: ℤ) {
    a ⋅ a = a^(ℕ.2)
}

theorem square_pos(a: ℤ) {
    a != 0 implies a^(ℕ.2) > 0
}

theorem abs_by_from_nat(a: ℤ) {
    a.abs = from_nat(abs(a))
} by {
    if a > 0 {
        from_nat(abs(a)) = a
        a.abs = a
        abs_by_from_nat(a)
    } else {
        from_nat(abs(a)) = -a
        a.abs = -a
        abs_by_from_nat(a)
    }
}

theorem member_abs_neg(a: ℤ) {
    a < 0 implies a.abs = -a
}

theorem member_abs_nonneg(a: ℤ) {
    a >= 0 implies a.abs = a
}

theorem member_abs_pos(a: ℤ) {
    a > 0 implies a.abs = a
}

theorem member_abs_nonpos(a: ℤ) {
    a <= 0 implies a.abs = -a
}

theorem int_triangle_ineq(a: ℤ, b: ℤ) { 
    (a + b).abs <= (a).abs + (b).abs 
} 

theorem int_triangle_ineq_sub(a: ℤ, b: ℤ) { 
    (a).abs - (b).abs <= (a - b).abs
} 

define gcd(a: ℤ, b: ℤ) -> ℤ {
    from_nat(nat_gcd(abs(a), abs(b)))
}

// port from ℕ

define relative_prime(a: ℤ, b: ℤ) -> Bool {
    nat_relative_prime(abs(a), abs(b))
}

theorem relative_prime_iff_gcd_one(a: ℤ, b: ℤ) {
    relative_prime(a, b) iff a != 0 and b != 0 and gcd(a, b) = 1
} by {
    if relative_prime(a, b) {
        nat_relative_prime(abs(a), abs(b)) 

        abs(a) != ℕ.0 and abs(b) != ℕ.0 and nat_gcd(abs(a), abs(b)) = ℕ.1

        a != 0 and b != 0 and gcd(a, b) = 1
    }
    
    if a != 0 and b != 0 and gcd(a, b) = 1 {
        abs(a) != ℕ.0 and abs(b) != ℕ.0 and nat_gcd(abs(a), abs(b)) = ℕ.1

        nat_relative_prime(abs(a), abs(b))

        relative_prime(a, b)
    }
}

theorem gcd_comm(a: ℤ, b: ℤ) { gcd(a, b) = gcd(b, a) } by {
    from_nat(nat_gcd(abs(a), abs(b))) = from_nat(nat_gcd(abs(b), abs(a)))
}

theorem gcd_one_right(n: ℤ) {
    gcd(n, 1) = 1
} by {
    nat_gcd(abs(n), ℕ.1) = ℕ.1
}

theorem gcd_one_left(n: ℤ) {
    gcd(1, n) = 1
}

theorem gcd_nonzero_left(a: ℤ, b: ℤ) {
    a != 0 implies gcd(a, b) != 0
} by {
    abs(a) != ℕ.0
    nat_gcd(abs(a), abs(b)) != ℕ.0
    gcd(a, b) != 0
}

theorem gcd_nonzero_right(a: ℤ, b: ℤ) {
    b != 0 implies gcd(a, b) != 0
}

theorem gcd_div_left(a: ℤ, b: ℤ) { gcd(a, b).divides(a) } by {
    ℤ.from_nat(nat_gcd(abs(a), abs(b))).divides(a)
}

theorem gcd_div_right(a: ℤ, b: ℤ) { gcd(a, b).divides(b) }

theorem gcd_mult_left(a: ℤ, b: ℤ, m: ℤ) {
    from_nat(abs(m)) ⋅ gcd(a, b) = gcd(m ⋅ a, m ⋅ b)
}

theorem gcd_mult_right(a: ℤ, b: ℤ, m: ℤ) {
    gcd(a, b) ⋅ from_nat(abs(m)) = gcd(a ⋅ m, b ⋅ m)
}

theorem cofactor(a: ℤ, b: ℤ, af: ℤ, bf: ℤ) {
    (
        gcd(a, b) != 0 and
        af ⋅ gcd(a, b) = a and
        bf ⋅ gcd(a, b) = b
    ) implies gcd(af, bf) = 1
} by {
    nat_gcd(abs(a), abs(b)) != ℕ.0
    abs(af) ⋅ nat_gcd(abs(a), abs(b)) = abs(a)
    abs(bf) ⋅ nat_gcd(abs(a), abs(b)) = abs(b)
    nat_gcd(abs(af), abs(bf)) = ℕ.1
}

attributes ℤ {
    define is_prime(self) -> Bool {
        abs(self).is_prime
    }
}

from list import List

theorem euclids_lemma_prime(a: ℤ, b: ℤ, c: ℤ) {
    a.is_prime and a.divides(b ⋅ c) implies a.divides(b) or a.divides(c)
} by {
    abs(a).is_prime 
    abs(a).divides(abs(b) ⋅ abs(c)) 
    abs(a).divides(abs(b)) or abs(a).divides(abs(c))
}

theorem euclids_lemma(a: ℤ, b: ℤ, c: ℤ) {
    gcd(a, b) = 1 and a.divides(b ⋅ c) implies a.divides(c)
} by {
    nat_gcd(abs(a), abs(b)) = ℕ.1
    abs(a).divides(abs(b) ⋅ abs(c))
    abs(a).divides(abs(c))
}

// This is just the ℕ division theorem ported up
theorem positive_division_theorem(m: ℤ, n: ℤ) {
    0 <= m and n.is_positive implies exists(q: ℤ, r: ℤ) {
        0 <= r and r < n and m = q ⋅ n + r
    }
} by {
    let (q: ℕ, r: ℕ) satisfy {
        r < abs(n) and abs(m) = q ⋅ abs(n) + r
    }
    0 <= from_nat(r)
    from_nat(r) < n
    from_nat(abs(m)) = from_nat(q ⋅ abs(n) + r)
    m = from_nat(q ⋅ abs(n) + r)
    m = from_nat(q) ⋅ from_nat(abs(n)) + from_nat(r)
}

// Dividing negative numbers is awkward, sometimes you're off by one
theorem negative_division_theorem(m: ℤ, n: ℤ) {
    m.is_negative and n.is_positive implies exists(q: ℤ, r: ℤ) {
        0 <= r and r < n and m = q ⋅ n + r
    }
} by {
    0 <= -m
    let (qn: ℤ, rn: ℤ) satisfy {
        0 <= rn and rn < n and -m = qn ⋅ n + rn
    }
    m = (-qn) ⋅ n + -rn
    if rn = 0 {
        negative_division_theorem(m, n)
    } else {
        rn > 0
        (-qn + -1) ⋅ n = (-qn) ⋅ n + -n
        (-qn) ⋅ n = (-qn + -1) ⋅ n + n
        m = (-qn) ⋅ n + -rn
        m = (-qn + -1) ⋅ n + (n + -rn)
        rn < n
        0 < n + -rn
        0 <= n + -rn
        -rn < 0
        n + -rn < n
        negative_division_theorem(m, n)
    }
}

// The entire division theorem is combining the two cases
theorem division_theorem(m: ℤ, n: ℤ) {
    n.is_positive implies exists(q: ℤ, r: ℤ) {
        0 <= r and r < n and m = q ⋅ n + r
    }
} by {
    if m.is_negative {
        division_theorem(m, n)
    } else {
        0 <= m
        division_theorem(m, n)
    }
}

theorem abs_pow_comm(a: ℤ, n: ℕ) {
    abs(a^n) = abs(a)^n
} by {
    let f = function(x: ℕ) {
        abs(a^x) = abs(a)^x
    }
    a^(ℕ.0) = 1
    ℕ.1 >= ℕ.0
    abs(1) = ℕ.1
    abs(a)^(ℕ.0) = ℕ.1
    f(ℕ.0)
    forall(x: ℕ) {
        if f(x) {
            abs(a^x) = abs(a)^x
            abs(a^(x.suc)) = abs(a)^(x.suc)
            f(x.suc)
        }
    }
    f(n)
}

theorem prime_divide_power(p: ℤ, a: ℤ, n: ℕ) {
    p.is_prime and n != ℕ.0 and p.divides(a^n) implies p.divides(a) 
} by {
    (abs(p)).divides(abs(a^n))
    (abs(p)).divides(abs(a)^n)
    (abs(p)).divides(abs(a))
    p.divides(a)
}

define have_common_prime_factor(a: ℤ, b: ℤ) -> Bool {
    exists(p: ℤ) {
        p.is_prime and p.divides(a) and p.divides(b)
    }
}

theorem power_preserve_relative_prime(a: ℤ, b: ℤ, n: ℕ, m: ℕ) {
    relative_prime(a, b) and n != ℕ.0 and m != ℕ.0 implies relative_prime(a^n, b^m)
} by {
    nat_relative_prime(abs(a), abs(b))
    nat_relative_prime(abs(a)^n, abs(b)^m)
    relative_prime(a^n, b^m)
}

theorem power_preserve_gcd_one(a: ℤ, b: ℤ, n: ℕ, m: ℕ) {
    a != 0 and b != 0 and gcd(a, b) = 1 and n != ℕ.0 and m != ℕ.0 implies gcd(a^n, b^m) = 1
}

theorem gcd_one_and_divide_imp_one(a: ℤ, b: ℤ) {
    a != 0 and gcd(a, b) = 1 and a.divides(b) implies a = 1 or a = -1
} by {
    nat_gcd(abs(a), abs(b)) = ℕ.1
    abs(a) != ℕ.0
    (abs(a)).divides(abs(b))
    abs(a) = ℕ.1
}