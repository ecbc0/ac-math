from nat import ℕ

/// The `ℤ` type represents integers.
/// It's defined by its two constructors.
///
/// `pos_suc` takes a natural number to an integer, which seems intuitive.
/// `neg_suc` takes `x` to `-(x+1)`, which is somewhat less intuitive. We do this so
/// that every integer can be represented either as a `pos_suc` or a `neg_suc`.
///
/// ```acorn
/// numerals ℤ
///
/// 2 = pos_suc(ℕ.2)
/// -2 = ℤ.neg_suc(ℕ.1)
/// ```
inductive ℤ {
    /// `ℤ.neg_suc` converts a natural number `x` into `-(x+1)`.
    /// This isn't particularly intuitive, it's just to give every integer a unique constructor.
    /// In particular, `neg_suc` can construct any negative integer, but not zero.
    neg_suc(ℕ)

    0

    /// `pos_suc` converts a natural number to an integer via the typical embedding.
    pos_suc(ℕ)
}

let pos_suc = ℤ.pos_suc
let neg_suc = ℤ.neg_suc

attributes ℤ {
    /// The integer zero.
    /// The integer one.
    let 1: ℤ = pos_suc(ℕ.0)
    /// The integer two.
    let 2: ℤ = pos_suc(ℕ.1)
    /// The integer three.
    let 3: ℤ = pos_suc(ℕ.2)
    /// The integer four.
    let 4: ℤ = pos_suc(ℕ.3)
    /// The integer five.
    let 5: ℤ = pos_suc(ℕ.4)
    /// The integer six.
    let 6: ℤ = pos_suc(ℕ.5)
    /// The integer seven.
    let 7: ℤ = pos_suc(ℕ.6)
    /// The integer eight.
    let 8: ℤ = pos_suc(ℕ.7)
    /// The integer nine.
    let 9: ℤ = pos_suc(ℕ.8)
    /// The integer ten.
    let 10: ℤ = pos_suc(ℕ.9)
}

numerals ℤ

theorem one_neq_zero { 1 != 0 } 

/// Yields the absolute value of an integer as a natural number.
define abs(a: ℤ) -> ℕ {
    match a {
        pos_suc(n) {
            n.suc
        }

        0 {
            ℕ.0
        }

        neg_suc(k) {
            k.suc
        }
    }
}

theorem abs_zero { abs(0) = ℕ.0 }

theorem abs_pos_suc(n: ℕ) {
    abs(pos_suc(n)) = n.suc
}

attributes ℤ {
    /// The negation of an integer.
    define neg(self) -> ℤ {
        match self {
            pos_suc(n) {
                neg_suc(n)
            }

            0 {
                0
            }

            neg_suc(n) {
                pos_suc(n)
            }
        }
    }
}

theorem neg_neg_suc(n: ℕ) {
    -neg_suc(n) = pos_suc(n)
}

theorem neg_pos_suc(n: ℕ) {
    -pos_suc(n) = neg_suc(n)
}

attributes ℤ {
    let from_nat: ℕ -> ℤ = function(n: ℕ) {
        if n = ℕ.0 {
            0
        } else {
            pos_suc(n - ℕ.1)
        }
    }
}

let from_nat = ℤ.from_nat

theorem numerals_from_nat {
    1 = from_nat(ℕ.1) and
    2 = from_nat(ℕ.2) and
    3 = from_nat(ℕ.3) and
    4 = from_nat(ℕ.4) and
    5 = from_nat(ℕ.5) and
    6 = from_nat(ℕ.6) and
    7 = from_nat(ℕ.7) and
    8 = from_nat(ℕ.8) and
    9 = from_nat(ℕ.9) and
    10 = from_nat(ℕ.10)
} by {
    from_nat(ℕ.1) = pos_suc(ℕ.0)
    from_nat(ℕ.2) = pos_suc(ℕ.1)
    from_nat(ℕ.3) = pos_suc(ℕ.2)
    from_nat(ℕ.4) = pos_suc(ℕ.3)
    from_nat(ℕ.5) = pos_suc(ℕ.4)
    from_nat(ℕ.6) = pos_suc(ℕ.5)
    from_nat(ℕ.7) = pos_suc(ℕ.6)
    from_nat(ℕ.8) = pos_suc(ℕ.7)
    from_nat(ℕ.9) = pos_suc(ℕ.8)
    from_nat(ℕ.10) = pos_suc(ℕ.9)
}

theorem pos_from_nat(n: ℕ) {
    from_nat(n.suc) = pos_suc(n)
}

theorem pos_from_nat_exists(m: ℕ) {
    m != ℕ.0 implies exists(n: ℕ) {
        from_nat(m) = pos_suc(n)
    } 
}

theorem pos_from_nat_pred(n: ℕ, m: ℕ) {
    m = n.suc implies from_nat(m) = pos_suc(n)
}

theorem pos_from_int_pred(k: ℤ, n: ℕ) {
    k = pos_suc(n) implies k = from_nat(n.suc)
}

theorem neg_from_nat(n: ℕ) {
    if n = ℕ.0 {
        -from_nat(n) = 0
    } else {
        -from_nat(n) = neg_suc(n -  ℕ.1)
    }
} by {
    if n = ℕ.0 {
        from_nat(n) = 0
        -from_nat(n) = 0
    } else {
        from_nat(n) = pos_suc(n - ℕ.1)
        -from_nat(n) = neg_suc(n - ℕ.1)
    }
}

/// or `back_to_nat` compare to `from_nat`
theorem abs_from_nat(n: ℕ) {
    abs(from_nat(n)) = n
} by {
    if n = ℕ.0 {
        abs(from_nat(n)) = n
    } else {
        let k: ℕ satisfy { 
            from_nat(n) = pos_suc(k)
        }
        from_nat(n) = pos_suc(k)
        abs(from_nat(n)) = k.suc 
        k = n - ℕ.1
        k.suc = n
        abs(from_nat(n)) = n
    }
}

theorem abs_neg_from_nat(n: ℕ) {
    abs(-from_nat(n)) = n
} by {
    if n = ℕ.0 {
        abs(-from_nat(n)) = n
    } else {
        let k: ℕ satisfy { 
            from_nat(n) = pos_suc(k)
        }
        -from_nat(n) = neg_suc(k)
        abs(-from_nat(n)) = k.suc 
        k = n - ℕ.1
        k.suc = n
        abs(-from_nat(n)) = n
    }
}

theorem from_nat_embed(m: ℕ, n: ℕ) {
    from_nat(m) = from_nat(n) implies m = n
}

theorem from_nat_embed_neg_dual(m: ℕ, n: ℕ) {
    m != n implies from_nat(m) != from_nat(n)
}

theorem neg_neg(a: ℤ) {
    -(-a) = a
} by {
    // helper
    match a {
        pos_suc(pred) {
            -(-a) = a
        }

        0 {
            -(-a) = a
        }

        neg_suc(pred) {
            -(-a) = a
        }
    }
}

theorem fix_neg(a: ℤ) {
    -a = a implies a = 0
} by {
    // helper
    if -a = a {
        match a {
            pos_suc(n) {
                -a != a
                false
            }

            0 {
                a = 0
            }

            neg_suc(n) {
                -a != a
                false
            }
        }
    }
}

theorem abs_neg(a: ℤ) {
    abs(-a) = abs(a)
} by {
    match a {
        pos_suc(pred) {
            abs(-a) = abs(a)
        }

        0 {
            abs(-a) = abs(a)
        }

        neg_suc(pred) {
            abs(-a) = abs(a)
        }
    }
}

theorem neg_or_pos(a: ℤ) {
    a = from_nat(abs(a)) or a = -(from_nat(abs(a)))
} by {
    match a {
        pos_suc(pred) {
            abs(a) = pred.suc
            from_nat(pred.suc) = pos_suc(pred.suc - ℕ.1)
            from_nat(pred.suc) = pos_suc(pred)
            a = from_nat(abs(a))
        }

        0 {
            a = from_nat(abs(a)) or a = -(from_nat(abs(a)))
        }

        neg_suc(pred) {
            abs(a) = pred.suc
            from_nat(pred.suc) = pos_suc(pred.suc - ℕ.1)
            from_nat(pred.suc) = pos_suc(pred)
            a = -from_nat(abs(a))        
        }
    }
}

theorem from_eq_neg_from(p: ℕ, q: ℕ) {
    from_nat(p) = -(from_nat(q)) implies p = ℕ.0 and q = ℕ.0
} by {
    abs(from_nat(p)) = abs(-(from_nat(q)))
    abs(from_nat(p)) = abs(from_nat(q))
    p = q
    from_nat(p) = -(from_nat(p))
    from_nat(p) = 0
}

// Subtraction that goes from naturals into integers.
// We will use this as the primary representation for proving things about integers, so we prove
// as many useful things about sub_nat as we can, before defining more stuff.
// the remaining cases is easy, e.g. if m >= 0 and n <= 0 then m - n = m + (-n)
define sub_nat(m: ℕ, n: ℕ) -> ℤ {
    if n <= m {
        from_nat(m - n)
    } else {
        -from_nat(n - m)
    }
}

theorem sub_nat_self(m: ℕ, n: ℕ) {
    m = n implies sub_nat(m, n) = 0
}

theorem neg_sub_nat(m: ℕ, n: ℕ) { 
    sub_nat(m, n) = -(sub_nat(n, m)) 
} by {
    if n < m {
        sub_nat(m, n) = from_nat(m - n)
        not (m <= n)
        sub_nat(n, m) = -from_nat(m - n)

        sub_nat(m, n) = -(sub_nat(n, m))
    } 
    if m < n {
        sub_nat(n, m) = from_nat(n - m)
        not (n <= m)
        sub_nat(m, n) = -from_nat(n - m)

        sub_nat(m, n) = -(sub_nat(n, m))
    }
}

theorem sub_nat_zero_right(n: ℕ) {
    sub_nat(n, ℕ.0) = from_nat(n)
} by {
    ℕ.0 <= n
    from_nat(n - ℕ.0) = sub_nat(n, ℕ.0)
}

theorem sub_nat_zero_left(n: ℕ) { 
    sub_nat(ℕ.0, n) = -(from_nat(n)) 
} 

theorem sub_nat_cancel_add_pos(p: ℕ, q: ℕ) {
    sub_nat(p + q, q) = from_nat(p)
} by {
    q <= p + q
}

theorem sub_nat_cancel_add_neg(p: ℕ, q: ℕ) { 
    sub_nat(p, p + q) = -(from_nat(q)) 
}

/// i - j = k => i = j + k
theorem sub_nat_imp_add(i: ℕ, j: ℕ, k: ℕ) {
    sub_nat(i, j) = from_nat(k) implies j + k = i
} by {
    if j <= i {
        let (d: ℕ) satisfy { j + d = i }
        sub_nat(i, j) = from_nat(d)
        d = k
        j + k = i
    } else {
        let (d: ℕ) satisfy { i + d = j }
        sub_nat(i, j) = -(from_nat(d))
        from_nat(k) = -(from_nat(d))
        k = ℕ.0
        d = ℕ.0
        i = j
        false
    }
}

theorem sub_nat_pos_iff_add(i: ℕ, j: ℕ, k: ℕ) {
    sub_nat(i, j) = from_nat(k) iff j + k = i
} by {
    j + k = i implies sub_nat(i, j) = from_nat(k)
}

/// i - j = -k => j = i + k
theorem sub_nat_neg_imp_add(i: ℕ, j: ℕ, k: ℕ) {
    sub_nat(i, j) = -from_nat(k) iff i + k = j
} by {
    sub_nat(i, j) = -from_nat(k) implies sub_nat(j, i) = from_nat(k)

    sub_nat(i, j) = -from_nat(k) implies i + k = j
}

// Half of a "without loss of generality" argument
theorem sub_nat_eq_helper(m: ℕ, n: ℕ, p: ℕ, q: ℕ) {
    p <= m implies (
        m + n = p + q iff sub_nat(m, p) = sub_nat(q, n)
    )
} by {
    let (d: ℕ) satisfy { p + d = m }
    sub_nat(m, p) = from_nat(d)
    m + n = p + d + n
    if m + n = p + q {
        p + q = p + d + n
        q = d + n
        sub_nat(q, n) = from_nat(d)
        sub_nat(m, p) = sub_nat(q, n)
    }
    if sub_nat(m, p) = sub_nat(q, n) {
        sub_nat(q, n) = from_nat(d)
        q = d + n
        p + q = p + d + n
        p + q = m + n
    }
}

theorem sub_nat_eq(m: ℕ, n: ℕ, p: ℕ, q: ℕ) {
    m + n = p + q iff sub_nat(m, p) = sub_nat(q, n)
} by {
    if p <= m {
        sub_nat_eq_helper(m, n, p, q)
        sub_nat_eq(m, n, p, q)
    } else {
        m <= p
        sub_nat_eq_helper(p, q, m, n)

        p + q = m + n iff sub_nat(p, m) = sub_nat(n, q)
        sub_nat(m, p) = -sub_nat(p, m)
        sub_nat(q, n) = -sub_nat(n, q)

        p + q = m + n implies sub_nat(m, p) = sub_nat(q, n)

        sub_nat_eq(m, n, p, q)
    }
}

theorem sub_nat_cancel_pos(i: ℕ, j: ℕ, k: ℕ) { 
    sub_nat(i, k) = sub_nat(j, k) iff i = j 
} 

theorem sub_nat_cancel_neg(i: ℕ, j: ℕ, k: ℕ) {
    sub_nat(k, i) = sub_nat(k, j) iff i = j
} 

theorem sub_nat_both_add_cancel_right(m: ℕ, n: ℕ, k: ℕ) {
    sub_nat(m, n) = sub_nat(m + k, n + k)
} by {
    m + (n + k) = n + (m + k)
}

theorem sub_nat_both_add_cancel_left(m: ℕ, n: ℕ, k: ℕ) {
    sub_nat(m, n) = sub_nat(k + m, k + n)
}

theorem sub_nat_cancel_add_pos_augment(p: ℕ, q: ℕ, r: ℕ, s: ℕ, t: ℕ) {
    sub_nat(p + t, q) = sub_nat(r + t, s) iff sub_nat(p, q) = sub_nat(r, s)
} by {
    sub_nat(p + t, q) = sub_nat(r + t, s) implies sub_nat(p, q) = sub_nat(r, s)
}

theorem sub_nat_cancel_add_neg_augment(p: ℕ, q: ℕ, r: ℕ, s: ℕ, t: ℕ) {
    sub_nat(p, q + t) = sub_nat(r, s + t) implies sub_nat(p, q) = sub_nat(r, s)
} 

// Now that we've proven a bunch of stuff about sub_nat, we define the positive and negative parts so that we can
// represent each integer as a sub_nat, and start defining useful functions on integers.

attributes ℤ {
    /// True if the integer is negative.
    define is_negative(self) -> Bool {
        self != from_nat(abs(self))
    }

    /// True if the integer is positive.
    define is_positive(self) -> Bool {
        (-self).is_negative
    }
}

theorem zero_not_neg { not 0.is_negative }

theorem zero_not_pos { not 0.is_positive }

theorem one_pos { 1.is_positive } by {
    (-from_nat(ℕ.1)).is_negative
    from_nat(ℕ.1) = 1
    (-1).is_negative
}

theorem neg_iff_not_pos(a: ℤ) {
    a != 0 implies (a.is_negative iff not a.is_positive)
} by {
    a.is_negative implies not a.is_positive
}

theorem nonzero_pos_or_neg(a: ℤ) {
    a != 0 implies a.is_positive or a.is_negative
} 

theorem pos_is_not_neg(a: ℤ) { 
    a.is_positive implies not a.is_negative 
}

theorem non_pos_is_neg_abs(a: ℤ) { 
    not a.is_positive implies a = -(from_nat(abs(a))) 
} by {
    from_nat(abs(a)) = -a
}

theorem non_neg_is_abs(a: ℤ) { 
    not a.is_negative implies a = from_nat(abs(a))
} 

theorem neg_from_suc(a: ℤ) {
    a.is_negative implies exists(n: ℕ) { a = neg_suc(n) }
} by {
    not a.is_positive
    a = -(from_nat(abs(a)))
    abs(a) != ℕ.0
    let pred: ℕ satisfy { 
        from_nat(abs(a)) = pos_suc(pred) 
    }
    a = neg_suc(pred)
    exists(n: ℕ) { a = neg_suc(n) }
}

theorem neg_from_suc_imp_revert(a: ℤ) {
    exists(n: ℕ) { a = neg_suc(n) } implies a.is_negative
} by {
    let pred: ℕ satisfy { a = neg_suc(pred) }
    abs(a) = pred.suc
    from_nat(abs(a)) = pos_suc(pred.suc - ℕ.1)
    from_nat(abs(a)) = pos_suc(pred)
    a != from_nat(abs(a))
    a.is_negative
}

attributes ℤ {
    /// The positive part of this integer.
    define pos_part(self) -> ℕ {
        if self.is_positive {
            abs(self)
        } else {
            ℕ.0
        }
    }

    /// The negative part of this integer.
    define neg_part(self) -> ℕ {
        if self.is_positive {
            ℕ.0
        } else {
            abs(self)
        }
    }
}

theorem sub_nat_parts(a: ℤ) { 
    sub_nat(a.pos_part, a.neg_part) = a 
} by {
    if a.is_positive {
        sub_nat(abs(a), ℕ.0) = a
        sub_nat(a.pos_part, a.neg_part) = a
    } else {
        sub_nat(ℕ.0, abs(a)) = a
        sub_nat(a.pos_part, a.neg_part) = a
    }
}

theorem pos_part_neg(a: ℤ) { 
    (-a).pos_part = a.neg_part 
} by {
    if a.is_positive {
        a.neg_part = ℕ.0
        not (-a).is_positive
        (-a).pos_part = ℕ.0
        (-a).pos_part = a.neg_part
    } else {
        a.neg_part = abs(a)
        not (-a).is_negative
        (-a).pos_part = abs(-a)
        (-a).pos_part = abs(a)
        (-a).pos_part = a.neg_part
    }
}

theorem pos_part_from(n: ℕ) { 
    from_nat(n).pos_part = n 
} by {
    if n = ℕ.0 {
        from_nat(n).pos_part = n
    } else {
        from_nat(n).pos_part = abs(from_nat(n))
        from_nat(n).pos_part = n
    }
}

theorem neg_part_from(n: ℕ) {
    from_nat(n).neg_part = ℕ.0
} by {
    if from_nat(n).is_positive {
        from_nat(n).neg_part = ℕ.0
    } else {
        from_nat(n).neg_part = abs(from_nat(n))
        from_nat(n).neg_part = ℕ.0
    }
}

theorem neg_part_neg(a: ℤ) { 
    (-a).neg_part = a.pos_part 
}

// Addition, and theorems about addition
// This method to define add of ℤ seems more convenient than nested if else in current Acorn?
attributes ℤ {
    /// The sum of two integers.
    define add(self, other: ℤ) -> ℤ {
        sub_nat(
            self.pos_part + other.pos_part, 
            self.neg_part + other.neg_part
        )
    }
}

theorem add_zero_left(a: ℤ) { 
    (0 + a) = a 
} by {
    0.pos_part = ℕ.0
    0.neg_part = ℕ.0
    0.pos_part + a.pos_part = a.pos_part
    0.neg_part + a.neg_part = a.neg_part
    (0 + a) = sub_nat(a.pos_part, a.neg_part)
}

theorem add_zero_right(a: ℤ) { 
    a + 0 = a 
} by {
    0.pos_part = ℕ.0
    0.neg_part = ℕ.0
    a.pos_part + 0.pos_part = a.pos_part
    a.neg_part + 0.neg_part = a.neg_part
    a + 0 = sub_nat(a.pos_part, a.neg_part)
}

theorem add_comm(a: ℤ, b: ℤ) { 
    a + b = b + a 
} by {
    a + b = sub_nat(
        a.pos_part + b.pos_part, 
        a.neg_part + b.neg_part
    )
}

theorem neg_distrib(a: ℤ, b: ℤ) { 
    -(a + b) = -a + -b 
} by {
    (-a).pos_part + (-b).pos_part = a.neg_part + b.neg_part
    (-a).neg_part + (-b).neg_part = a.pos_part + b.pos_part
    -a + -b = sub_nat(
        (-a).pos_part + (-b).pos_part,
        (-a).neg_part + (-b).neg_part
    )
    -a + -b = sub_nat(
        a.neg_part + b.neg_part,
        a.pos_part + b.pos_part
    )
    -a + -b = -sub_nat(
        a.pos_part + b.pos_part, 
        a.neg_part + b.neg_part
    )
}

theorem add_neg(a: ℤ) { 
    a + -a = 0 
} by {
    a + -a = sub_nat(
        a.pos_part + (-a).pos_part, 
        a.neg_part + (-a).neg_part
    )
    a + -a = sub_nat(
        a.pos_part + a.neg_part, 
        a.neg_part + a.pos_part
    )
    a + -a = 0
}

theorem neg_eq_zero(a: ℤ) {
    -a = 0 iff a = 0
} by {
    -a = 0 implies a = 0
}

theorem sub_nat_as_add_int(a: ℕ, b: ℕ) {
    sub_nat(a, b) = from_nat(a) + -from_nat(b)
}

theorem add_sub_nat_left_pos(p: ℕ, q: ℕ, r: ℕ) {
    (sub_nat(p, q) + from_nat(r)) = sub_nat(p + r, q)
} by {
    (sub_nat(p, q) + from_nat(r)) = sub_nat(
        sub_nat(p, q).pos_part + from_nat(r).pos_part,
        sub_nat(p, q).neg_part + from_nat(r).neg_part
    )

    from_nat(r).pos_part = r
    from_nat(r).neg_part = ℕ.0
    
    (sub_nat(p, q) + from_nat(r)) = sub_nat(
        sub_nat(p, q).pos_part + r,
        sub_nat(p, q).neg_part
    )

    sub_nat(p + r, q) = sub_nat(
        sub_nat(p, q).pos_part + r, 
        sub_nat(p, q).neg_part
    )
}

theorem add_sub_nat_left_neg(p: ℕ, q: ℕ, r: ℕ) {
    (sub_nat(p, q) + -(from_nat(r))) = sub_nat(p, q + r)
} by {
    (sub_nat(p, q) + -(from_nat(r))) = -(sub_nat(q, p) + from_nat(r))

    (sub_nat(p, q) + -(from_nat(r))) = -(sub_nat(q + r, p))

    -(sub_nat(q + r, p)) = sub_nat(p, q + r)
}

theorem add_sub_nat_left(p: ℕ, q: ℕ, a: ℤ) {
    (sub_nat(p, q) + a) = sub_nat(
        p + a.pos_part, 
        q + a.neg_part
    )
} by {
    if a.is_positive {
        (sub_nat(p, q) + a) = (sub_nat(p, q) + from_nat(abs(a)))

        (sub_nat(p, q) + a) = sub_nat(p + abs(a), q)

        (sub_nat(p, q) + a) = sub_nat(p + a.pos_part, q)

        (sub_nat(p, q) + a) = sub_nat(p + a.pos_part, q + a.neg_part)
    } else {
        (sub_nat(p, q) + a) = (sub_nat(p, q) + -(from_nat(abs(a))))

        (sub_nat(p, q) + a) = sub_nat(p, q + abs(a))

        (sub_nat(p, q) + a) = sub_nat(p, q + a.neg_part)

        (sub_nat(p, q) + a) = sub_nat(p + a.pos_part, q + a.neg_part)
    }
}

theorem add_sub_nat_right(p: ℕ, q: ℕ, a: ℤ) {
    a + sub_nat(p, q) = sub_nat(a.pos_part + p, a.neg_part + q)
}

theorem add_sub_nat(p: ℕ, q: ℕ, r: ℕ, s: ℕ) {
    (sub_nat(p, q) + sub_nat(r, s)) = sub_nat(p + r, q + s)
} by {
    (sub_nat(p, q) + sub_nat(r, s)) = sub_nat(
        p + sub_nat(r, s).pos_part,
        q + sub_nat(r, s).neg_part
    )
    // if we want to prove sub(a, b) = sub(c, d), use a + d = b + c, i.e. sub_nat_eq
    // so we need to prove 
    //     (p + sub_nat(r, s).pos_part) + (q + s) = (q + sub_nat(r, s).neg_part) + (p + r)
    // and use 
    //    sub(r, s) = sub(sub_nat(r, s).pos_part, sub_nat(r, s).neg_part)
    // and again use sub_nat_eq
    r + sub_nat(r, s).neg_part = s + sub_nat(r, s).pos_part
    // add two side with p + q, and use comm and assoc of nat
    p + q + (r + sub_nat(r, s).neg_part) = p + q + (s + sub_nat(r, s).pos_part)

    p + r + (q + sub_nat(r, s).neg_part) = q + s + (p + sub_nat(r, s).pos_part)

    sub_nat(p + r, q + s) = sub_nat(
        p + sub_nat(r, s).pos_part,
        q + sub_nat(r, s).neg_part
    )
}

theorem add_sub_nat_3_left(p: ℕ, q: ℕ, r: ℕ, s: ℕ, t: ℕ, u: ℕ) {
    sub_nat(p, q) + sub_nat(r, s) + sub_nat(t, u) = sub_nat((p + r) + t, (q + s) + u)
} by {
    let lhs = sub_nat(p, q) + sub_nat(r, s) + sub_nat(t, u)
    lhs = sub_nat(p + r, q + s) + sub_nat(t, u)
    lhs = sub_nat((p + r) + t, (q + s) + u)
}

theorem add_sub_nat_3_right(p: ℕ, q: ℕ, r: ℕ, s: ℕ, t: ℕ, u: ℕ) {
    sub_nat(p, q) + (sub_nat(r, s) + sub_nat(t, u)) = sub_nat(p + (r + t), q + (s + u))
} by {
    let lhs = sub_nat(p, q) + (sub_nat(r, s) + sub_nat(t, u))
    lhs = (sub_nat(p, q) + sub_nat(r + t, s + u))
    lhs = sub_nat(p + (r + t), q + (s + u))
}

theorem add_sub_nat_assoc(p: ℕ, q: ℕ, r: ℕ, s: ℕ, t: ℕ, u: ℕ) {
    (sub_nat(p, q) + sub_nat(r, s)) + sub_nat(t, u) = sub_nat(p, q) + (sub_nat(r, s) + sub_nat(t, u))
} by {
    let lhs = sub_nat(p, q) + sub_nat(r, s) + sub_nat(t, u)
    lhs = sub_nat((p + r) + t, (q + s) + u)
    lhs = sub_nat(p + (r + t), q + (s + u))
    lhs = sub_nat(p, q) + (sub_nat(r, s) + sub_nat(t, u))
}

theorem add_assoc(a: ℤ, b: ℤ, c: ℤ) { (a + b) + c = a + (b + c) } by {
    a = sub_nat(a.pos_part, a.neg_part)
    b = sub_nat(b.pos_part, b.neg_part)
    c = sub_nat(c.pos_part, c.neg_part)

    add_sub_nat_assoc(
        a.pos_part, a.neg_part, 
        b.pos_part, b.neg_part, 
        c.pos_part, c.neg_part
    )
}

from type_class.add import P_Add, Add, left_cancel

instance ℤ: P_Add {
    let add = ℤ.add
   
    let 0 = ℤ.0
}

instance ℤ: Add {
    let neg = ℤ.neg
}

theorem add_eq_zero(a: ℤ, b: ℤ) { 
    a + b = 0 iff a = -b 
} by {
    a + b = 0 implies a = -b 
}

theorem add_left_cancel(a: ℤ, b: ℤ, c: ℤ) { 
    c + a = c + b implies a = b 
} by {
    left_cancel(a, b, c)
}

theorem add_right_cancel(a: ℤ, b: ℤ, c: ℤ) { 
    a + c = b + c implies a = b 
} 

theorem add_from_nat(a: ℕ, b: ℕ) {
    from_nat(a) + from_nat(b) = from_nat(a + b)
}

theorem add_pos_nonneg(a: ℤ, b: ℤ) {
    a.is_positive and not b.is_negative implies (a + b).is_positive
} by {
    if b = 0 {
        a + b = a
        (a + b).is_positive
    } else {
        b.is_positive
        a = from_nat(abs(a))
        b = from_nat(abs(b))
        a + b = from_nat(abs(a) + abs(b))
        abs(a) + abs(b) != ℕ.0
        (a + b).is_positive
    }
}

theorem add_neg_nonpos(a: ℤ, b: ℤ) {
    a.is_negative and not b.is_positive implies (a + b).is_negative
} by {
    (-a).is_positive
    not (-b).is_negative
    (-a + -b).is_positive
    (-(a + b)).is_positive
}

theorem add_nonneg_nonneg(a: ℤ, b: ℤ) {
    not a.is_negative and not b.is_negative implies not (a + b).is_negative
} by {
    if a = 0 and b = 0 {
        a + b = 0
        not (a + b).is_negative
    } 
    if a != 0 {
        a.is_positive
        (a + b).is_positive
        not (a + b).is_negative
    }
    if b != 0 {
        b.is_positive
        (a + b).is_positive
        not (a + b).is_negative
    }
}

theorem add_nonpos_nonpos(a: ℤ, b: ℤ) {
    not a.is_positive and not b.is_positive implies not (a + b).is_positive
} 

theorem add_comm_4(a: ℤ, b: ℤ, c: ℤ, d: ℤ) { 
    (a + b) + (c + d) = (a + c) + (b + d) 
} by {
    a + (b + c) = a + c + b
}

// define sub(self, other: A) -> A { self + -other }

// Subtraction, and theorems about subtraction

theorem sub_zero_right(a: ℤ) { a - 0 = a } 

theorem sub_zero_left(a: ℤ) { 0 - a = -a } 

theorem sub_anticomm(a: ℤ, b: ℤ) { 
    a - b = -(b - a) 
} 

theorem sub_self(a: ℤ) { a - a = 0 }

theorem sub_eq_zero(a: ℤ, b: ℤ) { a - b = 0 iff a = b } by { 
    a - b = 0 implies a = b 
}

theorem sub_add_left(a: ℤ, b: ℤ) {
    (a + b) - b = a
} by {
    a + (b + -b) = a
}

theorem sub_add_right(a: ℤ, b: ℤ) { a - (a + b) = -b }

theorem sub_imp_add(a: ℤ, b: ℤ, c: ℤ) { a - b = c implies b + c = a } by {
    (a - b) + b = a
}

theorem sub_negate_imp_add(a: ℤ, b: ℤ, c: ℤ) { 
    a - b = -c implies a + c = b 
}

theorem sub_cancel_right(a: ℤ, b: ℤ, c: ℤ) { 
    a - c = b - c implies a = b 
}

theorem sub_cancel_left(a: ℤ, b: ℤ, c: ℤ) { 
    a - b = a - c implies b = c 
}

theorem sub_add_cancel_left(a: ℤ, b: ℤ, c: ℤ) { 
    (a + b) - (a + c) = b - c 
} by {
    b + a + -(a + c) = b - c
}

theorem sub_add_cancel_right(a: ℤ, b: ℤ, c: ℤ) { 
    (a + c) - (b + c) = a - b 
}

// Comparison operators

attributes ℤ {
    /// `a < b` when `(a - b)` is positive
    define lt(self, other: ℤ) -> Bool {
        (other - self).is_positive
    }

    define lte(self, other: ℤ) -> Bool {
        self < other or self = other
    }

    define gt(self, other: ℤ) -> Bool {
        other < self
    }

    define gte(self, other: ℤ) -> Bool {
        other <= self
    }
}

from util import is_acyclic, is_transitive

theorem lt_trans(a: ℤ, b: ℤ, c: ℤ) {
    a < b and b < c implies a < c
} by {
    (b - a).is_positive
    (c - b).is_positive
    ((c - b) + (b - a)).is_positive
    (c - a).is_positive
    a < c
}

theorem int_is_transitive {
    is_transitive(ℤ.lt)
}

theorem lt_acyclic(a: ℤ, b: ℤ) {
    not (a < b and b < a) 
}

theorem int_is_acyclic {
    is_acyclic(ℤ.lt)
}

from order import Partial_Order, Linear_Order
from util import Inhabited

instance ℤ: Inhabited {
    let default = 0
}

instance ℤ: Partial_Order {
    let lt = ℤ.lt
}

theorem zero_lt_pos(a: ℤ) { 
    a.is_positive iff 0 < a 
}

theorem neg_lt_zero(a: ℤ) {
    a.is_negative iff a < 0
} 

theorem zero_lte_nonneg(a: ℤ) { 
    not a.is_negative iff 0 <= a 
} by {
    not a.is_negative implies 0 <= a 
}

theorem nonpos_lt_zero(a: ℤ) {
    not a.is_positive iff a <= 0
} by {
    not a.is_positive implies a <= 0
}

theorem zero_lte_from_nat(n: ℕ) {
    0 <= from_nat(n)
}

theorem from_nat_gte_zero(n: ℕ) {
    from_nat(n) >= 0
}

theorem int_total(a: ℤ, b: ℤ) { 
    a < b or a = b or a > b 
} by {
    (b - a) = 0 or (b - a).is_positive or (b - a).is_negative
}

instance ℤ: Linear_Order
from order import gt_is_not_lte as order_gt_is_not_lte

theorem gt_is_not_lte(a: ℤ, b: ℤ) { 
    a > b iff not a <= b 
} by {
    a > b implies not a <= b 
}

theorem compare_by_zero(a: ℤ, b: ℤ) {
    a - b > 0 iff a > b
}

theorem lte_zero_abs(a: ℤ) {
    a <= 0 implies from_nat(abs(a)) = -a
}

theorem gte_zero_abs(a: ℤ) {
    a >= 0 implies from_nat(abs(a)) = a
}

theorem from_nat_preserve_lt(n: ℕ, m: ℕ) {
    from_nat(n) < from_nat(m) iff n < m
} by {
    from_nat(m) - from_nat(n) = sub_nat(m, n)
    if from_nat(n) < from_nat(m) {
        0 < (from_nat(m) - from_nat(n))
        sub_nat(m, n) > 0
        n <= m
        m - n != ℕ.0
        n < m
    }
}

theorem from_nat_preserve_lte(n: ℕ, m: ℕ) {
    from_nat(n) <= from_nat(m) iff n <= m
} by {
    from_nat(n) <= from_nat(m) implies n <= m
}

// Integer-natural multiplication

attributes ℤ {
    /// Multiply this integer by a natural number.
    define mul_nat(self, n: ℕ) -> ℤ {
        if self < 0 {
            -(from_nat(abs(self) * n))
        } else {
            from_nat(abs(self) * n)
        }
    }
}

theorem mul_nat_zero_right(a: ℤ) { 
    a.mul_nat(ℕ.0) = 0 
} by {
    from_nat(abs(a) * ℕ.0) = 0
    -from_nat(abs(a) * ℕ.0) = 0
}

theorem mul_nat_zero_left(n: ℕ) { 
    0.mul_nat(n) = 0 
} by {
    from_nat(abs(0) * n) = 0
}

theorem mul_nat_nonpos_left(a: ℤ, n: ℕ) {
    a <= 0 implies a.mul_nat(n) = -(from_nat(abs(a) * n))
} by {
    if a = 0 {
        a.mul_nat(n) = -(from_nat(abs(a) * n))
    } else {
        a.mul_nat(n) = -(from_nat(abs(a) * n))
    }
}

theorem mul_nat_negate_left(a: ℤ, n: ℕ) { 
    (-a).mul_nat(n) = -(a.mul_nat(n))
} by {
    if a = 0 { 
        (-a).mul_nat(n) = -(a.mul_nat(n)) 
    }
    if a > 0 {
        a.mul_nat(n) = from_nat(abs(a) * n)
        (-a) < 0
        (-a).mul_nat(n) = -(from_nat(abs(-a) * n))
        (-a).mul_nat(n) = -(from_nat(abs(a) * n))

        (-a).mul_nat(n) = -(a.mul_nat(n))
    } 
    if a < 0 {
        a.mul_nat(n) = -(from_nat(abs(a) * n))
        (-a) > 0
        (-a).mul_nat(n) = from_nat(abs(-a) * n)
        (-a).mul_nat(n) = from_nat(abs(a) * n)

        (-a).mul_nat(n) = -(a.mul_nat(n))
    }
}

theorem mul_nat_nonneg_suc(a: ℤ, n: ℕ) {
    a >= 0 implies a.mul_nat(n.suc) = a.mul_nat(n) + a
} by {
    a.mul_nat(n.suc) = from_nat(abs(a) * n.suc)
    a.mul_nat(n.suc) = from_nat(abs(a) * n + abs(a))
    a.mul_nat(n.suc) = from_nat(abs(a) * n) +  from_nat(abs(a))
    from_nat(abs(a)) = a
    a.mul_nat(n.suc) = a.mul_nat(n) + a
}

theorem mul_nat_suc(a: ℤ, n: ℕ) {
    a.mul_nat(n.suc) = (a.mul_nat(n) + a)
} by {
    if a < 0 {
        (-a) > 0
        a.mul_nat(n.suc) = -((-a).mul_nat(n.suc))
        a.mul_nat(n.suc) = -((-a).mul_nat(n) + -a)
        a.mul_nat(n.suc) = -(-(a.mul_nat(n)) + -a)
        a.mul_nat(n.suc) = -(-(a.mul_nat(n) + a))
        a.mul_nat(n.suc) = (a.mul_nat(n) + a)
    } else {
        a.mul_nat(n.suc) = (a.mul_nat(n) + a)
    }
}

theorem mul_nat_distrib_right(a: ℤ, b: ℤ, n: ℕ) {
    (a + b).mul_nat(n) = (a.mul_nat(n) + b.mul_nat(n))
} by {
    define f(x: ℕ) -> Bool { 
        mul_nat_distrib_right(a, b, x) 
    }
    ℕ.induction(f)

    // Prove the base case
    (a + b).mul_nat(ℕ.0) = 0
    a.mul_nat(ℕ.0) = 0
    b.mul_nat(ℕ.0) = 0

    (a + b).mul_nat(ℕ.0) = a.mul_nat(ℕ.0) + b.mul_nat(ℕ.0)

    f(ℕ.0)

    // Induct
    forall(x: ℕ) {
        if f(x) {
            (a + b).mul_nat(x) = a.mul_nat(x) + b.mul_nat(x)

            (a + b).mul_nat(x.suc) = (a.mul_nat(x) + a) + (b.mul_nat(x) + b)
            
            (a + b).mul_nat(x.suc) = a.mul_nat(x.suc) + b.mul_nat(x.suc)

            f(x.suc)
        }
    }
}

theorem mul_nat_from_nat_left(a: ℕ, b: ℕ) { 
    from_nat(a).mul_nat(b) = from_nat(a * b) 
} by {
    if a = ℕ.0 {
        from_nat(a).mul_nat(b) = from_nat(a * b)
    } else {
        from_nat(a) > 0
        abs(from_nat(a)) = a
        from_nat(a).mul_nat(b) = from_nat(abs(from_nat(a)) * b)
        from_nat(a).mul_nat(b) = from_nat(a * b)
    }
}

// Integer-integer multiplication

attributes ℤ {
    /// The product of two integers.
    define mul(self, n: ℤ) -> ℤ {
        if n > 0 {
            self.mul_nat(abs(n))
        } else {
            -(self.mul_nat(abs(n)))
        }
    }

    /// The integer formed by appending a digit to this integer in base 10.
    define read(self, other: ℤ) -> ℤ { 10 * self + other }
}

theorem mul_zero_right(a: ℤ) { a * 0 = 0 } by {
    a * 0 = -(a.mul_nat(ℕ.0))
    a * 0 = -(0)
}

theorem mul_zero_left(a: ℤ) {
    0 * a = 0
} 

theorem mul_to_zero(a: ℤ, b: ℤ) {
    a = 0 or b = 0 implies a * b = 0
} by {
    if a = 0 { 
        a * b = 0 
    } else { 
        b = 0
        a * b = 0
    }
}

theorem mul_nat_from_nat_right(a: ℤ, n: ℕ) { 
    a.mul_nat(n) = (a * from_nat(n)) 
} by {
    if n = ℕ.0 {
        a.mul_nat(n) = (a * from_nat(n)) 
    } else {
        from_nat(n) > 0
        a * from_nat(n) = a.mul_nat(abs(from_nat(n)))
    }
}

theorem mul_nonneg_right(a: ℤ, b: ℤ) { b >= 0 implies a * b = a.mul_nat(abs(b)) } by {
    if b = 0 {
        a * b = 0
        a.mul_nat(abs(b)) = 0
        a * b = a.mul_nat(abs(b))
    } else {
        a * b = a.mul_nat(abs(b))
    }
}

theorem mul_nonneg_nonneg(a: ℤ, b: ℤ) {
    a >= 0 and b >= 0 implies a * b = from_nat(abs(a) * abs(b))
} by {
    a * b = a.mul_nat(abs(b))
}

theorem mul_nonneg_nonpos(a: ℤ, b: ℤ) {
    a >= 0 and b <= 0 implies a * b = -(from_nat(abs(a) * abs(b)))
} by {
    a * b = -(a.mul_nat(abs(b)))
}

theorem mul_nonpos_nonneg(a: ℤ, b: ℤ) {
    a <= 0 and b >= 0 implies a * b = -(from_nat(abs(a) * abs(b)))
} by {
    a * b = a.mul_nat(abs(b))
}

theorem mul_nonpos_nonpos(a: ℤ, b: ℤ) {
    a <= 0 and b <= 0 implies a * b = from_nat(abs(a) * abs(b))
} by {
    a * b = -(a.mul_nat(abs(b)))
    a * b = -(-(from_nat(abs(a) * abs(b))))
}

theorem mul_comm(a: ℤ, b: ℤ) { a * b = b * a } by {
    if a > 0 {
        if b > 0 {
            a * b = from_nat(abs(a) * abs(b))
            b * a = from_nat(abs(b) * abs(a))
            a * b = b * a
        } else {
            a * b = -(from_nat(abs(a) * abs(b)))
            b * a = -(from_nat(abs(b) * abs(a)))
            a * b = b * a
        }
    } else {
        if b > 0 {
            a * b = -(from_nat(abs(a) * abs(b)))
            b * a = -(from_nat(abs(b) * abs(a)))
            a * b = b * a
        } else {
            a * b = from_nat(abs(a) * abs(b))
            b * a = from_nat(abs(b) * abs(a))
            a * b = b * a
        }
    }
}

theorem mul_one_right(a: ℤ) { a * 1 = a } by {
    1 > 0
    a * 1 = a.mul_nat(ℕ.1)
    if a > 0 {
        a * 1 = from_nat(abs(a) * ℕ.1)
        a * 1 = from_nat(abs(a))
        a * 1 = a
    } else {
        a * 1 = -(from_nat(abs(a) * ℕ.1))
        from_nat(abs(a)) = -a
        a * 1 = a
    }
}

theorem mul_one_left(a: ℤ) { 1 * a = a }

theorem mul_neg_left(a: ℤ, b: ℤ) { 
    -a * b = -(a * b) 
} by {
    if a > 0 {
        if b > 0 {
            -a * b = -from_nat(abs(a) * abs(b))
            a * b = from_nat(abs(a) * abs(b))

            -a * b = -(a * b)
        } else {
            -a * b = from_nat(abs(a) * abs(b))
            a * b = -from_nat(abs(a) * abs(b))

            -a * b = -(a * b)
        }
    } else {
        if b > 0 {
            -a * b = from_nat(abs(a) * abs(b))
            a * b = -from_nat(abs(a) * abs(b))

            -a * b = -(a * b)
        } else {
            -a * b = -from_nat(abs(a) * abs(b))
            a * b = from_nat(abs(a) * abs(b))

            -a * b = -(a * b)
        }
    }
}

theorem mul_neg_right(a: ℤ, b: ℤ) { 
    a * -b = -(a * b) 
}

theorem mul_distrib_nonneg_right(a: ℤ, b: ℤ, c: ℤ) {
    c >= 0 implies (a + b) * c = a * c + b * c
} by {
    (a + b) * c = (a + b).mul_nat(abs(c))
    (a + b) * c = a.mul_nat(abs(c)) + b.mul_nat(abs(c))
    (a + b) * c = a * c + b * c
}

theorem mul_distrib_right(a: ℤ, b: ℤ, c: ℤ) { (a + b) * c = a * c + b * c } by {
    if c < 0 {
        (-c) > 0
        (a + b) * -(c) = a * -(c) + b * -(c)
        (a + b) * c = a * c + b * c
    } else {
        (a + b) * c = a * c + b * c
    }
}

theorem mul_distrib_left(a: ℤ, b: ℤ, c: ℤ) { 
    a * (b + c) = a * b + a * c 
} 

theorem mul_sub_distrib_right(a: ℤ, b: ℤ, c: ℤ) { 
    (a - b) * c = a * c - b * c 
} by {
    (a - b) * c = (a + -b) * c
}

theorem mul_sub_distrib_left(a: ℤ, b: ℤ, c: ℤ) { 
    a * (b - c) = a * b - a * c 
} by {
    a * (b - c) = a * (b + -(c))
}

theorem abs_mul(a: ℤ, b: ℤ) { 
    abs(a * b) = abs(a) * abs(b) 
} by {
    if a > 0 {
        if b > 0 {
            abs(a * b) = abs(a) * abs(b)
        } else {
            abs(a * b) = abs(a) * abs(b)
        }
    } else {
        if b > 0 {
            abs(a * b) = abs(a) * abs(b)
        } else {
            abs(a * b) = abs(a) * abs(b)
        }
    }
}