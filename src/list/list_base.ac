from util import compose, id_map
from nat.nat_base import ℕ
numerals ℕ
from order import max_imp_gte, min_imp_lte, Linear_Order
from option import Option
from nat.nat_base import true_below, strong_induction

/// A generic list data structure that can hold elements of any type.
/// Lists are constructed using nil (empty list) and cons (prepending an element).  
/// ℕ is also defined inductively. In fact, List can be understood as a mapping constructed in an inductive way with ℕ or a finite subset of it as the domain, by the length method 
inductive List[T] {
    /// The empty list.
    nil
    /// Constructs a list by prepending an element to an existing list.
    cons(T, List[T])
}

attributes List[T] {
    /// Concatenates two lists together.
    define add(self, other: List[T]) -> List[T] {
        match self {
            List.nil {
                other
            }
            List.cons(head, tail) {
                List.cons(head, tail.add(other))
            } 
        }
    }

    /// True if this list contains the given item.
    define contains(self, item: T) -> Bool {
        match self {
            List.nil {
                false
            }
            List.cons(head, tail) {
                if head = item {
                    true
                } else {
                    tail.contains(item)
                }
            }
        }
    }

    define not_contains(self, item: T) -> Bool {
        not self.contains(item)
    }
}

/// If a list contains no elements of type T, then it must be empty.
theorem not_contains_any_imp_nil[T](list: List[T]) {
    (forall(x: T) { x ∉ list }) implies list = List[T].nil
} 

/// If a list is empty, then it contains no elements of type T.
theorem nil_imp_not_contains_any[T](list: List[T]) {
    list = List[T].nil implies (forall(x: T) { x ∉ list })
}

/// If a list contains some element, then it is not empty.
theorem contains_any_imp_non_nil[T](list: List[T]) {
    (exists(x: T) { x ∈ list }) implies list != List[T].nil
}

/// If a list is not empty, then it contains some element.
theorem non_nil_imp_contains_any[T](list: List[T]) {
    list != List[T].nil implies (exists(x: T) { x ∈ list })
}

/// The negation of membership is equivalent to non-membership.
theorem not_contains_is_not_contains[T](list: List[T], item: T) {
    (not item ∈ list) iff item ∉ list
}

/// Adding an empty list on the right yields the original list.
theorem add_nil_right[T](list: List[T]) {
    list + List.nil[T] = list
}

/// Adding an empty list on the left yields the original list.
theorem add_nil_left[T](list: List[T]) {
    List.nil[T] + list = list
}

/// An item in the left list is contained in the concatenated list.
theorem add_contains_left[T](left: List[T], right: List[T], item: T) {
    item ∈ left implies item ∈ (left + right)
} by {
    // Base case: empty list contains no items
    define f(l: List[T]) -> Bool {
        item ∈ l implies item ∈ (l + right)
    }
    f(List.nil)
    // Inductive step
    forall(head: T, tail: List[T]) {
        if f(tail) {
            f(List.cons(head, tail))
            // see definition of contains & add ...
        }
    }
}

/// An item in the right list is contained in the concatenated list.
theorem add_contains_right[T](left: List[T], right: List[T], item: T) {
    item ∈ right implies item ∈ (left + right)
} by {
    // Check if item is in x + right by induction
    define f(x: List[T]) -> Bool {
        item ∈ (x + right) // this helper function is different from that defined in add_contains_left
    }
    f(List.nil)
    forall(head: T, tail: List[T]) {
        if f(tail) {
            f(List.cons(head, tail)) // forward check until arrive the right, then f(right) = true
        }
    }
}

/// If an item is in neither list, it is not in their concatenation.
theorem not_contains_add[T](left: List[T], right: List[T], item: T) {
    item ∉ left and item ∉ right implies item ∉ (left + right)
} by {
    // if item ∉ right
    // Prove by induction on the left list
    define f(x: List[T]) -> Bool {
        not item ∈ x implies not item ∈ (x + right)
    }
    f(List.nil)
    forall(head: T, tail: List[T]) {
        if f(tail) {
            f(List.cons(head, tail))
            // see definiton of (not) contains
            //     if p { q1 } else { q2 } 
            // is equivalent to 
            //     (p => q1) and ((not p) => q2) 
            // so its negative is 
            //     (p and (not q1)) or ((not p) and (not q2))
            // for 
            //     not item ∈ (head, tail)
            // either 
            //     head = item & head/item ∈ (head, tails) = false
            // or 
            //     head != item & not tails.contain(item). 
            // induction is from `(head, tails) + right` forward to `tails + right`
        }
    }
}

/// If an item is in the concatenated list, it is in at least one of the lists.
theorem contains_add[T](left: List[T], right: List[T], item: T) {
    item ∈ (left + right) implies item ∈ left or item ∈ right
}

attributes List[T] {
    /// True if this list contains every element of type T.
    define contains_every(self) -> Bool {
        forall(x: T) {
            x ∈ self
        }
    }

    /// True if this list contains any element of type T.
    define contains_any(self) -> Bool {
        exists(x: T) {
            x ∈ self
        }
    }

    /// Yields the number of elements in the list.
    define length(self) -> ℕ {
        match self {
            List.nil {
                0
            }
            List.cons(_, tail) {
                tail.length.suc
                // how to avoid infinity?
            }
        }
    }
}

theorem add_length[T](left: List[T], right: List[T]) {
    left.length + right.length = (left + right).length
} by {
    define f(x: List[T]) -> Bool {
        x.length + right.length = (x + right).length
    }
    f(List.nil)
    forall(head: T, tail: List[T]) {
        if f(tail) {
            f(List.cons(head, tail))
        }
    }
}

attributes List[T] {
    /// Creates a list containing a single element.
    let singleton: T -> List[T] = function(x: T) {
        List.cons(x, List.nil[T])
    }

    /// Removes all duplicate elements from the list.
    /// When duplicates exist, the last occurrence is kept.
    define unique(self) -> List[T] {
        match self {
            List.nil {
                List.nil[T]
            }
            List.cons(head, tail) {
                if head ∈ tail {
                    tail.unique
                } else {
                    List.cons(head, tail.unique)
                }
            }
        }
    }

    /// True if removing duplicates yields the same list (i.e., list has no duplicates).
    define is_unique(self) -> Bool {
        self.unique = self
    }
}

/// A singleton list contains no duplicates.
theorem singleton_unique[T](item: T) {
    List.singleton(item).is_unique
}

/// Removing duplicates cannot increase list length.
theorem unique_length[T](list: List[T]) {
    list.unique.length <= list.length
} by {
    define f(x: List[T]) -> Bool {
        x.unique.length <= x.length
    }
    f(List.nil)
    forall(head: T, tail: List[T]) {
        if f(tail) {
            tail.unique.length <= tail.length
            List.cons(head, tail).length = tail.length.suc
            if head ∈ tail {
                List.cons(head, tail).unique = tail.unique
                f(List.cons(head, tail))
            } else {
                List.cons(head, tail).unique.length = tail.unique.length.suc
                f(List.cons(head, tail))
            }
            f(List.cons(head, tail))
        }
    }
}

/// Decomposition of unique based on whether head appears in tail.
theorem unique_decomposition[T](head: T, tail: List[T]) {
    if head ∈ tail { 
        List.cons(head, tail).unique = tail.unique 
    } and 
    if not head ∈ tail { 
        List.cons(head, tail).unique = List.cons(head, tail.unique) 
    }
} by {
    // helper
    head ∈ tail implies List.cons(head, tail).unique = tail.unique 
}

/// Membership in a cons cell decomposes to head equality or tail membership.
theorem contains_decomposition[T](head: T, tail: List[T], item: T) {
    item ∈ List.cons(head, tail) iff head = item or item ∈ tail
} by {
    // helper
    head = item or item ∈ tail implies item ∈ List.cons(head, tail)
}

/// Non-membership in a cons cell decomposes to head inequality and tail non-membership.
theorem contains_decomposition_neg_dual[T](head: T, tail: List[T], item: T) {
    not item ∈ List.cons(head, tail) iff head != item and not item ∈ tail
} by {
    // helper
    contains_decomposition[T](head, tail, item)
}

/// When head does not equal item, membership depends only on tail.
theorem contains_when_head_not_eq_item[T](head: T, tail: List[T], item: T) {
    if head != item {
        // def of contains
        item ∈ List.cons(head, tail) iff item ∈ tail
    }
} by {
    // helper
    item ∈ List.cons(head, tail) implies item ∈ tail
}

/// When tail contains head, membership in cons depends only on tail.
theorem contains_when_tail_contains_head[T](head: T, tail: List[T], item: T) {
    if head ∈ tail {
        item ∈ List.cons(head, tail) iff item ∈ tail 
    }
} by {
    if head = item {
        item ∈ tail
        item ∈ List.cons(head, tail)
    }
    if head != item {
        // def of contains
        // helper
        item ∈ List.cons(head, tail) implies item ∈ tail

        item ∈ List.cons(head, tail) iff item ∈ tail
    }
}

/// When tail does not contain head and head equals item, membership depends on head.
theorem contains_when_tail_not_contains_head[T](head: T, tail: List[T], item: T) {
    if head ∉ tail {
        if head = item {
            // def of contains
            item ∈ List.cons(head, tail) iff head = item
        } 
        // case head != item already handled
    }
} 

/// Removing duplicates preserves membership of any item.
theorem unique_preserves_contains[T](list: List[T], item: T) {
    item ∈ list.unique iff item ∈ list
} by {
    define p(l: List[T]) -> Bool {
        item ∈ l.unique iff item ∈ l
    }

    // Base case: empty list
    p(List.nil[T])

    // Induction when add head to tail
    forall(head: T, tail: List[T]) {

        if p(tail) {
            if head ∈ tail {
                // Case 1: head appears in tail, so it gets removed by unique
                List.cons(head, tail).unique = tail.unique
                item ∈ List.cons(head, tail) iff item ∈ tail
                // p(tail)
                item ∈ tail.unique iff item ∈ tail
                // induction success
                p(List.cons(head, tail))
            }
            if head ∉ tail {
                // Case 2: head does not appear in tail, so it is kept
                List.cons(head, tail).unique = List.cons(head, tail.unique)
                if head = item {
                    // Subcase 2a: head equals item
                    item ∈ List.cons(head, tail) iff head = item
                    // similar
                    item ∈ List.cons(head, tail.unique) iff head = item
                    p(List.cons(head, tail))
                }
                if head != item {
                    // Subcase 2b: head does not equal item
                    item ∈ List.cons(head, tail) iff item ∈ tail
                    // similar
                    item ∈ List.cons(head, tail.unique) iff item ∈ tail.unique
                    // p(tail)
                    item ∈ tail.unique iff item ∈ tail
                    p(List.cons(head, tail))
                }
                p(List.cons(head, tail))
            }
            p(List.cons(head, tail))
        }
    }
}

/// Removing duplicates twice yields same result as removing once.
theorem unique_indemp[T](list: List[T]) {
    list.unique.unique = list.unique
} by {
    let list_unique = list.unique

    define f(x: List[T]) -> Bool {
        x.unique.unique = x.unique
    }

    // Base case: empty list
    f(List.nil)

    // Inductive step
    forall(head: T, tail: List[T]) {
        if f(tail) {
            tail.unique.unique = tail.unique

            if head ∈ tail {
                List.cons(head, tail).unique = tail.unique

                List.cons(head, tail).unique.unique = tail.unique.unique
                // use f(tail)
                f(List.cons(head, tail))
            } 
            if head ∉ tail {
                List.cons(head, tail).unique = List.cons(head, tail.unique)

                head ∉ tail.unique

                List.cons(head, tail.unique).unique = List.cons(head, tail.unique.unique)
                // use f(tail)
                f(List.cons(head, tail))
            }
            f(List.cons(head, tail))
        }
    }
}

/// The result of removing duplicates contains no duplicates.
theorem unique_list_is_unique[T](list: List[T]) {
    list.unique.is_unique
}

/// If a cons list is unique, then its tail is unique.
theorem unique_implies_tail_unique[T](head: T, tail: List[T]) {
    List.cons(head, tail).is_unique implies tail.is_unique
} by {
    if head ∈ tail {
        List.cons(head, tail).unique = tail.unique

        List.cons(head, tail).length = tail.length + 1

        List.cons(head, tail).unique.length < List.cons(head, tail).length

        not List.cons(head, tail).is_unique
    } 
    if head ∉ tail {
        List.cons(head, tail).unique = List.cons(head, tail.unique)
    }
}

attributes List[T] {
    /// Counts the number of occurrences of an item in the list.
    define count(self, item: T) -> ℕ {
        match self {
            List.nil[T] {
                0
            }
            List.cons(head, tail) {
                if head = item {
                    1 + tail.count(item)
                } else {
                    tail.count(item)
                }
            }
        }
    }
}

/// Adding a head cannot decrease the count of any item.
theorem count_increase[T](head: T, tail: List[T], item: T) {
    List.cons(head, tail).count(item) >= tail.count(item)
}

/// Counting in concatenated list is additive.
theorem count_add[T](l1: List[T], l2: List[T], item: T) {
    (l1 + l2).count(item) = l1.count(item) + l2.count(item)
} by {
    define f(l: List[T]) -> Bool {
        count_add(l, l2, item)
    }
    f(List[T].nil)
    forall(head: T, tail: List[T]) {
        List.cons(head, tail) + l2 = List.cons(head, tail + l2)

        (List.cons(head, tail) + l2).count(item) = List.cons(head, tail + l2).count(item)

        if f(tail) {
            (tail + l2).count(item) = tail.count(item) + l2.count(item)

            if head = item {
                List.cons(head, tail).count(item) = 1 + tail.count(item)

                List.cons(head, tail + l2).count(item) = 1 + (tail + l2).count(item)

                List.cons(head, tail + l2).count(item) = 1 + tail.count(item) + l2.count(item)

                (List.cons(head, tail) + l2).count(item) = List.cons(head, tail).count(item) + l2.count(item)
            } else {
                head != item

                (List.cons(head, tail) + l2).count(item) = List.cons(head, tail).count(item) + l2.count(item)
            }
            f(List.cons(head, tail))
        }
    }
    f(l1)
}

/// If an item is in a list, it occurs at least once.
theorem list_contains_implies_count_geq_one[T](list: List[T], item: T) {
    item ∈ list implies list.count(item) >= 1
} by {
    define p(l: List[T]) -> Bool {
        item ∈ l implies l.count(item) >= 1
    }

    // Base case: empty list
    p(List.nil[T])

    // Induction
    forall(head: T, tail: List[T]) {
        if p(tail) {
            if item ∈ List.cons(head, tail) {
                if head = item {
                    List.cons(head, tail).count(item) = 1 + tail.count(item)
                    List.cons(head, tail).count(item) >= 1
                } 
                if head != item {
                    item ∈ tail
                    tail.count(item) >= 1
                    List.cons(head, tail).count(item) >= 1
                }
                p(List.cons(head, tail))
            }
        }
    }
    p(list)
}

/// An item is not in a list iff its count is zero.
theorem list_not_contains_iff_count_zero[T](list: List[T], item: T) {
    not item ∈ list iff list.count(item) = 0
} by {
    define p(l: List[T]) -> Bool {
        not item ∈ l implies l.count(item) = 0
    }
    p(List.nil)
    forall(head: T, tail: List[T]) {
        if p(tail) {
            if item ∉ List.cons(head, tail) {
                head != item and item ∉ tail
                
                List.cons(head, tail).count(item) = 0

                p(List.cons(head, tail))
            }
        }
    }
    p(list)
}

/// An item is in a list iff its count is nonzero.
theorem list_contains_iff_not_count_zero[T](list: List[T], item: T) {
    item ∈ list iff list.count(item) != 0
} by {
    item ∈ list implies list.count(item) != 0
}

/// If a list is a singleton, then it only contains that element and has count 1.
theorem singleton_imp_only_have_and_count_one[T](x: T, list: List[T]) {
    list = List.singleton(x) implies forall(y: T) { y ∈ list implies y = x } and list.count(x) = 1
} 

/// If a list only contains x with count 1, then it must be a singleton.
theorem only_have_and_count_one_imp_singleton[T](x: T, list: List[T]) {
    forall(y: T) { y ∈ list implies y = x } and list.count(x) = 1 implies list = List.singleton(x)
} by {
    define f(l: List[T]) -> Bool {
        forall(y: T) { y ∈ l implies y = x } and l.count(x) = 1 implies l = List.singleton(x)
    }

    List[T].nil != List.singleton(x)
    f(List[T].nil)

    forall(head: T, tail: List[T]) {
        if f(tail) {
            if forall(y: T) { y ∈ List.cons(head, tail) implies y = x } and List.cons(head, tail).count(x) = 1 {
                if tail != List[T].nil {
                    let y: T satisfy { y ∈ tail }
                    y = x
                    head = x 
                    List.cons(head, tail).count(x) > 1
                    false 
                } else {
                    tail = List[T].nil
                    head = x
                    List.cons(head, tail) = List.singleton(x)
                    f(List.cons(head, tail))
                }
                f(List.cons(head, tail))
            }
            f(List.cons(head, tail))
        }
    }
    f(list)
}

/// If a list is unique, each element appears at most once.
theorem unique_implies_no_duplicate[T](list: List[T], item: T) {
    list.is_unique implies list.count(item) <= 1
} by {
    define p(l: List[T]) -> Bool {
        l.is_unique implies l.count(item) <= 1
    }

    // Base case: empty list
    p(List.nil[T])

    // Induction
    forall(head: T, tail: List[T]) {
        if p(tail) and item ∈ List.cons(head, tail) {
            head = item or item ∈ tail
            if List.cons(head, tail).is_unique {
                head ∉ tail
                if head = item {
                    List.cons(head, tail).count(item) = 1 + tail.count(item)
                    // head = item & head ∈ tail
                    tail.count(item) = 0
                    List.cons(head, tail).count(item) <= 1
                } 
                if head != item {
                    List.cons(head, tail).count(item) = tail.count(item)
                    // p(tail)
                    List.cons(head, tail).count(item) <= 1
                }
                p(List.cons(head, tail))
            }
            p(List.cons(head, tail))
        }
    }
    p(list)
}

/// If an item is in a list, it appears exactly once in the unique version.
theorem unique_contains_count_one[T](list: List[T], item: T) {
    item ∈ list implies list.unique.count(item) = 1
} by {
    item ∈ list.unique
    list.unique.count(item) >= 1
    list.unique.count(item) <= 1
}

attributes List[T] {
    /// True if every element appears at most once in the list.
    define no_duplicate(self) -> Bool {
        forall(item: T) { 
            self.count(item) <= 1 
        }
    }
    /// True if some element appears more than once in the list.
    define duplicate(self) -> Bool {
        exists(item: T) { 
            self.count(item) > 1 
        }
    }
}

/// Having no duplicates is equivalent to not being duplicate.
theorem no_duplicate_is_not_duplicate[T](list: List[T]) {
    list.no_duplicate iff not list.duplicate
} by {
    // helper
    list.no_duplicate implies not list.duplicate
}

/// If a list has no duplicates, then removing duplicates yields the same list.
theorem no_duplicate_implies_unique[T](list: List[T]) {
    list.no_duplicate implies list.is_unique
} by {
    define p(l: List[T]) -> Bool {
        (forall(item: T) { l.count(item) <= 1 }) implies l.is_unique
    }

    // Base case: empty list
    p(List.nil[T])

    // Induction
    forall(head: T, tail: List[T]) {
        if p(tail) {
            if (forall(item: T) { List.cons(head, tail).count(item) <= 1 }) {
                (forall(item: T) { 
                    // helper
                    if item ∈ tail {
                        tail.count(item) <= 1 
                    }
                })
                tail.is_unique
                head ∉ tail
                List.cons(head, tail).is_unique
            }
            p(List.cons(head, tail))
        }
    }
    p(list)
}

/// Having no duplicates is equivalent to being unique.
theorem no_duplicate_iff_unique[T](list: List[T]) {
    list.no_duplicate iff list.is_unique
} by {
    // helper
    list.is_unique implies list.no_duplicate
}

/// Not being unique is equivalent to being duplicate.
theorem duplicate_iff_not_unique[T](list: List[T]) {
    not list.is_unique iff list.duplicate
} 

attributes List[T] {
    /// Appends a single element to the end of the list.
    define append(self, item: T) -> List[T] {
        self + List.singleton(item)
    }
}

attributes ℕ {
    /// Creates a list of natural numbers from 0 to n-1.
    define range(self) -> List[ℕ] {
        match self {
            0 {
                List.nil[ℕ]
            }
            ℕ.suc(pred) {
                pred.range.append(pred)
            }
        }
    }
}

attributes List[T] {
    /// Alternate name for `ℕ.range`.
    /// Creates a list of natural numbers from 0 to n-1.
    let range: ℕ -> List[ℕ] = ℕ.range

    /// Filters the list, keeping only elements that satisfy the given predicate.
    define filter(self, f: T -> Bool) -> List[T] {
        match self {
            List.nil {
                List.nil[T]
            }
            List.cons(head, tail) {
                if f(head) {
                    List.cons(head, tail.filter(f))
                } else {
                    tail.filter(f)
                }
            }
        }
    }

    /// Removes all instances of an element from the list.
    define difference(self, elem: T) -> List[T] {
        match self {
            List.nil {
                List.nil[T]
            }
            List.cons(head, tail) {
                if head != elem {
                    List.cons(head, tail.difference(elem))
                } else {
                    tail.difference(elem)
                }
            }
        }
    }
}

/// True if elem is not equal to item.
define not_expect[T](elem: T, item: T) -> Bool {
    elem != item
}

/// Removing an element is equivalent to filtering with inequality.
theorem remove_elem_is_filter[T](list: List[T], elem: T) {
    list ∖ elem = list.filter(not_expect(elem))   
} by {
    define p(l: List[T]) -> Bool {
        l ∖ elem = l.filter(not_expect(elem)) 
    }

    // Base case: empty list
    p(List.nil[T])

    // Induction
    forall(head: T, tail: List[T]) {
        if p(tail) {
            tail ∖ elem = tail.filter(not_expect(elem))
            if head != elem {
                List.cons(head, tail) ∖ elem = List.cons(head, tail ∖ elem)

                not_expect(elem, head) = true

                List.cons(head, tail).filter(not_expect(elem)) = List.cons(head, tail.filter(not_expect(elem)))

                p(List.cons(head, tail))
            } 
            if head = elem {
                List.cons(head, tail) ∖ elem = tail ∖ elem

                not_expect(elem, head) = false

                List.cons(head, tail).filter(not_expect(elem)) = tail.filter(not_expect(elem))

                p(List.cons(head, tail))
            }
            p(List.cons(head, tail)) 
        }
    }
    p(list)
}

/// Removing an element ensures it no longer appears in the list.
theorem remove_elem_does_remove[T](list: List[T], elem: T) {
    elem ∉ (list ∖ elem)  
} by {
    define p(l: List[T]) -> Bool {
        elem ∉ (l ∖ elem)
    }
    p(List.nil)

    forall(head: T, tail: List[T]) {
        if p(tail) {
            elem ∉ (tail ∖ elem)
            if head = elem {
                List.cons(head, tail) ∖ elem = tail ∖ elem
            }
            if head != elem {
                List.cons(head, tail) ∖ elem = List.cons(head, tail ∖ elem)

                elem ∉ (List.cons(head, tail) ∖ elem)
            }
            p(List.cons(head, tail))
        }
    }
    p(list)
}

/// The count of an item cannot exceed the list length.
theorem count_lte_lenght[T](list: List[T], item: T) {
    list.count(item) <= list.length
} by {
    define p(l: List[T]) -> Bool {
        l.count(item) <= l.length
    }
    p(List[T].nil)
    forall(head: T, tail: List[T]) {
        List.cons(head, tail).length = 1 + tail.length
        if p(tail) {
            tail.count(item) <= tail.length
            if head = item {
                List.cons(head, tail).count(item) = 1 + tail.count(item)
                1 + tail.count(item) <= 1 + tail.length
                List.cons(head, tail).count(item) <= List.cons(head, tail).length
                p(List.cons(head, tail))
            } else {
                head != item
                List.cons(head, tail).count(item) = tail.count(item)
                tail.count(item) <= 1 + tail.length
                List.cons(head, tail).count(item) <= List.cons(head, tail).length
                p(List.cons(head, tail))
            }
            p(List.cons(head, tail))
        }
    }
    p(list)
}

/// List length equals length after removal plus count of removed elements.
theorem remove_length_ver_add[T](list: List[T], elem: T) {
    (list ∖ elem).length + list.count(elem) = list.length
} by {
    define p(l: List[T]) -> Bool {
        (l ∖ elem).length + l.count(elem) = l.length
    }

    // Base case: empty list
    p(List.nil[T])

    // Induction
    forall(head: T, tail: List[T]) {
        List.cons(head, tail).length = tail.length + 1
        if p(tail) {   
            if head = elem {
                List.cons(head, tail).count(elem) = tail.count(elem) + 1

                List.cons(head, tail) ∖ elem = tail ∖ elem

                // p(tail)
                (tail ∖ elem).length + tail.count(elem) = tail.length
                
                (tail ∖ elem).length + (tail.count(elem) + 1) = tail.length + 1
                                
                (List.cons(head, tail) ∖ elem).length + List.cons(head, tail).count(elem) = List.cons(head, tail).length

                p(List.cons(head, tail))
            }
            if head != elem {
                List.cons(head, tail).count(elem) = tail.count(elem)

                List.cons(head, tail) ∖ elem = List.cons(head, tail ∖ elem)

                (List.cons(head, tail) ∖ elem).length = (tail ∖ elem).length + 1

                // p(tail)
                (tail ∖ elem).length + tail.count(elem) = tail.length

                (1 + (tail ∖ elem).length) + tail.count(elem) = 1 + tail.length

                (List.cons(head, tail) ∖ elem).length + List.cons(head, tail).count(elem) = List.cons(head, tail).length

                p(List.cons(head, tail))
            }
            p(List.cons(head, tail))
        }
    }
    p(list)
}

/// Length after removal equals original length minus count of removed elements.
theorem remove_length[T](list: List[T], elem: T) {
    (list ∖ elem).length = list.length - list.count(elem)
    // this is nat sub
} by {
    (list ∖ elem).length + list.count(elem) = list.length
    0 <= (list ∖ elem).length
    list.count(elem) <= list.length
}

/// Removing elements cannot increase list length.
theorem remove_length_lte[T](list: List[T], elem: T) {
    (list ∖ elem).length <= list.length
} 

/// Removing an element that appears in the list decreases length.
theorem remove_contains_length_lt[T](list: List[T], elem: T) {
    elem ∈ list implies (list ∖ elem).length < list.length
} 

/// Removing an element not in the list leaves the list unchanged.
theorem remove_not_contains_do_nothing[T](list: List[T], item: T) {
    item ∉ list iff list ∖ item = list
} by {
    define p(l: List[T]) -> Bool {
        item ∉ l iff l ∖ item = l
    }

    // Base case: empty list
    p(List.nil[T])

    // Induction
    forall(head: T, tail: List[T]) {
        if p(tail) {   
            if item ∈ List.cons(head, tail) {
                List.cons(head, tail).count(item) != 0
                (List.cons(head, tail) ∖ item).length = List.cons(head, tail).length - List.cons(head, tail).count(item)
                (List.cons(head, tail) ∖ item).length < List.cons(head, tail).length
                List.cons(head, tail) != List.cons(head, tail) ∖ item
                p(List.cons(head, tail))
            } else {
                item ∉ List.cons(head, tail)
                item != head
                item ∉ tail
                tail = tail ∖ item
                List.cons(head, tail) ∖ item = List.cons(head, tail) 
                p(List.cons(head, tail))
            }
            p(List.cons(head, tail))
        }
    }
    p(list)
}

/// If an item is not in a list, it remains not present after removing any element.
theorem remove_preserve_not_conatins[T](list: List[T], item: T, elem: T) {
    item ∉ list implies item ∉ list ∖ elem
    // the reverse direction is rarely used and need forall(elem: T){ elem != item implies ...}, which make the proof too long
} by {
    define p(l: List[T]) -> Bool {
        item ∉ l implies item ∉ l ∖ elem
    }

    // Base case: empty list
    p(List.nil[T])

    // Induction
    forall(head: T, tail: List[T]) {
        if p(tail) {   
            if item ∉ List.cons(head, tail) {
                head != item
                item ∉ tail
                
                if head = elem {
                    List.cons(head, tail) ∖ elem = tail ∖ elem

                    // p(tail)
                    item ∉ tail ∖ elem

                    item ∉ List.cons(head, tail) ∖ elem
                }
                if head != elem {
                    List.cons(head, tail) ∖ elem = List.cons(head, tail ∖ elem)

                    item ∉ List.cons(head, tail) ∖ elem
                }
                item ∉ List.cons(head, tail) ∖ elem
                
                p(List.cons(head, tail))
            }
        }
    }
    p(list)
}

/// Removing a different element preserves count of another element.
theorem remove_count[T](list: List[T], item: T, elem: T) {
    item != elem implies list.count(item) = (list ∖ elem).count(item) 
    // although maybe list != list ∖ elem
    // reverse is false. example: item = elem but both not in list
    // if item = elem, then (list ∖ elem).count(item) = 0
} by {
    define p(l: List[T]) -> Bool {
        item != elem implies l.count(item) = (l ∖ elem).count(item)
    }

    // Base case: empty list
    p(List.nil[T])

    // Induction
    forall(head: T, tail: List[T]) {
        if p(tail) {   
            if item ∉ List.cons(head, tail) {
                List.cons(head, tail).count(item) = 0

                item ∉ List.cons(head, tail) ∖ elem
                
                (List.cons(head, tail) ∖ elem).count(item) = 0
                
                p(List.cons(head, tail))
            } else {
                item ∈ List.cons(head, tail)
                if item = head {
                    elem != head
                    
                    List.cons(head, tail) ∖ elem = List.cons(head, tail ∖ elem)
                
                    List.cons(head, tail).count(item) = 1 + tail.count(item)

                    List.cons(head, tail ∖ elem).count(item) = 1 + (tail ∖ elem).count(item)

                    // p(tail)
                    tail.count(item) = (tail ∖ elem).count(item)

                    List.cons(head, tail).count(item) = List.cons(head, tail ∖ elem).count(item)

                    p(List.cons(head, tail))
                } else {
                    item != head

                    List.cons(head, tail).count(item) = tail.count(item)
                    
                    if elem = head {
                        List.cons(head, tail) ∖ elem = tail ∖ elem

                        (List.cons(head, tail) ∖ elem).count(item) = (tail ∖ elem).count(item)

                        // p(tail)
                        tail.count(item) = (tail ∖ elem).count(item)

                        p(List.cons(head, tail))
                    } else {
                        elem != head

                        List.cons(head, tail) ∖ elem = List.cons(head, tail ∖ elem)

                        List.cons(head, tail ∖ elem).count(item) = (tail ∖ elem).count(item)

                        p(List.cons(head, tail))
                    }
                    p(List.cons(head, tail))
                }
                p(List.cons(head, tail))
            }
            p(List.cons(head, tail))
        }
    }
    p(list)
}

/// Removing an element from a unique list preserves uniqueness and reduces length by 1.
theorem remove_unique[T](list: List[T], elem: T) {
    if list.is_unique and elem ∈ list {
        (list ∖ elem).is_unique and
        (list ∖ elem).length + 1 = list.length 
    } // the reverse direction seems true, but rarely used, I think
} by {
    define p(l: List[T]) -> Bool {
        if l.is_unique and elem ∈ l {
            (l ∖ elem).is_unique and
            (l ∖ elem).length + 1 = l.length 
        } 
    }

    // Base case: empty list
    p(List.nil[T])

    // Induction
    forall(head: T, tail: List[T]) {
        if p(tail) {
            if 
            List.cons(head, tail).is_unique and 
            elem ∈ List.cons(head, tail) {
                if head = elem {
                    elem ∉ tail

                    List.cons(head, tail) ∖ elem = tail

                    tail.is_unique

                    tail.length + 1 = List.cons(head, tail).length

                    p(List.cons(head, tail))
                }
                if head != elem {
                    elem ∈ tail
                    tail.is_unique

                    List.cons(head, tail) ∖ elem = List.cons(head, tail ∖ elem)

                    // p(tail)
                    (tail ∖ elem).is_unique

                    (tail ∖ elem).length + 1 = tail.length

                    head ∉ tail

                    head ∉ tail ∖ elem

                    List.cons(head, tail ∖ elem).is_unique

                    p(List.cons(head, tail))
                }   
                p(List.cons(head, tail))
            }
            p(List.cons(head, tail))
        }
    }
    p(list)
}

/// Filtering cannot increase list length.
theorem filter_length_lte[T](list: List[T], f: T -> Bool) {
    list.filter(f).length <= list.length
} by {
    define p(l: List[T]) -> Bool {
        l.filter(f).length <= l.length
    }
    p(List[T].nil)
    forall(head: T, tail: List[T]) {
        if p(tail) {
            tail.filter(f).length <= tail.length
            List.cons(head, tail).length = 1 + tail.length
            if f(head) {
                List.cons(head, tail).filter(f) = List.cons(head, tail.filter(f))

                List.cons(head, tail).filter(f).length = 1 + tail.filter(f).length

                List.cons(head, tail).filter(f).length <= 1 + tail.length

                List.cons(head, tail).filter(f).length <= List.cons(head, tail).length
            } else {
                List.cons(head, tail).filter(f) = tail.filter(f)
                
                List.cons(head, tail).filter(f).length = tail.filter(f).length

                List.cons(head, tail).filter(f).length <= tail.length

                List.cons(head, tail).filter(f).length <= List.cons(head, tail).length
            }
            List.cons(head, tail).filter(f).length <= List.cons(head, tail).length

            p(List.cons(head, tail))
        }
    }
    p(list)
}

/// An item that is in the list and satisfies the predicate is in the filter.
theorem filter_contains_and[T](list: List[T], f: T -> Bool, item: T) {
    (item ∈ list and f(item)) implies item ∈ list.filter(f)
} by {
    define p(l: List[T]) -> Bool {
        item ∈ l and f(item) implies item ∈ l.filter(f)
    }

    // Base case: empty list
    p(List.nil[T])

    // Induction
    forall(head: T, tail: List[T]) {
        if p(tail) {
            if item ∈ tail {
                item ∈ tail.filter(f)
                if f(head) {
                    List.cons(head, tail).filter(f) = List.cons(head, tail.filter(f))

                    item ∈ List.cons(head, tail).filter(f)
                } else {
                    List.cons(head, tail).filter(f) = tail.filter(f)

                    item ∈ List.cons(head, tail).filter(f)
                }
            } else {
                item ∉ tail
                if head = item {
                    f(head)
                    List.cons(head, tail).filter(f) = List.cons(head, tail.filter(f))

                    item ∈ List.cons(head, tail).filter(f)
                }
            }
            p(List.cons(head, tail))
        }
    }

    p(list)
}

/// An item in the filter must be in the list and satisfy the predicate.
theorem filter_contained_by_and[T](list: List[T], f: T -> Bool, item: T) {
    item ∈ list.filter(f) implies (item ∈ list and f(item))
} by {
    define p(l: List[T]) -> Bool {
        item ∈ l.filter(f) implies (item ∈ l and f(item))
    }

    // Base case: empty list
    p(List.nil[T])

    // Induction
    forall(head: T, tail: List[T]) {
        if p(tail) {
            if item ∈ List.cons(head, tail).filter(f) {
                // By the def of tail, if the filter contains the item then item must either be in tail.filter or head
                if item ∈ tail.filter(f) {
                    // `and` phrase here is needed to help prover
                    f(item) and item ∈ tail

                    f(item) and item ∈ List.cons(head, tail)
                } else {
                    // see def of filter
                    f(head)
                    head = item
                    f(item) and item ∈ List.cons(head, tail)
                }
                f(item) and item ∈ List.cons(head, tail)
            }
            p(List.cons(head, tail))
        }
    }
    p(list)
}

/// Item in filter is equivalent to being in list and satisfying predicate.
theorem filter_equivalent_to_and[T](list: List[T], f: T -> Bool, item: T) {
    (item ∈ list and f(item)) = item ∈ list.filter(f)
} by {
    item ∈ list.filter(f) implies (item ∈ list and f(item))
    (item ∈ list and f(item)) implies item ∈ list.filter(f)
}

/// If predicate is true for all elements, filter returns original list.
theorem filter_of_super_is_self[T](list: List[T], contains: T -> Bool) {
    forall(x: T) {
        x ∈ list implies contains(x)
    } implies list.filter(contains) = list
} by {
    // Induction
    define f(l: List[T]) -> Bool {
        forall(x: T) {
            x ∈ l implies contains(x)
        } implies l.filter(contains) = l
    }

    // Base case: empty list
    f(List.nil[T])

    // Inductive step
    forall(head: T, tail: List[T]) {        
        if f(tail) {
            if forall(x: T) {
                x ∈ List.cons(head, tail) implies contains(x)
            } {
                head ∈ List.cons(head, tail)
                contains(head)

                List.cons(head, tail).filter(contains) = List.cons(head, tail.filter(contains))

                forall(x: T) {
                    if x ∈ tail {
                        x ∈ List.cons(head, tail)
                        contains(x)
                    }
                }
                tail.filter(contains) = tail

                List.cons(head, tail).filter(contains) = List.cons(head, tail)
            }
            f(List.cons(head, tail))
        }
    }
    f(list)
}

/// Filtering with the list's own membership predicate returns the list.
theorem filter_of_self_is_self[T](list: List[T]) {
    list.filter(list.contains) = list
}

/// Length of range from 0 to n-1 is n.
theorem length_range(n: ℕ) {
    n.range.length = n
} by {
    // Induction on n
    define f(x: ℕ) -> Bool {
        x.range.length = x
    }

    // Base case: 0.range.length = 0
    0.range = List.nil[ℕ]
    List.nil[ℕ].length = 0
    f(0)

    // Inductive step
    forall(x: ℕ) {
        if f(x) {
            // Induction hypothesis: x.range.length = x
            (x + 1).range = x.range.append(x)
            (x + 1).range = x.range + List.singleton(x)

            // Using add_length theorem
            (x + 1).range.length = x.range.length + List.singleton(x).length

            // Simplify the left side
            x.range.length = x
            List.singleton(x).length = 1

            // Therefore
            (x + 1).range.length = x + 1
            f(x + 1)
        }
    }

    // Conclusion
    f(n)
}

/// n is in the range from 0 to n.
theorem suc_range_contains(n: ℕ) {
    n ∈ (n + 1).range
} by {
    n ∈ List.singleton(n)
    (n + 1).range = n.range + List.singleton(n)
    n ∈ (n + 1).range
}

/// Every number less than n appears in range from 0 to n-1.
theorem range_contains_all_leq(n: ℕ) {
    forall(x: ℕ) {
        x < n implies x ∈ n.range
    }
} by {
    define p(m: ℕ) -> Bool {
        forall(x: ℕ) {
            x < m implies x ∈ m.range
        }
    }

    // Base case: 0
    p(0)

    // Induction
    forall(m: ℕ) {
        if p(m) {
            // Induction hypothesis: forall(x: ℕ) { x < m implies x ∈ m.range }
            forall(x: ℕ) {
                if x < m + 1 {
                    if x < m {
                        x ∈ m.range
                        x ∈ (m + 1).range
                    }
                    if x = m {
                        x = m
                        m ∈ (m + 1).range
                        x ∈ (m + 1).range
                    }
                    x ∈ (m + 1).range
                }
            }
            p(m + 1)
        }
    }

    // Conclusion
    p(n)
}

/// No number greater than or equal to m is in range from 0 to m-1.
theorem range_does_not_contain_geq(m: ℕ, n: ℕ) {
    n >= m implies n ∉ m.range
} by {
    define p(x: ℕ) -> Bool {
        forall(y: ℕ) {
            y >= x implies y ∉ x.range
        }
    }

    // Base case: 0
    p(0)

    // Induction
    forall(x: ℕ) {
        (x + 1).range = x.range + List.singleton(x)
        if p(x) {
            forall(y: ℕ) {
                if y >= x + 1 {
                    y > x
                    y ∉ x.range
                    y ∉ List.singleton(x)

                    y ∉ (x + 1).range
                }
            }
            p(x + 1)
        }
    }
}

/// Being less than n is equivalent to being in range from 0 to n-1.
theorem range_iff_contains_all_leq(n: ℕ) {
    forall(x: ℕ) {
        x < n iff x ∈ n.range
    }
} by {
    forall(x: ℕ) {
        x < n implies x ∈ n.range
        
        not x < n implies x ∉ n.range

        x < n iff x ∈ n.range
    }
}

/// Each element in range appears exactly once.
theorem range_count(n: ℕ, m: ℕ) {
    m ∈ n.range implies n.range.count(m) = 1
} by {
    define p(x: ℕ) -> Bool {
        m ∈ x.range implies x.range.count(m) = 1
    }
    p(0)
    forall(x: ℕ) {
        x.suc.range = x.range.append(x)
        x.range.append(x) = x.range + List.singleton(x)
        (x.range + List.singleton(x)).count(m) = x.range.count(m) + List.singleton(x).count(m)
        x.suc.range.count(m) = x.range.count(m) + List.singleton(x).count(m)
        if p(x) {
            if m ∈ x.suc.range {
                m < x.suc
                m <= x
                if m < x {
                    // Case 1: m is in x.range but not the new element
                    m ∈ x.range
                    m != x
                    List.singleton(x).count(m) = 0
                    x.suc.range.count(m) = 1
                } else {
                    // Case 2: m equals the new element x
                    m = x
                    m ∉ x.range
                    x.range.count(m) = 0
                    List.singleton(x).count(m) = 1
                    x.suc.range.count(m) = 1
                }
                x.suc.range.count(m) = 1
            }
            p(x.suc)
        }
    }
    p(n)
}

/// Range contains no duplicates.
theorem range_is_unique(n: ℕ) {
    n.range.is_unique
} by {
    forall(m: ℕ) {
        if m ∈ n.range {
            n.range.count(m) = 1
            n.range.count(m) <= 1
        } else {
            m ∉ n.range
            n.range.count(m) = 0
            n.range.count(m) <= 1
        }
        n.range.count(m) <= 1
    }
}

/// List concatenation is associative.
theorem add_assoc[T](a: List[T], b: List[T], c: List[T]) {
    (a + b) + c = a + (b + c)
} by {
    define p(x: List[T]) -> Bool {
        (x + b) + c = x + (b + c)
    }

    // Base case: (nil + b) + c = nil + (b + c)
    (List.nil[T] + b) + c = b + c
    List.nil[T] + (b + c) = b + c
    p(List.nil)

    // Inductive step
    forall(head: T, tail: List[T]) {
        if p(tail) {
            // Induction hypothesis: (tail + b) + c = tail + (b + c)

            // Left side: (List.cons(head, tail) + b) + c
            (List.cons(head, tail) + b) + c = List.cons(head, tail + b) + c
            List.cons(head, tail + b) + c = List.cons(head, (tail + b) + c)

            // Use induction hypothesis
            List.cons(head, (tail + b) + c) = List.cons(head, tail + (b + c))

            // Right side: List.cons(head, tail) + (b + c)
            List.cons(head, tail) + (b + c) = List.cons(head, tail + (b + c))

            // Therefore
            (List.cons(head, tail) + b) + c = List.cons(head, tail) + (b + c)
            p(List.cons(head, tail))
        }
    }
}


attributes List[T] {
    /// Yields the list without its first element.
    /// Yields nil for an empty list.
    define tail(self) -> List[T] {
        match self {
            List.nil {
                List.nil[T]
            }
            List.cons(h, t) {
                t
            }
        }
    }

    /// Removes the first n elements from the list.
    define drop(self, n: ℕ) -> List[T] {
        match n {
            0 {
                self
            }
            ℕ.suc(pred) {
                self.tail.drop(pred)
            }
            // drop (forward) n
        }
    }
}

/// Tail of cons returns the tail component.
theorem tail_cancels_cons[T](a: T, b: List[T]) {
    List.cons(a, b).tail = b
}

/// Dropping zero elements returns the original list.
theorem drop_zero[T](a: List[T]) {
    a.drop(0) = a
}

/// Dropping one element returns the tail.
theorem drop_one[T](a: List[T]) {
    a.drop(1) = a.tail
}

/// Dropping the length of the first list from concatenation returns the second.
theorem drop_cancels_add[T](a: List[T], b: List[T]) {
    (a + b).drop(a.length) = b
} by {
    define p(x: List[T]) -> Bool {
        (x + b).drop(x.length) = b
    }

    // Base case
    (List.nil[T] + b).drop(List.nil[T].length) = b.drop(0)
    b.drop(0) = b
    p(List.nil)

    // Inductive step
    forall(head: T, tail: List[T]) {
        if p(tail) {
            // Induction hypothesis: (tail + b).drop(tail.length) = b

            // Left side
            (List.cons(head, tail) + b).drop(List.cons(head, tail).length) = (List.cons(head, tail + b)).drop(tail.length.suc)

            (List.cons(head, tail + b)).drop(tail.length.suc) = (tail + b).drop(tail.length)

            // Use induction hypothesis
            (tail + b).drop(tail.length) = b

            // Therefore
            p(List.cons(head, tail))
        }
    }
}

/// Dropping m then n elements is equivalent to dropping m+n elements at once.
theorem drop_twice[T](a: List[T], m: ℕ, n: ℕ) {
    a.drop(m).drop(n) = a.drop(m + n)
} by {
    define f(x: ℕ) -> Bool {
        forall(l: List[T], k: ℕ) {
            l.drop(x).drop(k) = l.drop(x + k)
        }
    }

    ℕ.induction(f)

    forall(l: List[T], k: ℕ) {
        l.drop(0) = l
        drop_zero(l)
        l.drop(0).drop(k) = l.drop(k)
        0 + k = k
        l.drop(0 + k) = l.drop(k)
    }
    f(0)

    forall(x: ℕ) {
        if f(x) {
            forall(l: List[T], k: ℕ) {
                // Induction hypothesis: l.drop(x).drop(k) = l.drop(x + k)
                l.drop(x + 1).drop(k) = l.tail.drop(x).drop(k)

                f(x)

                l.tail.drop(x).drop(k) = l.tail.drop(x + k)

                x + 1 + k = (x + k).suc

                l.drop(x + 1 + k) = l.drop((x + k).suc)

                l.drop((x + k).suc) = l.tail.drop(x + k)

                l.drop(x + 1).drop(k) = l.drop(x + 1 + k)
            }
            f(x + 1)
        }
    }

    f(m)
}

attributes List[T] {
    /// Removes the last n elements from the list.
    /// Yields empty list if n >= list length.
    define drop_last(self, n: ℕ) -> List[T] {
        match self {
            List.nil {
                List.nil[T]
            }
            List.cons(head, tail) {
                if tail.length < n {
                    List.nil[T]
                } else {
                    List.cons(head, tail.drop_last(n))
                }
                // cons, until the length of tail < n, then stop cons
            }
        }
    }
}

/// Dropping zero elements from end returns the original list.
theorem drop_last_zero[T](a: List[T]) {
    a.drop_last(0) = a
} by {
    define q(x: List[T]) -> Bool {
        x.drop_last(0) = x
    }
    q(List.nil)
    forall(head: T, tail: List[T]) {
        if q(tail) {
            List.cons(head, tail).drop_last(0) = List.cons(head, tail.drop_last(0))

            List.cons(head, tail.drop_last(0)) = List.cons(head, tail)

            q(List.cons(head, tail))
        }
    }
    q(a)
}

/// Dropping all elements from end returns empty list.
theorem drop_last_all[T](l: List[T]) {
    l.drop_last(l.length) = List.nil[T]
} by {
    define r(x: List[T]) -> Bool {
        x.drop_last(x.length) = List.nil[T]
    }
    r(List.nil)
    forall(head: T, tail: List[T]) {
        if r(tail) {
            List.cons(head, tail).drop_last(List.cons(head, tail).length) = List.cons(head, tail).drop_last(tail.length.suc)

            List.cons(head, tail).drop_last(tail.length.suc) = List.nil[T]

            r(List.cons(head, tail))
        }
    }
    r(l)
}

/// Dropping length of second list from end of concatenation returns first list.
theorem drop_last_cancels_add[T](a: List[T], b: List[T]) {
    (a + b).drop_last(b.length) = a
} by {
    define p(x: List[T]) -> Bool {
        (x + b).drop_last(b.length) = x
    }
    drop_last_all(b)
    p(List.nil)
    forall(head: T, tail: List[T]) {
        if p(tail) {
            add_length(tail, b)

            let (c: ℕ) satisfy { b.length + c = (tail + b).length }

            c = tail.length
            b.length <= (tail + b).length

            (List.cons(head, tail) + b).drop_last(b.length) = List.cons(head, tail + b).drop_last(b.length)

            List.cons(head, tail + b).drop_last(b.length) = List.cons(head, (tail + b).drop_last(b.length))

            p(tail)

            List.cons(head, (tail + b).drop_last(b.length)) = List.cons(head, tail)

            p(List.cons(head, tail))
        }
    }
    p(a)
}

attributes ℕ {
    /// Creates a list of natural numbers from self to n-1 (exclusive of n).
    define until(self, n: ℕ) -> List[ℕ] {
        n.range.drop(self)
    }

    /// Creates a list of natural numbers from self to n (inclusive).
    define upto(self, n: ℕ) -> List[ℕ] {
        self.until(n.suc)
    }
}

/// Range from 0 to n-1 equals 0.until(n).
theorem zero_until(n: ℕ) {
    0.until(n) = n.range
} by {
    drop_zero(n.range)
}

/// Range from n to n is empty.
theorem until_self(n: ℕ) {
    n.until(n) = List.nil[ℕ]
} by {
    n.range.length = n
    drop_cancels_add(n.range, List.nil[ℕ])
}

/// Range from n to n+1 is singleton containing n.
theorem until_suc(n: ℕ) {
    n.until(n.suc) = List.singleton(n)
} by {
    n.suc.range = n.range + List.singleton(n)
    n.range.length = n
    drop_cancels_add(n.range, List.singleton(n))
}

/// Range from 0 to n inclusive equals (n+1).range.
theorem zero_upto(n: ℕ) {
    0.upto(n) = n.suc.range
}

/// Range from n to n inclusive is singleton containing n.
theorem upto_self(n: ℕ) {
    n.upto(n) = List.singleton(n)
}

/// Range from a to b-1 can be decomposed as a.range plus a.until(b).
theorem range_add_until(a: ℕ, b: ℕ) {
    a <= b implies a.range + a.until(b) = b.range
} by {
    let (k: ℕ) satisfy { a + k = b }

    define f(x: ℕ) -> Bool {
        a.range + a.until(a + x) = (a + x).range
    }

    // Base case: x = 0
    until_self(a)
    add_nil_right(a.range)
    f(0)

    // Inductive step
    forall(x: ℕ) {
        if f(x) {
            // Show a.until(a + x.suc) = a.until(a + x) + List.singleton(a + x)
            a.until(a + x.suc) = (a + x.suc).range.drop(a)
            (a + x.suc).range = (a + x).range + List.singleton(a + x)
            a.until(a + x.suc) = ((a + x).range + List.singleton(a + x)).drop(a)
            f(x)
            (a + x).range = a.range + a.until(a + x)
            a.until(a + x.suc) = (a.range + a.until(a + x) + List.singleton(a + x)).drop(a)
            a.range.length = a
            drop_cancels_add(a.range, a.until(a + x) + List.singleton(a + x))
            a.until(a + x.suc) = a.until(a + x) + List.singleton(a + x)

            // Now show f(x.suc)
            a.range + a.until(a + x.suc) = a.range + (a.until(a + x) + List.singleton(a + x))
            add_assoc(a.range, a.until(a + x), List.singleton(a + x))
            (a.range + a.until(a + x)) + List.singleton(a + x) = (a + x).range + List.singleton(a + x)
            f(x)
            (a + x).range + List.singleton(a + x) = (a + x).suc.range
            f(x.suc)
        }
    }

    f(k)
    a + k = b
}

/// A list with length zero must be empty.
theorem length_zero_imp_nil[T](list: List[T]) {
    list.length = ℕ.0 implies list = List.nil[T]
}

/// If concatenation is empty, both lists must be empty.
theorem add_to_nil[T](a: List[T], b: List[T]) {
    a + b = List.nil[T] implies a = List.nil[T] and b = List.nil[T]
}

/// Appending to any list never results in an empty list.
theorem append_not_nil[T](a: List[T], t: T) {
    a.append(t) != List.nil[T]
}

/// Returns maximum element of list using max operation, with nil_elem for empty lists.
define max_list[L: Linear_Order](list: List[L], nil_elem: L) -> L {
    match list {
        List[L].nil {
            nil_elem
        }
        List.cons(head, tail) {
            head.max(max_list(tail, nil_elem))
        }
    }
}

/// Every element in list is less than or equal to its maximum.
theorem list_has_max[L: Linear_Order](list: List[L], nil_elem: L) {
    forall(a: L) {
        a ∈ list implies a <= max_list(list, nil_elem)
    }
} by {
    define f(l: List[L]) -> Bool {
        forall(k: L) {
            k ∈ l implies k <= max_list(l, nil_elem)
        }
    }
    f(List[L].nil)

    forall(head: L, tail: List[L]) {
        if f(tail) {
            let k = max_list(tail, nil_elem)
            let m: L = head.max(k)
            m >= max_list(List.cons(head, tail), nil_elem)
            max_imp_gte(head, k)
            m >= max_list(tail, nil_elem)
            forall(x: L) {
                head = x implies x <= m
                x ∈ tail implies x <= m

                x ∈ List.cons(head, tail) implies x <= m
            }

            f(List.cons(head, tail))
        }
    }

    f(list)
}

/// Returns minimum element of list using min operation, with nil_elem for empty lists.
define min_list[L: Linear_Order](list: List[L], nil_elem: L) -> L {
    match list {
        List[L].nil {
            nil_elem
        }
        List.cons(head, tail) {
            head.min(min_list(tail, nil_elem))
        }
    }
}

/// Every element in list is greater than or equal to its minimum.
theorem list_has_min[L: Linear_Order](list: List[L], nil_elem: L) {
    forall(a: L) {
        a ∈ list implies a >= min_list(list, nil_elem)
    }
} by {
    define f(l: List[L]) -> Bool {
        forall(k: L) {
            k ∈ l implies k >= min_list(l, nil_elem)
        }
    }
    f(List[L].nil)

    forall(head: L, tail: List[L]) {
        if f(tail) {
            let k = min_list(tail, nil_elem)
            let m: L = head.min(k)
            m <= min_list(List.cons(head, tail), nil_elem)
            min_imp_lte(head, k)
            m <= min_list(tail, nil_elem)
            forall(x: L) {
                head = x implies x >= m
                x ∈ tail implies x >= m

                x ∈ List.cons(head, tail) implies x >= m
            }

            f(List.cons(head, tail))
        }
    }

    f(list)
}

/// Every list of natural numbers misses some natural number.
theorem no_list_contains_nat(list: List[ℕ]) {
    exists(n: ℕ) {
        n ∉ list
    } // max_list + 1
}

attributes List[T] {
    /// Returns the index of first occurrence of item, or 0 if not found.
    define find_first_idx(self, item: T) -> ℕ {
        match self {
            List.nil{
                ℕ.0
            }
            List.cons(head, tail) {
                if head = item {
                    ℕ.0
                } else {
                    1 + tail.find_first_idx(item)
                }
            }
        }
    }

    /// Gets the element at index i, returning None if out of bounds.
    define get(self, i: ℕ) -> Option[T] {
        match self {
            List.nil {
                Option.none
            }
            List.cons(head, tail) {
                if i > 0 {
                    tail.get(i - 1)
                } else {
                    Option.some(head)
                }
            }
        }
    }

    /// Removes the first occurrence of elem from the list.
    define remove_first(self, elem: T) -> List[T] {
        match self {
            List.nil {
                List.nil[T]
            }
            List.cons(head, tail) {
                if head != elem {
                    List.cons(head, tail.remove_first(elem))
                } else {
                    tail
                }
            }
        }
    }
}

attributes List[T] {
    /// Two lists are permutations if they have the same count for each element.
    define is_permutation(self, l: List[T]) -> Bool {
        forall(item: T) {
            self.count(item) = l.count(item)
        }
    }
}

/// Every list is a permutation of itself.
theorem self_permutation[T](list: List[T]) {
    list.is_permutation(list)
} 

/// Permutation relation is symmetric.
theorem permutation_comm[T](l1: List[T], l2: List[T]) {
    l1.is_permutation(l2) implies l2.is_permutation(l1)
}

/// Permutation relation is transitive.
theorem permutation_is_transitive[T](l1: List[T], l2: List[T], l3: List[T]) {
    l1.is_permutation(l2) and l2.is_permutation(l3) implies l1.is_permutation(l3)
} by {
    forall(item: T) {
        l1.count(item) = l2.count(item)
        l2.count(item) = l3.count(item)
        l1.count(item) = l3.count(item)
    }
}

/// Empty list is only a permutation of empty list.
theorem nil_permutation[T](list: List[T]) {
    (List[T].nil).is_permutation(list) iff list = List[T].nil 
} by {
    (List[T].nil).is_permutation(list) implies list = List[T].nil 
    // all count = 0 <==> nil
}

/// Removing same element from both lists preserves permutation relation.
theorem remove_preserve_permutation[T](l1: List[T], l2: List[T], item: T) {
    l1.is_permutation(l2) implies (l1 ∖ item).is_permutation(l2 ∖ item)
} by {
    l1.count(item) = l2.count(item)
    forall(x: T) {
        if x != item {
            (l1 ∖ item).count(x) = l1.count(x)
            (l2 ∖ item).count(x) = l2.count(x)

            (l1 ∖ item).count(x) = (l2 ∖ item).count(x)
        } else {
            (l1 ∖ item).count(x) = 0
            (l2 ∖ item).count(x) = 0

            (l1 ∖ item).count(x) = (l2 ∖ item).count(x)
        }
        (l1 ∖ item).count(x) = (l2 ∖ item).count(x)
    }
}

/// Permutations have equal length.
theorem permutation_length[T](list_1: List[T], list_2: List[T]) {
    list_1.is_permutation(list_2) implies list_1.length = list_2.length
} by {
    define f(n: ℕ) -> Bool {
        forall(l1: List[T], l2: List[T]) {
            l1.length = n and l1.is_permutation(l2) implies l1.length = l2.length
        }
    }
    f(0)
    forall(k: ℕ) {
        if true_below(f, k) {
            if k = 0 {
                f(k)
            } else {
                k != 0
                forall(l1: List[T], l2: List[T]) {
                    if l1.length = k and l1.is_permutation(l2) {
                        let item: T satisfy { item ∈ l1 }

                        l1.count(item) = l2.count(item)

                        (l1 ∖ item).length = l1.length - l1.count(item)

                        (l2 ∖ item).length = l2.length - l2.count(item)

                        l1.length = (l1 ∖ item).length + l1.count(item)

                        l2.length = (l2 ∖ item).length + l2.count(item)

                        (l1 ∖ item).is_permutation(l2 ∖ item)

                        (l1 ∖ item).length < k

                        // By true_below induction
                        f((l1 ∖ item).length)

                        (l1 ∖ item).length = (l2 ∖ item).length

                        l1.length = l2.length
                    }
                }
                f(k)
            }
            f(k)
        }
    }
    f(list_1.length)
}

/// Permutations have identical membership predicates.
theorem permutation_imp_same_contains[T](l1: List[T], l2: List[T]) {
    l1.is_permutation(l2) implies l1.contains = l2.contains
} by {
    forall(x: T) {
        if x ∈ l1 {
            l1.count(x) != 0
            l2.count(x) != 0
            x ∈ l2
            l1.contains(x) = l2.contains(x)
        } else {
            x ∉ l1
            l1.count(x) = 0
            l2.count(x) = 0
            x ∉ l2
            l1.contains(x) = l2.contains(x)
        }
        l1.contains(x) = l2.contains(x)
    }
    l1.contains = l2.contains
}

/// Two unique lists with same membership are permutations.
theorem unique_and_same_contains_imp_permutation[T](l1: List[T], l2: List[T]) {
    l1.is_unique and l2.is_unique and l1.contains = l2.contains implies l1.is_permutation(l2)
} by {
    forall(item: T) {
        if item ∈ l1 {
            item ∈ l2
            l1.count(item) = 1
            l2.count(item) = 1
            l2.count(item) = l2.count(item)
        } else {
            item ∉ l1
            item ∉ l2
            l1.count(item) = l2.count(item)
        }
        l1.count(item) = l2.count(item)
    }
}

/// Permutations remain permutations after removing duplicates.
theorem permutation_unique_permutation[T](l1: List[T], l2: List[T]) {
    l1.is_permutation(l2) implies l1.unique.is_permutation(l2.unique)
} by {
    l1.contains = l2.contains
    l1.unique.contains = l2.unique.contains
}

/// Any list permutation of a singleton must be that singleton.
theorem singleton_permutation[T](l: List[T], x: T) {
    List[T].singleton(x).is_permutation(l) implies l = List[T].singleton(x)
} by {
    forall(y: T) {
        List[T].singleton(x).count(y) = l.count(y)
        if y ∈ l {
            if y != x {
                l.count(y) = 0
                y ∉ l
                false
            }
            y = x
        }
        l.count(x) = 1
    }
}

attributes List[T] {
    /// List is subset if each element's count is at most the count in other.
    define subset_eq(self, other: List[T]) -> Bool {
        forall(x: T) {
            x ∈ self implies self.count(x) <= other.count(x)
        }
    }
    /// List is superset if other is a subset.
    define superset_eq(self, other: List[T]) -> Bool {
        other ⊆ self
    }
}

/// Subset relation implies count inequality for each element.
theorem subset_eq_more[T](l1: List[T], l2: List[T]) {
    l1 ⊆ l2 implies forall(x: T) {
        l1.count(x) <= l2.count(x)
    }
} by {
    forall(x: T) {
        if x ∉ l1 {
            l1.count(x) = 0
            l1.count(x) <= l2.count(x)
        } else {
            x ∈ l1
            l1.count(x) <= l2.count(x)
        }
        l1.count(x) <= l2.count(x)
    } 
}

/// Two lists are permutations if each is subset of the other.
theorem subset_superset_to_permutation[T](l1: List[T], l2: List[T]) {
    l1 ⊆ l2 and l1 ⊇ l2 implies l1.is_permutation(l2)
} by {
    forall(x: T) {
        l1.count(x) <= l2.count(x)
        l1.count(x) >= l2.count(x)
        l1.count(x) = l2.count(x)
    }
}

/// If l1 is subset of l and l1 permutes to l2, then l2 is subset of l.
theorem permutation_preserve_subset[T](l1: List[T], l2: List[T], l: List[T]) {
    l1 ⊆ l and l1.is_permutation(l2) implies l2 ⊆ l
} by {
    forall(x: T) {
        if x ∈ l2 {
            l1.count(x) = l2.count(x)
            l2.count(x) <= l.count(x)
        }
    }
}

theorem permutation_preserve_superset[T](l1: List[T], l2: List[T], l: List[T]) {
    l1 ⊇ l and l1.is_permutation(l2) implies l2 ⊇ l
} by {
    forall(x: T) {
        if x ∈ l {
            l1.count(x) = l2.count(x)
            l2.count(x) >= l.count(x)
        }
    }
}

/// Removing same element preserves subset relation.
theorem remove_preserve_subset[T](l1: List[T], l2: List[T], x: T) {
    l1 ⊆ l2 implies (l1 ∖ x) ⊆ (l2 ∖ x)
} by {
    forall(y: T) {
        if y ∈ l1 ∖ x {
            y != x
            (l1 ∖ x).count(y) = l1.count(y)
            (l2 ∖ x).count(y) = l2.count(y)
            (l1 ∖ x).count(y) <= (l2 ∖ x).count(y)
        }
    }
}

theorem nil_subset[T](l: List[T]) {
    List[T].nil ⊆ l
} by {
    forall(x: T) {
        List[T].nil.count(x) = 0
        List[T].nil.count(x) <= l.count(x)
    }
}

theorem subset_trans[T](l1: List[T], l2: List[T], l3: List[T]) {
    l1 ⊆ l2 and l2 ⊆ l3 implies l1 ⊆ l3
} by {
    forall(x: T) {
        if x ∈ l1 {
            x ∈ l2
            x ∈ l3
        }
    }
}

/// Subset relation implies length inequality.
theorem subset_imp_length_lte[T](list_1: List[T], list_2: List[T]) {
    list_1 ⊆ list_2 implies list_1.length <= list_2.length
} by {
    define f(n: ℕ) -> Bool {
        forall(l1: List[T], l2: List[T]) {
            l1.length = n and l1 ⊆ l2 implies l1.length <= l2.length
        }
    }
    f(0)
    forall(k: ℕ) {
        if true_below(f, k) {
            if k = 0 {
                f(k)
            } else {
                k != 0
                forall(l1: List[T], l2: List[T]) {
                    if l1.length = k and l1 ⊆ l2 {
                        let item: T satisfy { item ∈ l1 }

                        l1.length = (l1 ∖ item).length + l1.count(item)

                        l2.length = (l2 ∖ item).length + l2.count(item)

                        (l1 ∖ item) ⊆ (l2 ∖ item)

                        (l1 ∖ item).length < k

                        (l1 ∖ item).length <= (l2 ∖ item).length

                        l1.count(item) <= l2.count(item)

                        (l1 ∖ item).length + l1.count(item) <= (l2 ∖ item).length + l2.count(item)

                        l1.length <= l2.length
                    }
                }
                f(k)
            }
            f(k)
        }
    }
    f(list_1.length)
}

/// If unique list l1 has elements only appearing in l2, then l1 is subset of l2.
theorem unique_subset[T](l1: List[T], l2: List[T]) {
    l1.is_unique and forall(x: T) {
        x ∈ l1 implies x ∈ l2
    } implies l1 ⊆ l2
} by {
    forall(x: T) {
        if x ∈ l1 {
            x ∈ l2
            l1.count(x) = 1
            l2.count(x) >= 1
            l1.count(x) <= l2.count(x)
        }
    }
    l1 ⊆ l2
}

/// Applies a function to each element of a list, creating a new list of results.
attributes List[T] {
    define map[U](self, f: T -> U) -> List[U] {
        match self {
            List.nil {
                List.nil[U]
            }
            List.cons(head, tail) {
                List.cons(f(head), tail.map(f))
            }
        }
    }
}

/// Applies a function to each element of a list, creating a new list of results.
/// Deprecated non-attribute definition.
define map[T, U](items: List[T], f: T -> U) -> List[U] {
    match items {
        List.nil {
            List.nil[U]
        }
        List.cons(head, tail) {
            List.cons(f(head), map(tail, f))
        }
    }
}

/// The attribute and non-attribute definitions of map are equivalent.
theorem map_equivalence[T, U] {
    List.map[T, U] = map[T, U]
} by {
    forall(f: T -> U) {
        // Induction on p
        define p(ts: List[T]) -> Bool {
            ts.map(f) = map(ts, f)
        }

        // Base case
        p(List.nil)

        forall(ts: List[T]) {
            p(ts)
            ts.map(f) = map(ts, f)
        }
    }
}

/// Mapping a singleton yields a singleton of mapped element.
theorem map_singleton[T, U](f: T -> U, x: T) {
    List.singleton(x).map(f) = List.singleton(f(x))
}

/// Mapping distributes over concatenation.
theorem map_add[T, U](left: List[T], right: List[T], f: T -> U) {
    (left + right).map(f) = left.map(f) + right.map(f)
} by {
    define p(x: List[T]) -> Bool {
        (x + right).map(f) = x.map(f) + right.map(f)
    }

    // Base case: (nil + right).map(f) = nil.map(f) + right.map(f)
    (List.nil[T] + right).map(f) = right.map(f)
    List.nil[T].map(f) = List.nil[U]
    List.nil[U] + right.map(f) = right.map(f)
    p(List.nil)

    // Inductive step

    forall(head: T, tail: List[T]) {
        if p(tail) {
            // Induction hypothesis: (tail + right).map(f) = tail.map(f) + right.map(f)

            // Left side: (List.cons(head, tail) + right).map(f)
            (List.cons(head, tail) + right).map(f) = List.cons(head, tail + right).map(f)
            List.cons(head, tail + right).map(f) = List.cons(f(head), (tail + right).map(f))

            // Use induction hypothesis
            List.cons(f(head), (tail + right).map(f)) = List.cons(f(head), tail.map(f) + right.map(f))

            // Right side: List.cons(head, tail).map(f) + right.map(f)
            List.cons(head, tail).map(f) = List.cons(f(head), tail.map(f))
            List.cons(head, tail).map(f) + right.map(f) = List.cons(f(head), tail.map(f)) + right.map(f)
            // Definition of add
            List.cons(f(head), tail.map(f)) + right.map(f) = List.cons(f(head), tail.map(f) + right.map(f))

            // Therefore
            (List.cons(head, tail) + right).map(f) = List.cons(head, tail).map(f) + right.map(f)
            p(List.cons(head, tail))
        }
    }
}

/// Mapping an append operation yields append of mapped elements.
theorem map_append[T, U](initial: List[T], last: T, f: T -> U) {
    (initial.append(last)).map(f) = initial.map(f).append(f(last))
}

/// Mapping twice is equivalent to mapping with composition.
theorem map_map[T, U, V](items: List[T], f: T -> U, g: U -> V) {
    (items.map(f)).map(g) = items.map(compose(g, f))
} by {
    define p(x: List[T]) -> Bool {
        (x.map(f)).map(g) = x.map(compose(g, f))
    }

    // Base case
    List.nil[T].map(f).map(g) = (List.nil[U]).map(g)
    List.nil[U].map(g) = List.nil[V]
    List.nil[T].map(compose(g, f)) = List.nil[V]
    p(List.nil)

    // Inductive step
    forall(head: T, tail: List[T]) {
        if p(tail) {
            // Left side
            List.cons(head, tail).map(f).map(g) = List.cons(f(head), tail.map(f)).map(g)
            List.cons(f(head), tail.map(f)).map(g) = List.cons(g(f(head)), tail.map(f).map(g))

            // Use induction hypothesis
            tail.map(f).map(g) = tail.map(compose(g, f))

            // Right side
            List.cons(head, tail).map(compose(g, f)) = List.cons(compose(g, f)(head), tail.map(compose(g, f)))
            List.cons(compose(g, f)(head), tail.map(compose(g, f))) = List.cons(g(f(head)), tail.map(compose(g, f)))

            // Therefore
            List.cons(head, tail).map(f).map(g) = List.cons(head, tail).map(compose(g, f))
            p(List.cons(head, tail))
        }
    }
}

/// Mapping with identity function returns the list unchanged.
theorem map_id_map[T](list: List[T]) {
    list.map(id_map[T]) = list
} by {
    define p(l: List[T]) -> Bool {
        l.map(id_map[T]) = l
    }
    p(List[T].nil)
    forall(head: T, tail: List[T]) {
        if p(tail) {
            List.cons(head, tail).map(id_map[T]) = List.cons(id_map[T](head), tail.map(id_map[T]))
            List.cons(head, tail).map(id_map[T]) = List.cons(head, tail)
        }
        p(List.cons(head, tail))
    }
    p(list)
}

/// If no element maps to y, then y is not in the mapped list.
theorem map_image_to_exists_imp_dual[T, U](list: List[T], f: T -> U, y: U) {
    forall(x: T) {
        x ∈ list implies f(x) != y
    } implies y ∉ list.map(f)
} by {
    define p(l: List[T]) -> Bool {
        forall(x: T) {
            x ∈ l implies f(x) != y
        } implies y ∉ l.map(f)       
    }
    p(List[T].nil)
    forall(head: T, tail: List[T]) {
        List.cons(head, tail).map(f) = List.cons(f(head), tail.map(f))
        if p(tail) {
            if forall(x: T) {
                x ∈ List.cons(head, tail) implies f(x) != y
            } {
                head ∈ List.cons(head, tail)
                f(head) != y
                forall(x: T) {
                    if x ∈ tail {
                        x ∈ List.cons(head, tail)
                        f(x) != y
                    }
                }
                y ∉ tail.map(f)
                y ∉ List.cons(f(head), tail.map(f))
            }
            p(List.cons(head, tail))
        }
    }
    p(list)
}

/// If y is in the mapped list, some element maps to it.
theorem map_image_to_exists[T, U](list: List[T], f: T -> U, y: U) {
    y ∈ list.map(f) implies exists(x: T) {
        x ∈ list and f(x) = y
    }
}

/// Returns the list of elements from list that map to y under f.
define fiber_list[T, U](list: List[T], f: T -> U, y: U) -> List[T] {
    match list {
        List[T].nil {
            List[T].nil
        }
        List.cons(head, tail) {
            if f(head) = y {
                List.cons(head, fiber_list(tail, f, y))
            } else {
                fiber_list(tail, f, y)
            }
        }
    }
}

/// Count of y in mapped list equals length of fiber list of y.
theorem map_count_is_fiber_length[T, U](list: List[T], f: T -> U, y: U) {
    list.map(f).count(y) = fiber_list(list, f, y).length
} by {
    define p(l: List[T]) -> Bool {
        l.map(f).count(y) = fiber_list(l, f, y).length
    }
    p(List[T].nil)
    forall(head: T, tail: List[T]) {
        List.cons(head, tail).map(f) = List.cons(f(head), tail.map(f))
        List.cons(head, tail).map(f).count(y) = List.singleton(f(head)).count(y) + tail.map(f).count(y)
        if p(tail) {
            tail.map(f).count(y) = fiber_list(tail, f, y).length
            if f(head) = y {
                List.cons(head, tail).map(f).count(y) = 1 + tail.map(f).count(y)
                fiber_list(List.cons(head, tail), f, y) = List.cons(head, fiber_list(tail, f, y))
                fiber_list(List.cons(head, tail), f, y).length = 1 + fiber_list(tail, f, y).length
                List.cons(head, tail).map(f).count(y) = fiber_list(List.cons(head, tail), f, y).length
            } else {
                List.cons(head, tail).map(f).count(y) = tail.map(f).count(y)
                fiber_list(List.cons(head, tail), f, y) = fiber_list(tail, f, y)
                fiber_list(List.cons(head, tail), f, y).length = fiber_list(tail, f, y).length
                List.cons(head, tail).map(f).count(y) = fiber_list(List.cons(head, tail), f, y).length
            }
            List.cons(head, tail).map(f).count(y) = fiber_list(List.cons(head, tail), f, y).length
            p(List.cons(head, tail))
        }
    }
    p(list)
}

/// Any element in fiber list maps to y.
theorem fiber_list_is_inv_image_imp[T, U](list: List[T], f: T -> U, x: T, y: U) {
    x ∈ fiber_list(list, f, y) implies f(x) = y
} by {
    define p(l: List[T]) -> Bool {
        x ∈ fiber_list(l, f, y) implies f(x) = y
    }
    p(List[T].nil)
    forall(head: T, tail: List[T]) {
        if p(tail) {
            if x ∈ fiber_list(List.cons(head, tail), f, y) {
                if f(head) = y {
                    fiber_list(List.cons(head, tail), f, y) = List.cons(head, fiber_list(tail, f, y))
                    if x = head {
                        f(x) = y
                    } else {
                        x ∈ fiber_list(tail, f, y)
                        f(x) = y
                    }
                    f(x) = y
                } else {
                    fiber_list(List.cons(head, tail), f, y) = fiber_list(tail, f, y)
                    x ∈ fiber_list(tail, f, y)
                    f(x) = y
                }           
                f(x) = y
            }
            p(List.cons(head, tail))
        }
    }
    p(list)
}

/// If x is in list and maps to y, then fiber list is non-empty and contains x.
theorem fiber_list_is_inv_image_imp_by[T, U](list: List[T], f: T -> U, x: T, y: U) {
    x ∈ list and f(x) = y implies fiber_list(list, f, y) != List[T].nil and x ∈ fiber_list(list, f, y)
} by {
    define p(l: List[T]) -> Bool {
        x ∈ l and f(x) = y implies fiber_list(l, f, y) != List[T].nil and x ∈ fiber_list(l, f, y)
    }
    p(List[T].nil)
    forall(head: T, tail: List[T]) {
        if p(tail) {
            if x ∈ List.cons(head, tail) and f(x) = y {
                if f(head) = y {
                    fiber_list(List.cons(head, tail), f, y) = List.cons(head, fiber_list(tail, f, y))
                    fiber_list(List.cons(head, tail), f, y) != List[T].nil
                    if x = head {
                        x ∈ fiber_list(List.cons(head, tail), f, y)
                    } else {
                        x ∈ tail
                        x ∈ fiber_list(tail, f, y)
                        x ∈ fiber_list(List.cons(head, tail), f, y)
                    }
                    x ∈ fiber_list(List.cons(head, tail), f, y)
                } else {
                    f(head) != y
                    x != head
                    x ∈ tail
                    fiber_list(List.cons(head, tail), f, y) = fiber_list(tail, f, y)
                    fiber_list(tail, f, y) != List[T].nil
                    fiber_list(List.cons(head, tail), f, y) != List[T].nil
                    x ∈ fiber_list(tail, f, y)
                    x ∈ fiber_list(List.cons(head, tail), f, y)
                }
                fiber_list(List.cons(head, tail), f, y) != List[T].nil and x ∈ fiber_list(List.cons(head, tail), f, y)
            }
            p(List.cons(head, tail))
        }
    }
    p(list)
}

/// Any element in fiber list is in the original list.
theorem in_fiber_list[T, U](list: List[T], f: T -> U, x: T, y: U) {
    x ∈ fiber_list(list, f, y) implies x ∈ list
} by {
    define p(l: List[T]) -> Bool {
        x ∉ l implies x ∉ fiber_list(l, f, y)
    }
    p(List[T].nil)
    forall(head: T, tail: List[T]) {
        if p(tail) {
            if x ∉ List.cons(head, tail) {
                x != head
                x ∉ tail
                x ∉ fiber_list(tail, f, y)
                if f(head) = y {
                    fiber_list(List.cons(head, tail), f, y) = List.cons(head, fiber_list(tail, f, y))
                    head ∈ List.cons(head, tail)
                    x ∉ fiber_list(List.cons(head, tail), f, y)
                } else {
                    fiber_list(List.cons(head, tail), f, y) = fiber_list(tail, f, y)
                    x ∉ fiber_list(List.cons(head, tail), f, y)
                }
                x ∉ fiber_list(List.cons(head, tail), f, y)
            }
            p(List.cons(head, tail))
        }
    }
    p(list)
}

/// If x is in fiber list for y, its count in fiber equals its count in list.
theorem fiber_list_count[T, U](list: List[T], f: T -> U, x: T, y: U) {
    x ∈ fiber_list(list, f, y) implies fiber_list(list, f, y).count(x) = list.count(x)
} by {
    define p(l: List[T]) -> Bool {
        x ∈ fiber_list(l, f, y) implies fiber_list(l, f, y).count(x) = l.count(x)
    }
    p(List[T].nil)
    forall(head: T, tail: List[T]) {
        if p(tail) {
            if x ∈ fiber_list(List.cons(head, tail), f, y) {
                f(x) = y
                x ∈ List.cons(head, tail)
                if f(head) = y {
                    fiber_list(List.cons(head, tail), f, y) = List.cons(head, fiber_list(tail, f, y))
                    
                    List.cons(head, fiber_list(tail, f, y)).count(x) = List.singleton(head).count(x) + fiber_list(tail, f, y).count(x)
                    
                    List.cons(head, tail).count(x) = List.singleton(head).count(x) + tail.count(x)

                    if x ∈ tail {
                        x ∈ fiber_list(tail, f, y)
                        fiber_list(tail, f, y).count(x) = tail.count(x)
                    } else {
                        x ∉ tail
                        x ∉ fiber_list(tail, f, y)
                        fiber_list(tail, f, y).count(x) = tail.count(x)
                    }
                    fiber_list(tail, f, y).count(x) = tail.count(x)
                    
                    fiber_list(List.cons(head, tail), f, y).count(x) = List.cons(head, tail).count(x)
                } else {
                    fiber_list(List.cons(head, tail), f, y) = fiber_list(tail, f, y)

                    x != head

                    List.cons(head, tail).count(x) = tail.count(x)

                    fiber_list(tail, f, y).count(x) = tail.count(x)

                    fiber_list(List.cons(head, tail), f, y).count(x) = List.cons(head, tail).count(x)
                }
                p(List.cons(head, tail))
            }
        }
    }
    p(list)
}

/// Fiber list is a subset of the original list.
theorem fiber_list_subset_list[T, U](list: List[T], f: T -> U, y: U) {
    fiber_list(list, f, y) ⊆ list
} 

/// Subset relation is preserved under fiber list construction.
theorem map_preserve_fiber_list_length[T, U](l1: List[T], l2: List[T], f: T -> U, y: U) {
    l1 ⊆ l2 implies fiber_list(l1, f, y) ⊆ fiber_list(l2, f, y)
} by {
    forall(x: T) {
        if x ∈ fiber_list(l1, f, y) {
            f(x) = y
            x ∈ fiber_list(l2, f, y)
            fiber_list(l1, f, y).count(x) = l1.count(x)
            fiber_list(l2, f, y).count(x) = l2.count(x)
            l1.count(x) <= l2.count(x)
            fiber_list(l1, f, y).count(x) <= fiber_list(l2, f, y).count(x)
        }
    }
}

/// Subset relation is preserved under mapping.
theorem map_preserve_subset[T, U](l1: List[T], l2: List[T], f: T -> U) {
    l1 ⊆ l2 implies l1.map(f) ⊆ l2.map(f)
} by {
    forall(y: U) {
        l1.map(f).count(y) = fiber_list(l1, f, y).length
        l2.map(f).count(y) = fiber_list(l2, f, y).length
        fiber_list(l1, f, y) ⊆ fiber_list(l2, f, y)
        fiber_list(l1, f, y).length <= fiber_list(l2, f, y).length
        l1.map(f).count(y) <= l2.map(f).count(y)
    }
}

/// Reduces a non-empty list using binary operator, applying right-to-left.
define two_to_finite[T](op: (T, T) -> T, list: List[T], nil_elem: T) -> T {
    match list {
        List[T].nil {
            nil_elem
        }
        List.cons(head, tail) {
            if tail = List[T].nil {
                head
            } else {
                op(two_to_finite(op, tail, nil_elem), head)
            }
        }
    }
}

/// Concatenates a list of lists into a single list.
define flatten[T](ls: List[List[T]]) -> List[T] {
    match ls {
        List[List[T]].nil {
            List[T].nil
        }
        List[List[T]].cons(head, tail) {
            head + flatten(tail)
        }
    }
}

/// Predicate is preserved under binary operation on its elements.
define preserve_two[T](op: (T, T) -> T, contains: T -> Bool) -> Bool {
    forall(x: T, y: T) {
        contains(x) and contains(y) implies contains(op(x, y))
    }
}

/// If all list elements satisfy predicate and op preserves it, then reduction satisfies it.
define preserve_finite[T](op: (T, T) -> T, list: List[T], nil_elem: T, contains: T -> Bool) -> Bool {
    list.length != 0 and (forall(x: T) { list.contains(x) implies contains(x) }) implies contains(two_to_finite(op, list, nil_elem))
}

/// If binary operation preserves predicate, then reduction also preserves it.
theorem preserve_two_to_finite[T](op: (T, T) -> T, list: List[T], nil_elem: T, contains: T -> Bool) {
    preserve_two(op, contains) implies preserve_finite(op, list, nil_elem, contains)
} by {
    define f(l: List[T]) -> Bool {
        preserve_two(op, contains) implies preserve_finite(op, l, nil_elem, contains)
    }
    f(List[T].nil)
    forall(head: T, tail: List[T]) {
        if f(tail) {
            if tail = List[T].nil {
                List.cons(head, tail) = List.singleton(head)
                two_to_finite(op, List.cons(head, tail), nil_elem) = head
                if List.cons(head, tail).length != 0 and forall(x: T) { List.cons(head, tail).contains(x) implies contains(x) } {
                    List.cons(head, tail).contains(head)
                    contains(head)
                    contains(two_to_finite(op, List.cons(head, tail), nil_elem))
                }
                f(List.cons(head, tail))
            } else {
                tail != List[T].nil
                tail.length != 0
                if List.cons(head, tail).length != 0 and forall(x: T) { List.cons(head, tail).contains(x) implies contains(x) } {
                    forall(x: T) {
                        if tail.contains(x) {
                            List.cons(head, tail).contains(x)
                            contains(x)
                        }
                    }
                    contains(two_to_finite(op, tail, nil_elem))
                    List.cons(head, tail).contains(head)
                    contains(head)
                    contains(op(two_to_finite(op, tail, nil_elem), head))
                    two_to_finite(op, List.cons(head, tail), nil_elem) = op(two_to_finite(op, tail, nil_elem), head)
                    contains(two_to_finite(op, List.cons(head, tail), nil_elem))
                } 
                f(List.cons(head, tail))
            }
            f(List.cons(head, tail))
        }
    }
    f(list)
}

/// f1 is subset of f2 if f1 implies f2 for all elements.
define contains_subset[T](f1: T -> Bool, f2: T -> Bool) -> Bool {
    forall(x: T) {
        f1(x) implies f2(x)
    }
}

/// l1 is subset of l2 if membership predicate of l1 implies that of l2.
define contains_subset_list[T](l1: List[T], l2: List[T]) -> Bool {
    contains_subset(l1.contains, l2.contains)
}