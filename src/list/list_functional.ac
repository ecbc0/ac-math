from list.list_base import List

/// Reverses a list.
define reverse[T](list: List[T]) -> List[T] {
    match list {
        List.nil {
            List.nil[T]
        }
        List.cons(head, tail) {
            reverse(tail).append(head)
        }
    }
}

theorem reverse_add[T](list_1: List[T], list_2: List[T]) {
    reverse(list_1 + list_2) = reverse(list_2) + reverse(list_1)
} by {
    define p(l1: List[T]) -> Bool {
        reverse(l1 + list_2) = reverse(list_2) + reverse(l1)
    }

    // Base case: empty list
    reverse(List.nil[T] + list_2) = reverse(list_2)
    reverse(list_2) + reverse(List.nil[T]) = reverse(list_2)
    p(List.nil[T])

    // Induction
    forall(head: T, tail: List[T]) {
        if p(tail) {
            // Induction hypothesis: reverse(tail + list_2) = reverse(list_2) + reverse(tail)
            // Definition of add
            reverse(List.cons(head, tail) + list_2) = reverse(List.cons(head, tail + list_2))
            reverse(List.cons(head, tail + list_2)) = reverse(tail + list_2).append(head)
            reverse(tail + list_2).append(head) = reverse(tail + list_2) + List.singleton(head)
            reverse(tail + list_2) + List.singleton(head) = (reverse(list_2) + reverse(tail)) + List.singleton(head)
            // associativity
            (reverse(list_2) + reverse(tail)) + List.singleton(head) = reverse(list_2) + (reverse(tail) + List.singleton(head))
            reverse(list_2) + (reverse(tail) + List.singleton(head)) = reverse(list_2) + reverse(tail).append(head)
            reverse(list_2) + reverse(tail).append(head) = reverse(list_2) + reverse(List.cons(head, tail))
            reverse(List.cons(head, tail) + list_2) = reverse(list_2) + reverse(List.cons(head, tail))
            p(List.cons(head, tail))
        }
    }
    p(list_1)
}

theorem reverse_involution[T](list: List[T]) {
    reverse(reverse(list)) = list
} by {
    define p(l: List[T]) -> Bool {
        reverse(reverse(l)) = l
    }

    // Base case: empty list
    p(List.nil[T])

    // Induction
    forall(head: T, tail: List[T]) {
        if p(tail) {
            // Induction hypothesis: reverse(reverse(tail)) = tail
            reverse(reverse(List.cons(head, tail))) = reverse(reverse(tail).append(head))
            reverse(reverse(tail).append(head)) = reverse(reverse(tail) + List.singleton(head))
            reverse(reverse(tail) + List.singleton(head)) = reverse(List.singleton(head)) + reverse(reverse(tail))
            reverse(List.singleton(head)) = List.singleton(head)
            reverse(List.singleton(head)) + reverse(reverse(tail)) = List.singleton(head) + tail
            List.singleton(head) + tail = List.cons(head, tail)
            reverse(reverse(List.cons(head, tail))) = List.cons(head, tail)
            p(List.cons(head, tail))
        }
    }
    p(list)
}

theorem reverse_is_permutation[T](list: List[T]) {
    reverse(list).is_permutation(list)
} by {
    define f(l: List[T]) -> Bool {
        reverse(l).is_permutation(l)
    }
    f(List[T].nil)
    forall(head: T, tail: List[T]) {
        reverse(List.cons(head, tail)) = reverse(tail).append(head)
        reverse(List.cons(head, tail)) = reverse(tail) + List.singleton(head)
        if f(tail) {
            forall(item: T) {
                (reverse(tail) + List.singleton(head)).count(item) = reverse(tail).count(item) + List.singleton(head).count(item)

                List.cons(head, tail).count(item) = List.singleton(head).count(item) + tail.count(item)

                reverse(tail).is_permutation(tail)

                reverse(tail).count(item) = tail.count(item)

                reverse(List.cons(head, tail)).count(item) = List.cons(head, tail).count(item)
            }
            f(List.cons(head, tail))
        }
    }
    f(list)
}