from list.list_base import List
from type_class.add import P_Add, add_fn
from nat import ℕ
numerals ℕ

/// Computes the sum of all elements in a list (requires elements to form an additive commutative monoid).  
/// also aplly to mul ⋅
define sum[A: P_Add](items: List[A]) -> A {
    match items {
        List.nil {
            A.0
        }
        List.cons(head, tail) {
            head + sum(tail)
        }
    }
}

/// Computes the partial sum of a series up to index n.
/// Returns the sum of f(n) + f(n + 1) + ... + f(m).
define partial_sum[A: P_Add](f: ℕ -> A, n: ℕ, m: ℕ) -> A {
    sum(n.upto(m).map(f))
}
// todo: rearrange invariant. ⩽ n! steps. n! is the number of all rearrange (bijective)

define range_sum[A: P_Add](f: ℕ -> A, m: ℕ) -> A {
    sum(m.range.map(f))
}

theorem zero_range_sum[A: P_Add](f: ℕ -> A) {
    range_sum(f, ℕ.0) = A.0
} by {
    0.range = List[ℕ].nil
    0.range.map(f) = List[A].nil
}

theorem range_sum_from_partial_sum[A: P_Add](f: ℕ -> A, m: ℕ) {
    range_sum(f, m.suc) = partial_sum(f, 0, m)
} by {
    m.suc.range = 0.upto(m)
}

theorem sum_add[A: P_Add](left: List[A], right: List[A]) {
    sum(left + right) = sum(left) + sum(right)
} by {
    define p(x: List[A]) -> Bool {
        sum(x + right) = sum(x) + sum(right)
    }

    // Base case: sum(nil + right) = sum(nil) + sum(right)
    sum(List.nil[A] + right) = sum(right)
    sum(List.nil[A]) = A.0
    A.0 + sum(right) = sum(right)
    p(List.nil)

    // Inductive step
    forall(head: A, tail: List[A]) {
        if p(tail) {
            // Induction hypothesis: sum(tail + right) = sum(tail) + sum(right)

            // Left side: sum(List.cons(head, tail) + right)
            // use def of add 
            //     List.cons(head, tail) + right = List.cons(head, tail + right)
            sum(List.cons(head, tail) + right) = sum(List.cons(head, tail + right))

            sum(List.cons(head, tail + right)) = head + sum(tail + right)

            // Use induction hypothesis
            head + sum(tail + right) = head + (sum(tail) + sum(right))

            // Right side: sum(List.cons(head, tail)) + sum(right)
            sum(List.cons(head, tail)) = head + sum(tail)

            sum(List.cons(head, tail)) + sum(right) = (head + sum(tail)) + sum(right)

            // Use associativity
            (head + sum(tail)) + sum(right) = head + (sum(tail) + sum(right))

            // Therefore
            sum(List.cons(head, tail) + right) = sum(List.cons(head, tail)) + sum(right)
            p(List.cons(head, tail))
        }
    }
}

theorem sum_append[A: P_Add](initial: List[A], last: A) {
    sum(initial.append(last)) = sum(initial) + last
}

theorem range_sum_suc[A: P_Add](f: ℕ -> A, m: ℕ) {
    range_sum(f, m.suc) = range_sum(f, m) + f(m)
} by {
    m.suc.range = m.range.append(m)
    m.suc.range.map(f) = m.range.map(f).append(f(m))
    sum(m.range.map(f).append(f(m))) = sum(m.range.map(f)) + f(m)
}

theorem sum_singleton[A: P_Add](x: A) {
    sum(List.singleton(x)) = x
}

theorem partial_one[A: P_Add](f: ℕ -> A) {
    partial_sum(f, 0, 0) = f(0)
} by {
    partial_sum(f, 0, 0) = sum(0.upto(0).map(f))
    0.upto(0) = List.singleton(0)
    List.singleton(0).map(f) = List.singleton(f(0))
}

/// Summing two mapped lists equals mapping with the pointwise sum of functions.
theorem map_sum_add[T, A: P_Add](list: List[T], f: T -> A, g: T -> A) {
    sum(list.map(f)) + sum(list.map(g)) = sum(list.map(add_fn(f, g)))
} by {
    define p(l: List[T]) -> Bool {
        sum(l.map(f)) + sum(l.map(g)) = sum(l.map(add_fn(f, g)))
    }

    // Base case: empty list
    sum(List.nil[T].map(f)) + sum(List.nil[T].map(g)) = A.0 + A.0
    A.0 + A.0 = A.0
    sum(List.nil[T].map(add_fn(f, g))) = A.0
    p(List.nil)

    // Inductive step
    forall(head: T, tail: List[T]) {
        if p(tail) {
            // Induction hypothesis: sum(tail.map(f)) + sum(tail.map(g)) = sum(tail.map(add_fn(f, g)))

            // LHS: sum(List.cons(head, tail).map(f)) + sum(List.cons(head, tail).map(g))
            sum(List.cons(head, tail).map(f)) = sum(List.cons(f(head), tail.map(f)))
            sum(List.cons(f(head), tail.map(f))) = f(head) + sum(tail.map(f))
            sum(List.cons(head, tail).map(g)) = sum(List.cons(g(head), tail.map(g)))
            sum(List.cons(g(head), tail.map(g))) = g(head) + sum(tail.map(g))

            // RHS: sum(List.cons(head, tail).map(add_fn(f, g)))
            List.cons(head, tail).map(add_fn(f, g)) = List.cons(add_fn(f, g)(head), tail.map(add_fn(f, g)))
            add_fn(f, g)(head) = f(head) + g(head)
            sum(List.cons(head, tail).map(add_fn(f, g))) = sum(List.cons(f(head) + g(head), tail.map(add_fn(f, g))))
            sum(List.cons(f(head) + g(head), tail.map(add_fn(f, g)))) = (f(head) + g(head)) + sum(tail.map(add_fn(f, g)))

            // Now we need to show:
            // (f(head) + sum(tail.map(f))) + (g(head) + sum(tail.map(g))) = (f(head) + g(head)) + sum(tail.map(add_fn(f, g)))

            // Using the induction hypothesis:
            sum(tail.map(f)) + sum(tail.map(g)) = sum(tail.map(add_fn(f, g)))

            // Using associativity and commutativity:
            (f(head) + sum(tail.map(f))) + (g(head) + sum(tail.map(g))) = (f(head) + g(head)) + sum(tail.map(add_fn(f, g)))

            p(List.cons(head, tail))
        }
    }
}


/// Adding two partial sums equals the partial sum of pointwise sums.
theorem partial_add[A: P_Add](f: ℕ -> A, g: ℕ -> A, n: ℕ, m: ℕ) {
    partial_sum(f, n, m) + partial_sum(g, n, m) = partial_sum(add_fn(f, g), n, m)
} by {
    // Expand the definitions of partial
    partial_sum(f, n, m) = sum(n.upto(m).map(f))
    partial_sum(g, n, m) = sum(n.upto(m).map(g))
    partial_sum(add_fn(f, g), n, m) = sum(n.upto(m).map(add_fn(f, g)))

    // Use map_sum_add theorem
    sum(n.upto(m).map(f)) + sum(n.upto(m).map(g)) = sum(n.upto(m).map(add_fn(f, g)))
}
