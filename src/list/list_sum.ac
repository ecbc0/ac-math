from list.list_base import List
from type_class.add import Add, add_fn
from nat import ℕ
numerals ℕ

/// Computes the sum of all elements in a list (requires elements to form an additive commutative monoid).  
/// also aplly to mul ⋅
define sum[A: Add](items: List[A]) -> A {
    match items {
        List.nil {
            A.0
        }
        List.cons(head, tail) {
            head + sum(tail)
        }
    }
}

/// Computes the partial sum of a series up to index n.
/// Returns the sum of f(n) + f(n + 1) + ... + f(m).
define partial_sum[A: Add](f: ℕ -> A, n: ℕ, m: ℕ) -> A {
    sum(n.upto(m).map(f))
}
// todo: rearrange invariant. ⩽ n! steps. n! is the number of all rearrange (bijective)

theorem sum_add[A: Add](left: List[A], right: List[A]) {
    sum(left + right) = sum(left) + sum(right)
} by {
    define p(x: List[A]) -> Bool {
        sum(x + right) = sum(x) + sum(right)
    }

    // Base case: sum(nil + right) = sum(nil) + sum(right)
    sum(List.nil[A] + right) = sum(right)
    sum(List.nil[A]) = A.0
    A.0 + sum(right) = sum(right)
    p(List.nil)

    // Inductive step
    forall(head: A, tail: List[A]) {
        if p(tail) {
            // Induction hypothesis: sum(tail + right) = sum(tail) + sum(right)

            // Left side: sum(List.cons(head, tail) + right)
            // use def of add 
            //     List.cons(head, tail) + right = List.cons(head, tail + right)
            sum(List.cons(head, tail) + right) = sum(List.cons(head, tail + right))

            sum(List.cons(head, tail + right)) = head + sum(tail + right)

            // Use induction hypothesis
            head + sum(tail + right) = head + (sum(tail) + sum(right))

            // Right side: sum(List.cons(head, tail)) + sum(right)
            sum(List.cons(head, tail)) = head + sum(tail)

            sum(List.cons(head, tail)) + sum(right) = (head + sum(tail)) + sum(right)

            // Use associativity
            (head + sum(tail)) + sum(right) = head + (sum(tail) + sum(right))

            // Therefore
            sum(List.cons(head, tail) + right) = sum(List.cons(head, tail)) + sum(right)
            p(List.cons(head, tail))
        }
    }
}

theorem sum_append[A: Add](initial: List[A], last: A) {
    sum(initial.append(last)) = sum(initial) + last
}

theorem sum_singleton[A: Add](x: A) {
    sum(List.singleton(x)) = x
}

theorem partial_one[A: Add](f: ℕ -> A) {
    partial_sum(f, 0, 0) = f(0)
} by {
    partial_sum(f, 0, 0) = sum(0.upto(0).map(f))
    0.upto(0) = List.singleton(0)
    List.singleton(0).map(f) = List.singleton(f(0))
}

/// Summing two mapped lists equals mapping with the pointwise sum of functions.
theorem map_sum_add[T, A: Add](list: List[T], f: T -> A, g: T -> A) {
    sum(list.map(f)) + sum(list.map(g)) = sum(list.map(add_fn(f, g)))
} by {
    define p(l: List[T]) -> Bool {
        sum(l.map(f)) + sum(l.map(g)) = sum(l.map(add_fn(f, g)))
    }

    // Base case: empty list
    sum(List.nil[T].map(f)) + sum(List.nil[T].map(g)) = A.0 + A.0
    A.0 + A.0 = A.0
    sum(List.nil[T].map(add_fn(f, g))) = A.0
    p(List.nil)

    // Inductive step
    forall(head: T, tail: List[T]) {
        if p(tail) {
            // Induction hypothesis: sum(tail.map(f)) + sum(tail.map(g)) = sum(tail.map(add_fn(f, g)))

            // LHS: sum(List.cons(head, tail).map(f)) + sum(List.cons(head, tail).map(g))
            sum(List.cons(head, tail).map(f)) = sum(List.cons(f(head), tail.map(f)))
            sum(List.cons(f(head), tail.map(f))) = f(head) + sum(tail.map(f))
            sum(List.cons(head, tail).map(g)) = sum(List.cons(g(head), tail.map(g)))
            sum(List.cons(g(head), tail.map(g))) = g(head) + sum(tail.map(g))

            // RHS: sum(List.cons(head, tail).map(add_fn(f, g)))
            List.cons(head, tail).map(add_fn(f, g)) = List.cons(add_fn(f, g)(head), tail.map(add_fn(f, g)))
            add_fn(f, g)(head) = f(head) + g(head)
            sum(List.cons(head, tail).map(add_fn(f, g))) = sum(List.cons(f(head) + g(head), tail.map(add_fn(f, g))))
            sum(List.cons(f(head) + g(head), tail.map(add_fn(f, g)))) = (f(head) + g(head)) + sum(tail.map(add_fn(f, g)))

            // Now we need to show:
            // (f(head) + sum(tail.map(f))) + (g(head) + sum(tail.map(g))) = (f(head) + g(head)) + sum(tail.map(add_fn(f, g)))

            // Using the induction hypothesis:
            sum(tail.map(f)) + sum(tail.map(g)) = sum(tail.map(add_fn(f, g)))

            // Using associativity and commutativity:
            (f(head) + sum(tail.map(f))) + (g(head) + sum(tail.map(g))) = (f(head) + g(head)) + sum(tail.map(add_fn(f, g)))

            p(List.cons(head, tail))
        }
    }
}


/// Adding two partial sums equals the partial sum of pointwise sums.
theorem partial_add[A: Add](f: ℕ -> A, g: ℕ -> A, n: ℕ, m: ℕ) {
    partial_sum(f, n, m) + partial_sum(g, n, m) = partial_sum(add_fn(f, g), n, m)
} by {
    // Expand the definitions of partial
    partial_sum(f, n, m) = sum(n.upto(m).map(f))
    partial_sum(g, n, m) = sum(n.upto(m).map(g))
    partial_sum(add_fn(f, g), n, m) = sum(n.upto(m).map(add_fn(f, g)))

    // Use map_sum_add theorem
    sum(n.upto(m).map(f)) + sum(n.upto(m).map(g)) = sum(n.upto(m).map(add_fn(f, g)))
}

from type_class.ring import Ring

/// Helper function for scalar multiplication.
define scalar_mul[S: Ring](c: S, x: S) -> S {
    c ⋅ x
}

/// Multiplying a constant by a sum equals the sum of the products.
theorem sum_scalar_mul[S: Ring](c: S, list: List[S]) {
    c ⋅ sum(list) = sum(list.map(scalar_mul(c)))
} by {
    define p(xs: List[S]) -> Bool {
        c ⋅ sum(xs) = sum(xs.map(scalar_mul(c)))
    }

    // Base case: c ⋅ sum(nil) = sum(map(nil, scalar_mul(c)))
    sum(List.nil[S]) = S.0
    c ⋅ S.0 = S.0
    List.nil[S].map(scalar_mul(c)) = List.nil[S]
    sum(List.nil[S]) = S.0
    p(List.nil)

    // Inductive step
    forall(head: S, tail: List[S]) {
        if p(tail) {
            // Induction hypothesis: c ⋅ sum(tail) = sum(tail.map(scalar_mul(c)))

            // Left side: c ⋅ sum(cons(head, tail))
            sum(List.cons(head, tail)) = head + sum(tail)
            c ⋅ sum(List.cons(head, tail)) = c ⋅ (head + sum(tail))
            c ⋅ (head + sum(tail)) = (c ⋅ head) + (c ⋅ sum(tail))

            // Apply induction hypothesis
            c ⋅ sum(tail) = sum(tail.map(scalar_mul(c)))
            (c ⋅ head) + (c ⋅ sum(tail)) = (c ⋅ head) + sum(tail.map(scalar_mul(c)))

            // Right side: sum(map(cons(head, tail), scalar_mul(c)))
            List.cons(head, tail).map(scalar_mul(c)) = List.cons(scalar_mul(c)(head), tail.map(scalar_mul(c)))
            scalar_mul(c)(head) = c ⋅ head
            List.cons(head, tail).map(scalar_mul(c)) = List.cons(c ⋅ head, tail.map(scalar_mul(c)))
            sum(List.cons(head, tail).map(scalar_mul(c))) = (c ⋅ head) + sum(tail.map(scalar_mul(c)))

            c ⋅ sum(List.cons(head, tail)) = sum(List.cons(head, tail).map(scalar_mul(c)))
            p(List.cons(head, tail))
        }
    }
}

from type_class.mul import mul_fn
from util import compose

/// Distributing scalar multiplication through a partial sum.
theorem partial_scalar_mul[S: Ring](c: S, f: ℕ -> S, n: ℕ, m: ℕ) {
    c ⋅ partial_sum(f, n, m) = partial_sum(mul_fn(c, f), n, m)
} by {
    // Expand the definition of partial
    partial_sum(f, n, m) = sum(n.upto(m).map(f))
    c ⋅ partial_sum(f, n, m) = c ⋅ sum(n.upto(m).map(f))

    // Use sum_scalar_mul theorem
    c ⋅ sum(n.upto(m).map(f)) = sum(n.upto(m).map(f).map(scalar_mul(c)))

    // Use the map_map theorem
    n.upto(m).map(f).map(scalar_mul(c)) = n.upto(m).map(compose(scalar_mul(c), f))

    // Show that compose(scalar_mul(c), f) = mul_fn(c, f)
    forall(k: ℕ) {
        compose(scalar_mul(c), f)(k) = scalar_mul(c)(f(k))
        scalar_mul(c)(f(k)) = c ⋅ f(k)
        mul_fn(c, f)(k) = c ⋅ f(k)
        compose(scalar_mul(c), f)(k) = mul_fn(c, f)(k)
    }

    // The two functions are equal
    compose(scalar_mul(c), f) = mul_fn(c, f)
    n.upto(m).map(compose(scalar_mul(c), f)) = n.upto(m).map(mul_fn(c, f))
    sum(n.upto(m).map(f).map(scalar_mul(c))) = sum(n.upto(m).map(mul_fn(c, f)))

    partial_sum(mul_fn(c, f), n, m) = sum(n.upto(m).map(mul_fn(c, f)))
}
