/// A generic list data structure that can hold elements of any type.
/// Lists are constructed using nil (empty list) and cons (prepending an element).  
/// Nat is also defined inductively. In fact, List can be understood as a mapping constructed in an inductive way with Nat or a finite subset of it as the domain, by the length method 
inductive List[T] {
    /// The empty list.
    nil
    /// Constructs a list by prepending an element to an existing list.
    cons(T, List[T])
}

attributes List[T] {
    /// Concatenates two lists together.
    define add(self, other: List[T]) -> List[T] {
        match self {
            List.nil {
                other
            }
            List.cons(head, tail) {
                List.cons(head, tail.add(other))
            } 
        }
    }

    /// True if this list contains the given item.
    define contains(self, item: T) -> Bool {
        match self {
            List.nil {
                false
            }
            List.cons(head, tail) {
                if head = item {
                    true
                } else {
                    tail.contains(item)
                }
            }
        }
    }
}

theorem add_nil[T](list: List[T]) {
    list + List.nil[T] = list
}

theorem add_nil_dual[T](list: List[T]) {
    List.nil[T] + list = list
}

theorem add_contains_left[T](left: List[T], right: List[T], item: T) {
    left.contains(item) implies (left + right).contains(item)
} by {
    define f(x: List[T]) -> Bool {
        x.contains(item) implies (x + right).contains(item)
    }
    f(List.nil)
    forall(head: T, tail: List[T]) {
        if f(tail) {
            f(List.cons(head, tail))
            // see definition of contains & add ...
        }
    }
}

theorem add_contains_right[T](left: List[T], right: List[T], item: T) {
    right.contains(item) implies (left + right).contains(item)
} by {
    define f(x: List[T]) -> Bool {
        (x + right).contains(item) // this helper function is different from that defined in add_contains_left
    }
    f(List.nil)
    forall(head: T, tail: List[T]) {
        if f(tail) {
            f(List.cons(head, tail)) // forward check until arrive the right, then f(right) = true
        }
    }
}

theorem not_contains_add[T](left: List[T], right: List[T], item: T) {
    not left.contains(item) and not right.contains(item) implies not (left + right).contains(item)
} by {
    // if not right.contains(item)
    define f(x: List[T]) -> Bool {
        not x.contains(item) implies not (x + right).contains(item)
    }
    f(List.nil)
    forall(head: T, tail: List[T]) {
        if f(tail) {
            f(List.cons(head, tail))
            // see definiton of (not) contains
            //     if p { q1 } else { q2 } 
            // is equivalent to 
            //     (p => q1) and ((not p) => q2) 
            // so its negative is 
            //     (p and (not q1)) or ((not p) and (not q2))
            // for 
            //     not (head, tail).contains(item)
            // either 
            //     head = item & (head, tails).contains(head/item) = false
            // or 
            //     head != item & not tails.contain(item). 
            // induction is from `(head, tails) + right` forward to `tails + right`
        }
    }
}

from nat.nat_base import Nat
numerals Nat

attributes List[T] {
    /// True if this list contains every element of type T.
    define contains_every(self) -> Bool {
        forall(x: T) {
            self.contains(x)
        }
    }

    /// True if this list contains any element of type T.
    define contains_any(self) -> Bool {
        exists(x: T) {
            self.contains(x)
        }
    }

    /// Yields the number of elements in the list.
    define length(self) -> Nat {
        match self {
            List.nil {
                0
            }
            List.cons(_, tail) {
                tail.length.suc
                // how to avoid infinity?
            }
        }
    }
}

theorem add_length[T](left: List[T], right: List[T]) {
    left.length + right.length = (left + right).length
} by {
    define f(x: List[T]) -> Bool {
        x.length + right.length = (x + right).length
    }
    f(List.nil)
    forall(head: T, tail: List[T]) {
        if f(tail) {
            f(List.cons(head, tail))
        }
    }
}

attributes List[T] {
    /// Creates a list containing a single element.
    let singleton: T -> List[T] = function(x: T) {
        List.cons(x, List.nil[T])
    }

    /// Removes all duplicate elements from the list.
    /// When duplicates exist, the last occurrence is kept.
    define unique(self) -> List[T] {
        match self {
            List.nil {
                List.nil[T]
            }
            List.cons(head, tail) {
                if tail.contains(head) {
                    tail.unique
                } else {
                    List.cons(head, tail.unique)
                }
            }
        }
    }

    define is_unique(self) -> Bool {
        self.unique = self
    }
}

theorem singleton_unique[T](item: T) {
    List.singleton(item).is_unique
}

theorem unique_length[T](list: List[T]) {
    list.unique.length <= list.length
} by {
    define f(x: List[T]) -> Bool {
        x.unique.length <= x.length
    }
    f(List.nil)
    forall(head: T, tail: List[T]) {
        if f(tail) {
            tail.unique.length <= tail.length
            List.cons(head, tail).length = tail.length.suc
            if tail.contains(head) {
                List.cons(head, tail).unique = tail.unique
                f(List.cons(head, tail))
            } else {
                List.cons(head, tail).unique.length = tail.unique.length.suc
                f(List.cons(head, tail))
            }
            f(List.cons(head, tail))
        }
    }
}

theorem unique_decomposition[T](head: T, tail: List[T]) {
    if tail.contains(head) { 
        List.cons(head, tail).unique = tail.unique 
    } and 
    if not tail.contains(head) { 
        List.cons(head, tail).unique = List.cons(head, tail.unique) 
    }
} by {
    // helper
    tail.contains(head) implies List.cons(head, tail).unique = tail.unique 
}

theorem contains_decomposition[T](head: T, tail: List[T], item: T) {
    List.cons(head, tail).contains(item) iff head = item or tail.contains(item)
} by {
    // helper
    head = item or tail.contains(item) implies List.cons(head, tail).contains(item)
}

theorem contains_decomposition_dual[T](head: T, tail: List[T], item: T) {
    not List.cons(head, tail).contains(item) iff head != item and not tail.contains(item)
} by {
    // helper
    contains_decomposition[T](head, tail, item)
}

theorem contains_when_head_not_eq_item[T](head: T, tail: List[T], item: T) {
    if head != item {
        // def of contains
        List.cons(head, tail).contains(item) iff tail.contains(item)
    }
} by {
    // helper
    List.cons(head, tail).contains(item) implies tail.contains(item)
}

theorem contains_when_tail_contains_head[T](head: T, tail: List[T], item: T) {
    if tail.contains(head) {
        List.cons(head, tail).contains(item) iff tail.contains(item) 
    }
} by {
    if head = item {
        tail.contains(item)
        List.cons(head, tail).contains(item)
    }
    if head != item {
        // def of contains
        // helper
        List.cons(head, tail).contains(item) implies tail.contains(item)

        List.cons(head, tail).contains(item) iff tail.contains(item)
    }
}

theorem contains_when_tail_not_contains_head[T](head: T, tail: List[T], item: T) {
    if not tail.contains(head) {
        if head = item {
            // def of contains
            List.cons(head, tail).contains(item) iff head = item
        } 
        // case head != item already handled
    }
} 

theorem unique_preserves_contains[T](list: List[T], item: T) {
    list.unique.contains(item) iff list.contains(item)
} by {
    define p(l: List[T]) -> Bool {
        l.unique.contains(item) iff l.contains(item)
    }

    // Base case: empty list
    p(List.nil[T])

    // Induction when add head to tail
    forall(head: T, tail: List[T]) {

        if p(tail) {
            if tail.contains(head) {
                List.cons(head, tail).unique = tail.unique

                List.cons(head, tail).contains(item) iff tail.contains(item)
                // p(tail)
                tail.unique.contains(item) iff tail.contains(item)
                // induction success
                p(List.cons(head, tail))
            } 
            if not tail.contains(head) {           
                List.cons(head, tail).unique = List.cons(head, tail.unique)
                
                if head = item {
                    List.cons(head, tail).contains(item) iff head = item
                    // similar
                    List.cons(head, tail.unique).contains(item) iff head = item
                    
                    p(List.cons(head, tail))
                }
                if head != item {
                    List.cons(head, tail).contains(item) iff tail.contains(item)
                    // similar
                    List.cons(head, tail.unique).contains(item) iff tail.unique.contains(item)
                    // p(tail)
                    tail.unique.contains(item) iff tail.contains(item)
                    
                    p(List.cons(head, tail))
                }
                p(List.cons(head, tail))
            }
            p(List.cons(head, tail))
        }
    }
}

theorem unique_indemp[T](list: List[T]) {
    list.unique.unique = list.unique
} by {
    let list_unique = list.unique

    define f(x: List[T]) -> Bool {
        x.unique.unique = x.unique
    }

    // Base case
    f(List.nil)

    // Induction
    forall(head: T, tail: List[T]) {
        if f(tail) {
            tail.unique.unique = tail.unique

            if tail.contains(head) {
                List.cons(head, tail).unique = tail.unique

                List.cons(head, tail).unique.unique = tail.unique.unique
                // use f(tail)
                f(List.cons(head, tail))
            } 
            if not tail.contains(head) {
                List.cons(head, tail).unique = List.cons(head, tail.unique)

                not tail.unique.contains(head)

                List.cons(head, tail.unique).unique = List.cons(head, tail.unique.unique)
                // use f(tail)
                f(List.cons(head, tail))
            }
            f(List.cons(head, tail))
        }
    }
}

theorem unique_list_is_unique[T](list: List[T]) {
    list.unique.is_unique
}

theorem unique_implies_tail_unique[T](head: T, tail: List[T]) {
    List.cons(head, tail).is_unique implies tail.is_unique
} by {
    if tail.contains(head) {
        List.cons(head, tail).unique = tail.unique

        List.cons(head, tail).length = tail.length + 1

        List.cons(head, tail).unique.length < List.cons(head, tail).length

        not List.cons(head, tail).is_unique
    } 
    if not tail.contains(head) {
        List.cons(head, tail).unique = List.cons(head, tail.unique)
    }
}

attributes List[T] {
    define count(self, item: T) -> Nat {
        match self {
            List.nil[T] {
                0
            }
            List.cons(head, tail) {
                if head = item {
                    1 + tail.count(item)
                } else {
                    tail.count(item)
                }
            }
        }
    }
}

theorem count_increas[T](head: T, tail: List[T], item: T) {
    List.cons(head, tail).count(item) >= tail.count(item)
}

theorem list_contains_implies_count_geq_one[T](list: List[T], item: T) {
    list.contains(item) implies list.count(item) >= 1
} by {
    define p(l: List[T]) -> Bool {
        l.contains(item) implies l.count(item) >= 1
    }

    // Base case: empty list
    p(List.nil[T])

    // Induction
    forall(head: T, tail: List[T]) {
        if p(tail) {
            if List.cons(head, tail).contains(item) {
                if head = item {
                    List.cons(head, tail).count(item) = 1 + tail.count(item)
                    List.cons(head, tail).count(item) >= 1
                } 
                if head != item {
                    tail.contains(item)
                    tail.count(item) >= 1
                    List.cons(head, tail).count(item) >= 1
                }
                p(List.cons(head, tail))
            }
        }
    }
    p(list)
}

theorem list_not_contains_iff_count_zero[T](list: List[T], item: T) {
    not list.contains(item) iff list.count(item) = 0
} by {
    define p(l: List[T]) -> Bool {
        not l.contains(item) implies l.count(item) = 0
    }
    p(List.nil)
    forall(head: T, tail: List[T]) {
        if p(tail) {
            if not List.cons(head, tail).contains(item) {
                head != item and not tail.contains(item)
                
                List.cons(head, tail).count(item) = 0

                p(List.cons(head, tail))
            }
        }
    }
    p(list)
}

theorem unique_implies_no_duplicate[T](list: List[T], item: T) {
    list.is_unique implies list.count(item) <= 1
} by {
    define p(l: List[T]) -> Bool {
        l.is_unique implies l.count(item) <= 1
    }

    // Base case: empty list
    p(List.nil[T])

    // Induction
    forall(head: T, tail: List[T]) {
        if p(tail) and List.cons(head, tail).contains(item) {
            head = item or tail.contains(item)
            if List.cons(head, tail).is_unique {
                not tail.contains(head)
                if head = item {
                    List.cons(head, tail).count(item) = 1 + tail.count(item)
                    // head = item & tail.contains(head)
                    tail.count(item) = 0
                    List.cons(head, tail).count(item) <= 1
                } else {
                    List.cons(head, tail).count(item) = tail.count(item)
                    // p(tail)
                    List.cons(head, tail).count(item) <= 1
                }
                p(List.cons(head, tail))
            }
            p(List.cons(head, tail))
        }
    }
    p(list)
}

attributes List[T] {
    define no_duplicate(self) -> Bool {
        forall(item: T) { 
            self.count(item) <= 1 
        }
    }
    define duplicate(self) -> Bool {
        exists(item: T) { 
            self.count(item) > 1 
        }
    }
}

theorem no_duplicate_is_not_duplicate[T](list: List[T]) {
    list.no_duplicate iff not list.duplicate
} by {
    // helper
    list.no_duplicate implies not list.duplicate
}

theorem no_duplicate_implies_unique[T](list: List[T]) {
    list.no_duplicate implies list.is_unique
} by {
    define p(l: List[T]) -> Bool {
        (forall(item: T) { l.count(item) <= 1 }) implies l.is_unique
    }

    // Base case: empty list
    p(List.nil[T])

    // Induction
    forall(head: T, tail: List[T]) {
        if p(tail) {
            if (forall(item: T) { List.cons(head, tail).count(item) <= 1 }) {
                (forall(item: T) { 
                    // helper
                    if tail.contains(item) {
                        tail.count(item) <= 1 
                    }
                })
                tail.is_unique
                not tail.contains(head)
                List.cons(head, tail).is_unique
            }
            p(List.cons(head, tail))
        }
    }
    p(list)
}

theorem no_duplicate_iff_unique[T](list: List[T]) {
    list.no_duplicate iff list.is_unique
} by {
    // helper
    list.is_unique implies list.no_duplicate
}

theorem duplicate_iff_not_unique[T](list: List[T]) {
    not list.is_unique iff list.duplicate
} 

attributes List[T] {
    /// Appends a single element to the end of the list.
    define append(self, item: T) -> List[T] {
        self + List.singleton(item)
    }
}

attributes Nat {
    /// Creates a list of natural numbers from 0 to n-1.
    define range(self) -> List[Nat] {
        match self {
            0 {
                List.nil[Nat]
            }
            Nat.suc(pred) {
                pred.range.append(pred)
            }
        }
    }
}

attributes List[T] {
    /// Alternate name for `Nat.range`.
    /// Creates a list of natural numbers from 0 to n-1.
    let range: Nat -> List[Nat] = Nat.range

    /// Filters the list, keeping only elements that satisfy the given predicate.
    define filter(self, f: T -> Bool) -> List[T] {
        match self {
            List.nil {
                List.nil[T]
            }
            List.cons(head, tail) {
                if f(head) {
                    List.cons(head, tail.filter(f))
                } else {
                    tail.filter(f)
                }
            }
        }
    }

    /// Remove all instances of an element from the list.
    // TODO: prove that this matches filter in the expected case
    define remove_elem(self, elem: T) -> List[T] {
        match self {
            List.nil {
                List.nil[T]
            }
            List.cons(head, tail) {
                if head != elem {
                    List.cons(head, tail.remove_elem(elem))
                } else {
                    tail.remove_elem(elem)
                }
            }
        }
    }
}

define not_expect[T](elem: T, item: T) -> Bool {
    elem != item
}

theorem remove_elem_is_filter[T](list: List[T], elem: T) {
    list.remove_elem(elem) = list.filter(not_expect(elem))   
} by {
    define p(l: List[T]) -> Bool {
        l.remove_elem(elem) = l.filter(not_expect(elem)) 
    }

    // Base case: empty list
    p(List.nil[T])

    // Induction
    forall(head: T, tail: List[T]) {
        if p(tail) {
            tail.remove_elem(elem) = tail.filter(not_expect(elem))
            if head != elem {
                List.cons(head, tail).remove_elem(elem) = List.cons(head, tail.remove_elem(elem))

                not_expect(elem, head) = true

                List.cons(head, tail).filter(not_expect(elem)) = List.cons(head, tail.filter(not_expect(elem)))

                p(List.cons(head, tail))
            } 
            if head = elem {
                List.cons(head, tail).remove_elem(elem) = tail.remove_elem(elem)

                not_expect(elem, head) = false

                List.cons(head, tail).filter(not_expect(elem)) = tail.filter(not_expect(elem))

                p(List.cons(head, tail))
            }
            p(List.cons(head, tail)) 
        }
    }
    p(list)
}

theorem remove_elem_does_remove[T](list: List[T], elem: T) {
    not list.remove_elem(elem).contains(elem)   
} by {
    define p(l: List[T]) -> Bool {
        not l.remove_elem(elem).contains(elem)
    }
    p(List.nil)

    forall(head: T, tail: List[T]) {
        if p(tail) {
            not tail.remove_elem(elem).contains(elem)
            if head = elem {
                List.cons(head, tail).remove_elem(elem) = tail.remove_elem(elem)
            }
            if head != elem {
                List.cons(head, tail).remove_elem(elem) = List.cons(head, tail.remove_elem(elem))

                not List.cons(head, tail).remove_elem(elem).contains(elem)
            }
            p(List.cons(head, tail))
        }
    }
    p(list)
}

theorem remove_decrease_or_nothing[T](list: List[T], elem: T) {
    (
        list.contains(elem) iff list.remove_elem(elem).length < list.length
    ) and (
        not list.contains(elem) iff list.remove_elem(elem) = list
    )
} by {
    define p(l: List[T]) -> Bool {
        (
            l.contains(elem) iff l.remove_elem(elem).length < l.length
        ) and (
            not l.contains(elem) iff l.remove_elem(elem) = l
        )   
    }

    // Base case: empty list
    p(List.nil[T])

    // Induction
    forall(head: T, tail: List[T]) {
        if p(tail) {   
            if head = elem {
                List.cons(head, tail).remove_elem(elem) = tail.remove_elem(elem)
                // p(tail)
                tail.remove_elem(elem).length <= tail.length

                List.cons(head, tail).remove_elem(elem).length < List.cons(head, tail).length

                p(List.cons(head, tail))
            }
            if head != elem {
                List.cons(head, tail).remove_elem(elem) = List.cons(head, tail.remove_elem(elem))

                if List.cons(head, tail).contains(elem) {
                    tail.contains(elem) 
                    // p(tail)
                    tail.remove_elem(elem).length < tail.length

                    List.cons(head, tail).remove_elem(elem).length < List.cons(head, tail).length

                    p(List.cons(head, tail))
                }
                if not List.cons(head, tail).contains(elem) {
                    not tail.contains(elem) 
                    // p(tail)
                    tail.remove_elem(elem) = tail

                    List.cons(head, tail).remove_elem(elem) = List.cons(head, tail)
                    
                    p(List.cons(head, tail))
                }
                p(List.cons(head, tail))
            }
            p(List.cons(head, tail))
        }
    }
    p(list)
}

theorem remove_preserve_not_conatins[T](list: List[T], item: T, elem: T) {
    not list.contains(item) implies not list.remove_elem(elem).contains(item)
    // the reverse direction is rarely used and need forall(elem: T){ elem != item implies ...}, which make the proof too long
} by {
    define p(l: List[T]) -> Bool {
        not l.contains(item) implies not l.remove_elem(elem).contains(item)
    }

    // Base case: empty list
    p(List.nil[T])

    // Induction
    forall(head: T, tail: List[T]) {
        if p(tail) {   
            if not List.cons(head, tail).contains(item) {
                head != item
                not tail.contains(item)
                
                if head = elem {
                    List.cons(head, tail).remove_elem(elem) = tail.remove_elem(elem)

                    // p(tail)
                    not tail.remove_elem(elem).contains(item)

                    not List.cons(head, tail).remove_elem(elem).contains(item)
                }
                if head != elem {
                    List.cons(head, tail).remove_elem(elem) = List.cons(head, tail.remove_elem(elem))

                    not List.cons(head, tail).remove_elem(elem).contains(item)
                }
                not List.cons(head, tail).remove_elem(elem).contains(item)
                
                p(List.cons(head, tail))
            }
        }
    }
    p(list)
}

theorem remove_unique[T](list: List[T], elem: T) {
    if list.is_unique and list.contains(elem) {
        list.remove_elem(elem).is_unique and

        list.remove_elem(elem).length + 1 = list.length 
    }
} by {
    define p(l: List[T]) -> Bool {
        if l.is_unique and l.contains(elem) {
            l.remove_elem(elem).is_unique and
            l.remove_elem(elem).length + 1 = l.length 
        } // the reverse direction seems true, but rarely used, I think
    }

    // Base case: empty list
    p(List.nil[T])

    // Induction
    forall(head: T, tail: List[T]) {
        if p(tail) {
            if 
            List.cons(head, tail).is_unique and 
            List.cons(head, tail).contains(elem) {
                if head = elem {
                    not tail.contains(elem)

                    List.cons(head, tail).remove_elem(elem) = tail

                    tail.is_unique

                    tail.length + 1 = List.cons(head, tail).length

                    p(List.cons(head, tail))
                }
                if head != elem {
                    tail.contains(elem)
                    tail.is_unique

                    List.cons(head, tail).remove_elem(elem) = List.cons(head, tail.remove_elem(elem))

                    // p(tail)
                    tail.remove_elem(elem).is_unique

                    tail.remove_elem(elem).length + 1 = tail.length

                    not tail.contains(head)

                    not tail.remove_elem(elem).contains(head)

                    List.cons(head, tail.remove_elem(elem)).is_unique

                    p(List.cons(head, tail))
                }   
                p(List.cons(head, tail))
            }
            p(List.cons(head, tail))
        }
    }
    p(list)
}

// Length theorems
theorem length_range(n: Nat) {
    n.range.length = n
} by {
    // Induction on n
    define f(x: Nat) -> Bool {
        x.range.length = x
    }

    // Base case: 0.range.length = 0
    0.range = List.nil[Nat]
    List.nil[Nat].length = 0
    f(0)

    // Inductive step
    forall(x: Nat) {
        if f(x) {
            // Induction hypothesis: x.range.length = x
            (x + 1).range = x.range.append(x)
            (x + 1).range = x.range + List.singleton(x)

            // Use add_length theorem

            (x + 1).range.length = x.range.length + List.singleton(x).length

            // Simplify the left side
            x.range.length = x
            List.singleton(x).length = 1

            // Therefore
            (x + 1).range.length = x + 1
            f(x + 1)
        }
    }

    // Conclusion
    f(n)
}

theorem suc_range_contains(n: Nat) {
    (n + 1).range.contains(n)
} by {
    List.singleton(n).contains(n)
    (n + 1).range = n.range + List.singleton(n)
    (n + 1).range.contains(n)
}

theorem range_contains_all_leq(n: Nat) {
    forall(x: Nat) {
        x < n implies n.range.contains(x)
    }
} by {
    define p(m: Nat) -> Bool {
        forall(x: Nat) {
            x < m implies m.range.contains(x)
        }
    }

    // Base case: 0
    p(0)

    // Induction
    forall(m: Nat) {
        if p(m) {
            // Induction hypothesis: forall(x: Nat) { x < m implies m.range.contains(x) }
            forall(x: Nat) {
                if x < m + 1 {
                    if x < m {
                        m.range.contains(x)
                        (m + 1).range.contains(x)
                    } 
                    if x = m {
                        x = m
                        (m + 1).range.contains(m)
                        (m + 1).range.contains(x)
                    }
                    (m + 1).range.contains(x)
                }
            }
            p(m + 1)
        }
    }

    // Conclusion
    p(n)
}

theorem range_does_not_contain_geq(m: Nat, n: Nat) {
    n >= m implies not m.range.contains(n)
} by {
    define p(x: Nat) -> Bool {
        forall(y: Nat) {
            y >= x implies not x.range.contains(y)
        }
    }

    // Base case: 0
    p(0)

    // Induction
    forall(x: Nat) {
        (x + 1).range = x.range + List.singleton(x)
        if p(x) {
            forall(y: Nat) {
                if y >= x + 1 {
                    y > x 
                    not x.range.contains(y)
                    not List.singleton(x).contains(y)

                    not (x + 1).range.contains(y)
                }
            }
            p(x + 1)
        }
    }
}

theorem range_iff_contains_all_leq(n: Nat) {
    forall(x: Nat) {
        x < n iff n.range.contains(x)
    }
} by {
    forall(x: Nat) {
        x < n implies n.range.contains(x)
        
        not x < n implies not n.range.contains(x)

        x < n iff n.range.contains(x)
    }
}

/// Applies a function to each element of a list, creating a new list of results.
attributes List[T] {
    define map[U](self, f: T -> U) -> List[U] {
        match self {
            List.nil {
                List.nil[U]
            }
            List.cons(head, tail) {
                List.cons(f(head), tail.map(f))
            }
        }
    }
}

/// also called "commutative monoid".  
/// also apply to mul *
typeclass A: Add {
    /// The binary addition operation that combines two elements
    add: (A, A) -> A

    /// The additive identity element
    0: A

    /// The identity element must satisfy the identity property
    add_identity(a: A) {
        a + A.0 = a
    }

    /// The addition operation must be commutative: `a + b = b + a`
    commutative(a: A, b: A) {
        a + b = b + a
    }

    /// The addition operation must be associative: `(a + b) + c = a + (b + c)`
    add_associative(a: A, b: A, c: A) {
        a + (b + c) = (a + b) + c
    }
}

/// Computes the sum of all elements in a list (requires elements to form an additive commutative monoid).  
/// also aplly to mul *
define sum[A: Add](items: List[A]) -> A {
    match items {
        List.nil {
            A.0
        }
        List.cons(head, tail) {
            head + sum(tail)
        }
    }
}

/// Computes the partial sum of a series up to index n.
/// Returns the sum of f(0) + f(1) + ... + f(n-1).
define partial[A: Add](f: Nat -> A, n: Nat) -> A {
    sum(n.range.map(f))
}
// todo: rearrange invariant. ⩽ n! steps. n! is the number of all rearrange (bijective)

theorem sum_add[A: Add](left: List[A], right: List[A]) {
    sum(left + right) = sum(left) + sum(right)
} by {
    define p(x: List[A]) -> Bool {
        sum(x + right) = sum(x) + sum(right)
    }

    // Base case: sum(nil + right) = sum(nil) + sum(right)
    sum(List.nil[A] + right) = sum(right)
    sum(List.nil[A]) = A.0
    A.0 + sum(right) = sum(right)
    p(List.nil)

    // Inductive step
    forall(head: A, tail: List[A]) {
        if p(tail) {
            // Induction hypothesis: sum(tail + right) = sum(tail) + sum(right)

            // Left side: sum(List.cons(head, tail) + right)
            // use def of add 
            //     List.cons(head, tail) + right = List.cons(head, tail + right)
            sum(List.cons(head, tail) + right) = sum(List.cons(head, tail + right))

            sum(List.cons(head, tail + right)) = head + sum(tail + right)

            // Use induction hypothesis
            head + sum(tail + right) = head + (sum(tail) + sum(right))

            // Right side: sum(List.cons(head, tail)) + sum(right)
            sum(List.cons(head, tail)) = head + sum(tail)

            sum(List.cons(head, tail)) + sum(right) = (head + sum(tail)) + sum(right)

            // Use associativity
            (head + sum(tail)) + sum(right) = head + (sum(tail) + sum(right))

            // Therefore
            sum(List.cons(head, tail) + right) = sum(List.cons(head, tail)) + sum(right)
            p(List.cons(head, tail))
        }
    }
}

theorem sum_append[A: Add](initial: List[A], last: A) {
    sum(initial.append(last)) = sum(initial) + last
}

theorem add_assoc[T](a: List[T], b: List[T], c: List[T]) {
    (a + b) + c = a + (b + c)
} by {
    define p(x: List[T]) -> Bool {
        (x + b) + c = x + (b + c)
    }

    // Base case: (nil + b) + c = nil + (b + c)
    (List.nil[T] + b) + c = b + c
    List.nil[T] + (b + c) = b + c
    p(List.nil)

    // Inductive step
    forall(head: T, tail: List[T]) {
        if p(tail) {
            // Induction hypothesis: (tail + b) + c = tail + (b + c)

            // Left side: (List.cons(head, tail) + b) + c
            (List.cons(head, tail) + b) + c = List.cons(head, tail + b) + c
            List.cons(head, tail + b) + c = List.cons(head, (tail + b) + c)

            // Use induction hypothesis
            List.cons(head, (tail + b) + c) = List.cons(head, tail + (b + c))

            // Right side: List.cons(head, tail) + (b + c)
            List.cons(head, tail) + (b + c) = List.cons(head, tail + (b + c))

            // Therefore
            (List.cons(head, tail) + b) + c = List.cons(head, tail) + (b + c)
            p(List.cons(head, tail))
        }
    }
}

attributes List[T] {
    /// Yields the list without its first element.
    /// Yields nil for an empty list.
    define tail(self) -> List[T] {
        match self {
            List.nil {
                List.nil[T]
            }
            List.cons(h, t) {
                t
            }
        }
    }

    /// Removes the first n elements from the list.
    define drop(self, n: Nat) -> List[T] {
        match n {
            0 {
                self
            }
            Nat.suc(pred) {
                self.tail.drop(pred)
            }
            // drop (forward) n
        }
    }
}

theorem tail_cancels_cons[T](a: T, b: List[T]) {
    List.cons(a, b).tail = b
}

theorem drop_zero[T](a: List[T]) {
    a.drop(0) = a
}

theorem drop_one[T](a: List[T]) {
    a.drop(1) = a.tail
}

theorem drop_cancels_add[T](a: List[T], b: List[T]) {
    (a + b).drop(a.length) = b
} by {
    define p(x: List[T]) -> Bool {
        (x + b).drop(x.length) = b
    }

    // Base case
    (List.nil[T] + b).drop(List.nil[T].length) = b.drop(0)
    b.drop(0) = b
    p(List.nil)

    // Inductive step
    forall(head: T, tail: List[T]) {
        if p(tail) {
            // Induction hypothesis: (tail + b).drop(tail.length) = b

            // Left side
            (List.cons(head, tail) + b).drop(List.cons(head, tail).length) = (List.cons(head, tail + b)).drop(tail.length.suc)

            (List.cons(head, tail + b)).drop(tail.length.suc) = (tail + b).drop(tail.length)

            // Use induction hypothesis
            (tail + b).drop(tail.length) = b

            // Therefore
            p(List.cons(head, tail))
        }
    }
}

theorem drop_twice[T](a: List[T], m: Nat, n: Nat) {
    a.drop(m).drop(n) = a.drop(m + n)
} by {
    define f(x: Nat) -> Bool {
        forall(l: List[T], k: Nat) {
            l.drop(x).drop(k) = l.drop(x + k)
        }
    }

    Nat.induction(f)

    forall(l: List[T], k: Nat) {
        l.drop(0) = l
        drop_zero(l)
        l.drop(0).drop(k) = l.drop(k)
        0 + k = k
        l.drop(0 + k) = l.drop(k)
    }
    f(0)

    forall(x: Nat) {
        if f(x) {
            forall(l: List[T], k: Nat) {
                // Induction hypothesis: l.drop(x).drop(k) = l.drop(x + k)
                l.drop(x + 1).drop(k) = l.tail.drop(x).drop(k)
                f(x)
                l.tail.drop(x).drop(k) = l.tail.drop(x + k)
                x + 1 + k = (x + k).suc
                l.drop(x + 1 + k) = l.drop((x + k).suc)
                l.drop((x + k).suc) = l.tail.drop(x + k)
                l.drop(x + 1).drop(k) = l.drop(x + 1 + k)
            }
            f(x + 1)
        }
    }

    f(m)
}

attributes List[T] {
    /// Removes the last n elements from the list.
    define drop_last(self, n: Nat) -> List[T] {
        match self {
            List.nil {
                List.nil[T]
            }
            List.cons(head, tail) {
                if tail.length < n {
                    List.nil[T]
                } else {
                    List.cons(head, tail.drop_last(n))
                }
                // cons, until the length of tail < n, then stop cons
            }
        }
    }
}


theorem drop_last_zero[T](a: List[T]) {
    a.drop_last(0) = a
} by {
    define q(x: List[T]) -> Bool {
        x.drop_last(0) = x
    }
    q(List.nil)
    forall(head: T, tail: List[T]) {
        if q(tail) {
            List.cons(head, tail).drop_last(0) = List.cons(head, tail.drop_last(0))
            List.cons(head, tail.drop_last(0)) = List.cons(head, tail)
            q(List.cons(head, tail))
        }
    }
    q(a)
}

theorem drop_last_all[T](l: List[T]) {
    l.drop_last(l.length) = List.nil[T]
} by {
    define r(x: List[T]) -> Bool {
        x.drop_last(x.length) = List.nil[T]
    }
    r(List.nil)
    forall(head: T, tail: List[T]) {
        if r(tail) {
            List.cons(head, tail).drop_last(List.cons(head, tail).length) = List.cons(head, tail).drop_last(tail.length.suc)
            List.cons(head, tail).drop_last(tail.length.suc) = List.nil[T]
            r(List.cons(head, tail))
        }
    }
    r(l)
}

theorem drop_last_cancels_add[T](a: List[T], b: List[T]) {
    (a + b).drop_last(b.length) = a
} by {
    define p(x: List[T]) -> Bool {
        (x + b).drop_last(b.length) = x
    }
    drop_last_all(b)
    p(List.nil)
    forall(head: T, tail: List[T]) {
        if p(tail) {
            add_length(tail, b)
            let (c: Nat) satisfy { b.length + c = (tail + b).length }
            c = tail.length
            b.length <= (tail + b).length
            (List.cons(head, tail) + b).drop_last(b.length) = List.cons(head, tail + b).drop_last(b.length)
            List.cons(head, tail + b).drop_last(b.length) = List.cons(head, (tail + b).drop_last(b.length))
            p(tail)
            List.cons(head, (tail + b).drop_last(b.length)) = List.cons(head, tail)
            p(List.cons(head, tail))
        }
    }
    p(a)
}

attributes Nat {
    /// Creates a list of natural numbers from self to n-1 (exclusive of n).
    define until(self, n: Nat) -> List[Nat] {
        n.range.drop(self)
    }

    /// Creates a list of natural numbers from self to n (inclusive).
    define upto(self, n: Nat) -> List[Nat] {
        self.until(n.suc)
    }
}

theorem zero_until(n: Nat) {
    0.until(n) = n.range
} by {
    drop_zero(n.range)
}

theorem until_self(n: Nat) {
    n.until(n) = List.nil[Nat]
} by {
    n.range.length = n
    drop_cancels_add(n.range, List.nil[Nat])
}

theorem until_suc(n: Nat) {
    n.until(n.suc) = List.singleton(n)
} by {
    n.suc.range = n.range + List.singleton(n)
    n.range.length = n
    drop_cancels_add(n.range, List.singleton(n))
}

theorem zero_upto(n: Nat) {
    0.upto(n) = n.suc.range
}

theorem upto_self(n: Nat) {
    n.upto(n) = List.singleton(n)
}

theorem range_add_until(a: Nat, b: Nat) {
    a <= b implies a.range + a.until(b) = b.range
} by {
    let (k: Nat) satisfy { a + k = b }

    define f(x: Nat) -> Bool {
        a.range + a.until(a + x) = (a + x).range
    }

    // Base case: x = 0
    until_self(a)
    add_nil(a.range)
    f(0)

    // Inductive step
    forall(x: Nat) {
        if f(x) {
            // Show a.until(a + x.suc) = a.until(a + x) + List.singleton(a + x)
            a.until(a + x.suc) = (a + x.suc).range.drop(a)
            (a + x.suc).range = (a + x).range + List.singleton(a + x)
            a.until(a + x.suc) = ((a + x).range + List.singleton(a + x)).drop(a)
            f(x)
            (a + x).range = a.range + a.until(a + x)
            a.until(a + x.suc) = (a.range + a.until(a + x) + List.singleton(a + x)).drop(a)
            a.range.length = a
            drop_cancels_add(a.range, a.until(a + x) + List.singleton(a + x))
            a.until(a + x.suc) = a.until(a + x) + List.singleton(a + x)

            // Now show f(x.suc)
            a.range + a.until(a + x.suc) = a.range + (a.until(a + x) + List.singleton(a + x))
            add_assoc(a.range, a.until(a + x), List.singleton(a + x))
            (a.range + a.until(a + x)) + List.singleton(a + x) = (a + x).range + List.singleton(a + x)
            f(x)
            (a + x).range + List.singleton(a + x) = (a + x).suc.range
            f(x.suc)
        }
    }

    f(k)
    a + k = b
}

theorem length_zero_imp_nil[T](list: List[T]) {
    list.length = Nat.0 implies list = List.nil[T]
}

theorem add_to_nil[T](a: List[T], b: List[T]) {
    a + b = List.nil[T] implies a = List.nil[T] and b = List.nil[T]
}

theorem append_not_nil[T](a: List[T], t: T) {
    a.append(t) != List.nil[T]
}

define max_list(list: List[Nat]) -> Nat {
    match list {
        List[Nat].nil {
            0
        }
        List.cons(head, tail) {
            head.max(max_list(tail))
        }
    }
}

from order import max_imp_gte

theorem list_has_max(list: List[Nat]) {
    forall(a: Nat) {
        list.contains(a) implies a <= max_list(list)
    }
} by {
    define f(l: List[Nat]) -> Bool {
        forall(k: Nat) {
            l.contains(k) implies k <= max_list(l)
        }
    }

    forall(head: Nat, tail: List[Nat]) {
        if f(tail) {
            let k = max_list(tail)
            let m: Nat = head.max(k)
            m >= max_list(List.cons(head, tail))
            max_imp_gte(head, k)
            m >= max_list(tail)
            forall(x: Nat) {
                head = x implies x <= m
                tail.contains(x) implies x <= m

                List.cons(head, tail).contains(x) implies x <= m
            }

            f(List.cons(head, tail))
        }
    }

    f(list)
}

theorem no_list_contains_nat(list: List[Nat]) {
    exists(n: Nat) {
        not list.contains(n)
    } // max_list + 1
}

from option import Option

attributes List[T] {
    define find_first_idx(self, item: T) -> Nat {
        match self {
            List.nil{
                Nat.0
            }
            List.cons(head, tail) {
                if head = item {
                    Nat.0
                } else {
                    1 + tail.find_first_idx(item)
                }
            }
        }
    }

    define get(self, i: Nat) -> Option[T] {
        match self {
            List.nil {
                Option.none
            }
            List.cons(head, tail) {
                if i > 0 {
                    tail.get(i - 1)
                } else {
                    Option.some(head)
                }
            }
        }
    }
}