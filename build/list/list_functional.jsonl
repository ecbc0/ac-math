{"goal":"reverse[T](List.nil[T] + list_2) = reverse[T](list_2)","proof":["List.nil[T] + list_2 != list_2","List.nil[T] != List.nil[T] or List.nil[T] + list_2 = list_2"]}
{"goal":"reverse[T](list_2) + reverse[T](List.nil[T]) = reverse[T](list_2)","proof":["List.nil[T] != List.nil[T] or reverse[T](List.nil[T]) = List.nil[T]","reverse[T](list_2) + List.nil[T] = reverse[T](list_2)","reverse[T](List.nil[T]) = List.nil[T]"]}
{"goal":"p(List.nil[T])","proof":["reverse[T](list_2) + reverse[T](List.nil[T]) != reverse[T](List.nil[T] + list_2) or p(List.nil[T])","reverse[T](list_2) + reverse[T](List.nil[T]) = reverse[T](List.nil[T] + list_2)","reverse[T](list_2) + reverse[T](List.nil[T]) != reverse[T](List.nil[T] + list_2)"]}
{"goal":"reverse[T](List.cons(head, tail) + list_2) = reverse[T](List.cons(head, tail + list_2))","proof":["List.cons(head, tail) + list_2 != List.cons(head, tail + list_2)","List.cons(head, tail) != List.cons(head, tail) or List.cons(head, tail) + list_2 = List.cons(head, tail + list_2)"]}
{"goal":"reverse[T](List.cons(head, tail + list_2)) = reverse[T](tail + list_2).append(head)","proof":["List.cons(head, tail + list_2) != List.cons(head, tail + list_2) or reverse[T](tail + list_2).append(head) = reverse[T](List.cons(head, tail + list_2))"]}
{"goal":"reverse[T](tail + list_2).append(head) = reverse[T](tail + list_2) + List.singleton(head)","proof":["reverse[T](tail + list_2) + List.singleton(head) = reverse[T](tail + list_2).append(head)"]}
{"goal":"reverse[T](tail + list_2) + List.singleton(head) = reverse[T](list_2) + reverse[T](tail) + List.singleton(head)","proof":["not p(tail) or reverse[T](list_2) + reverse[T](tail) = reverse[T](tail + list_2)","reverse[T](list_2) + reverse[T](tail) != reverse[T](tail + list_2)","reverse[T](list_2) + reverse[T](tail) = reverse[T](tail + list_2)"]}
{"goal":"reverse[T](list_2) + reverse[T](tail) + List.singleton(head) = reverse[T](list_2) + (reverse[T](tail) + List.singleton(head))","proof":["reverse[T](list_2) + (reverse[T](tail) + List.singleton(head)) = reverse[T](list_2) + reverse[T](tail) + List.singleton(head)"]}
{"goal":"reverse[T](list_2) + (reverse[T](tail) + List.singleton(head)) = reverse[T](list_2) + reverse[T](tail).append(head)","proof":["reverse[T](tail) + List.singleton(head) != reverse[T](tail).append(head)","reverse[T](tail) + List.singleton(head) = reverse[T](tail).append(head)"]}
{"goal":"reverse[T](list_2) + reverse[T](tail).append(head) = reverse[T](list_2) + reverse[T](List.cons(head, tail))","proof":["reverse[T](tail).append(head) != reverse[T](List.cons(head, tail))","List.cons(head, tail) != List.cons(head, tail) or reverse[T](tail).append(head) = reverse[T](List.cons(head, tail))"]}
{"goal":"reverse[T](List.cons(head, tail) + list_2) = reverse[T](list_2) + reverse[T](List.cons(head, tail))","proof":[]}
{"goal":"p(List.cons(head, tail))","proof":["reverse[T](list_2) + reverse[T](List.cons(head, tail)) != reverse[T](List.cons(head, tail) + list_2) or p(List.cons(head, tail))","reverse[T](list_2) + reverse[T](List.cons(head, tail)) != reverse[T](List.cons(head, tail) + list_2)"]}
{"goal":"p(list_1)","proof":["let (s0: (List[T] -> Bool) -> T, s1: (List[T] -> Bool) -> List[T]) satisfy { forall(x0: List[T] -> Bool, x1: List[T]) { not x0(List.nil[T]) or x0(s1(x0)) or x0(x1) } and forall(x2: List[T] -> Bool, x3: List[T]) { not x2(List.cons(s0(x2), s1(x2))) or not x2(List.nil[T]) or x2(x3) } }","not p(s1(p)) or p(List.cons(s0(p), s1(p)))","not p(List.cons(s0(p), s1(p))) or not p(List.nil[T]) or p(list_1)","not p(List.nil[T]) or p(s1(p)) or p(list_1)","p(s1(p))","not p(List.cons(s0(p), s1(p)))"]}
{"goal":"reverse_add","proof":["not p(list_1) or reverse[T](list_2) + reverse[T](list_1) = reverse[T](list_1 + list_2)"]}
{"goal":"p(List.nil[T])","proof":["reverse[T](reverse[T](List.nil[T])) != List.nil[T] or p(List.nil[T])","reverse[T](reverse[T](List.nil[T])) != List.nil[T]","List.nil[T] != List.nil[T] or reverse[T](List.nil[T]) = List.nil[T]","reverse[T](List.nil[T]) != List.nil[T] or reverse[T](reverse[T](List.nil[T])) = List.nil[T]","reverse[T](List.nil[T]) = List.nil[T]","reverse[T](List.nil[T]) != List.nil[T]"]}
{"goal":"reverse[T](reverse[T](List.cons(head, tail))) = reverse[T](reverse[T](tail).append(head))","proof":["reverse[T](tail).append(head) != reverse[T](List.cons(head, tail))","List.cons(head, tail) != List.cons(head, tail) or reverse[T](tail).append(head) = reverse[T](List.cons(head, tail))"]}
{"goal":"reverse[T](reverse[T](tail).append(head)) = reverse[T](reverse[T](tail) + List.singleton(head))","proof":["reverse[T](tail) + List.singleton(head) != reverse[T](tail).append(head)","reverse[T](tail) + List.singleton(head) = reverse[T](tail).append(head)"]}
{"goal":"reverse[T](reverse[T](tail) + List.singleton(head)) = reverse[T](List.singleton(head)) + reverse[T](reverse[T](tail))","proof":["reverse[T](List.singleton(head)) + reverse[T](reverse[T](tail)) = reverse[T](reverse[T](tail) + List.singleton(head))"]}
{"goal":"reverse[T](List.singleton(head)) = List.singleton(head)","proof":["List.cons(head, List.nil[T]) != List.cons(head, List.nil[T]) or reverse[T](List.nil[T]).append(head) = reverse[T](List.cons(head, List.nil[T]))","List.nil[T] + List.singleton(head) = List.nil[T].append(head)","List.nil[T] != List.nil[T] or reverse[T](List.nil[T]) = List.nil[T]","List.cons(head, List.nil[T]) = List.singleton(head)","List.nil[T] + List.cons(head, List.nil[T]) = List.cons(head, List.nil[T])","reverse[T](List.nil[T]) = List.nil[T]","reverse[T](List.nil[T]).append(head) = reverse[T](List.cons(head, List.nil[T]))"]}
{"goal":"reverse[T](List.singleton(head)) + reverse[T](reverse[T](tail)) = List.singleton(head) + tail","proof":["not p(tail) or reverse[T](reverse[T](tail)) = tail","List.singleton(head) + reverse[T](reverse[T](tail)) != List.singleton(head) + tail","reverse[T](reverse[T](tail)) = tail","reverse[T](reverse[T](tail)) != tail"]}
{"goal":"List.singleton(head) + tail = List.cons(head, tail)","proof":["List.cons(head, List.nil[T]) != List.singleton(head) or List.cons(head, List.nil[T] + tail) = List.singleton(head) + tail","List.cons(head, List.nil[T]) = List.singleton(head)","List.nil[T] + tail = tail","List.cons(head, List.nil[T] + tail) != List.singleton(head) + tail"]}
{"goal":"reverse[T](reverse[T](List.cons(head, tail))) = List.cons(head, tail)","proof":[]}
{"goal":"p(List.cons(head, tail))","proof":["reverse[T](reverse[T](List.cons(head, tail))) != List.cons(head, tail) or p(List.cons(head, tail))","reverse[T](reverse[T](List.cons(head, tail))) != List.cons(head, tail)"]}
{"goal":"p(list)","proof":["let (s0: (List[T] -> Bool) -> T, s1: (List[T] -> Bool) -> List[T]) satisfy { forall(x0: List[T] -> Bool, x1: List[T]) { not x0(List.nil[T]) or x0(s1(x0)) or x0(x1) } and forall(x2: List[T] -> Bool, x3: List[T]) { not x2(List.cons(s0(x2), s1(x2))) or not x2(List.nil[T]) or x2(x3) } }","not p(s1(p)) or p(List.cons(s0(p), s1(p)))","not p(List.cons(s0(p), s1(p))) or not p(List.nil[T]) or p(list)","not p(List.nil[T]) or p(s1(p)) or p(list)","p(s1(p))","not p(List.cons(s0(p), s1(p)))"]}
{"goal":"reverse_involution","proof":["not p(list) or reverse[T](reverse[T](list)) = list"]}
{"goal":"f(List.nil[T])","proof":["reverse[T](List.nil[T]).is_permutation(List.nil[T]) = f(List.nil[T])","not reverse[T](List.nil[T]).is_permutation(List.nil[T])","List.nil[T] != List.nil[T] or reverse[T](List.nil[T]) = List.nil[T]","List.nil[T].is_permutation(List.nil[T])","reverse[T](List.nil[T]) = List.nil[T]"]}
{"goal":"reverse[T](List.cons(head, tail)) = reverse[T](tail).append(head)","proof":["List.cons(head, tail) != List.cons(head, tail) or reverse[T](tail).append(head) = reverse[T](List.cons(head, tail))"]}
{"goal":"reverse[T](List.cons(head, tail)) = reverse[T](tail) + List.singleton(head)","proof":["reverse[T](tail) + List.singleton(head) = reverse[T](tail).append(head)"]}
{"goal":"(reverse[T](tail) + List.singleton(head)).count(item) = reverse[T](tail).count(item) + List.singleton(head).count(item)","proof":["reverse[T](tail).count(item) + List.singleton(head).count(item) = (reverse[T](tail) + List.singleton(head)).count(item)"]}
{"goal":"List.cons(head, tail).count(item) = List.singleton(head).count(item) + tail.count(item)","proof":["List.cons(head, List.nil[T]) != List.cons(head, List.nil[T]) or List.cons(head, List.nil[T]) + tail = List.cons(head, List.nil[T] + tail)","List.singleton(head).count(item) + tail.count(item) = (List.singleton(head) + tail).count(item)","(List.singleton(head) + tail).count(item) != List.cons(head, tail).count(item)","List.singleton(head) + tail != List.cons(head, tail)","List.cons(head, List.nil[T]) = List.singleton(head)","List.nil[T] + tail = tail","List.cons(head, List.nil[T]) + tail = List.cons(head, List.nil[T] + tail)"]}
{"goal":"reverse[T](tail).is_permutation(tail)","proof":["reverse[T](tail).is_permutation(tail) = f(tail)"]}
{"goal":"reverse[T](tail).count(item) = tail.count(item)","proof":["not reverse[T](tail).is_permutation(tail) or reverse[T](tail).count(item) = tail.count(item)"]}
{"goal":"reverse[T](List.cons(head, tail)).count(item) = List.cons(head, tail).count(item)","proof":["List.singleton(head).count(item) + tail.count(item) = tail.count(item) + List.singleton(head).count(item)"]}
{"goal":"f(List.cons(head, tail))","proof":["reverse[T](List.cons(head, tail)).is_permutation(List.cons(head, tail)) = f(List.cons(head, tail))","let s0: (List[T], List[T]) -> T satisfy { forall(x0: List[T], x1: List[T], x2: T) { not x0.is_permutation(x1) or x0.count(x2) = x1.count(x2) } and forall(x3: List[T], x4: List[T]) { x3.count(s0(x3, x4)) != x4.count(s0(x3, x4)) or x3.is_permutation(x4) } }","reverse[T](List.cons(head, tail)).count(s0(reverse[T](List.cons(head, tail)), List.cons(head, tail))) = List.cons(head, tail).count(s0(reverse[T](List.cons(head, tail)), List.cons(head, tail)))","reverse[T](List.cons(head, tail)).count(s0(reverse[T](List.cons(head, tail)), List.cons(head, tail))) != List.cons(head, tail).count(s0(reverse[T](List.cons(head, tail)), List.cons(head, tail))) or reverse[T](List.cons(head, tail)).is_permutation(List.cons(head, tail))","not reverse[T](List.cons(head, tail)).is_permutation(List.cons(head, tail))","reverse[T](List.cons(head, tail)).is_permutation(List.cons(head, tail))"]}
{"goal":"f(list)","proof":["let (s0: (List[T] -> Bool) -> T, s1: (List[T] -> Bool) -> List[T]) satisfy { forall(x0: List[T] -> Bool, x1: List[T]) { not x0(List.nil[T]) or x0(s1(x0)) or x0(x1) } and forall(x2: List[T] -> Bool, x3: List[T]) { not x2(List.cons(s0(x2), s1(x2))) or not x2(List.nil[T]) or x2(x3) } }","not f(s1(f)) or f(List.cons(s0(f), s1(f)))","not f(List.cons(s0(f), s1(f))) or not f(List.nil[T]) or f(list)","not f(List.nil[T]) or f(s1(f)) or f(list)","f(s1(f))","not f(List.cons(s0(f), s1(f)))"]}
{"goal":"reverse_is_permutation","proof":["reverse[T](list).is_permutation(list) = f(list)"]}
