{"goal":"exists(k0: Set[X]) { x ∈ k0 and k0 ∈ c and k0.is_open }","proof":["let s0: (Set[Set[X]], X) -> Set[X] satisfy { forall(x0: Set[Set[X]], x1: X) { not lib(set).elem_in_union_general(x0, x1) or s0(x0, x1) ∈ x0 } and forall(x2: Set[Set[X]], x3: X) { not lib(set).elem_in_union_general(x2, x3) or x3 ∈ s0(x2, x3) } and forall(x4: Set[X], x5: X, x6: Set[Set[X]]) { not x5 ∈ x4 or not x4 ∈ x6 or lib(set).elem_in_union_general(x6, x5) } }","not x ∈ s0(c, x) or not s0(c, x) ∈ c or not s0(c, x).is_open","not s0(c, x) ∈ c or s0(c, x).is_open","not lib(set).elem_in_union_general(c, x) or x ∈ s0(c, x)","not lib(set).elem_in_union_general(c, x) or s0(c, x) ∈ c","x ∈ Set.new[X](lib(set).elem_in_union_general[X](c)) = lib(set).elem_in_union_general(c, x)","Set.new[X](lib(set).elem_in_union_general[X](c)) = union[X](c)","x ∈ Set.new[X](lib(set).elem_in_union_general[X](c))","lib(set).elem_in_union_general(c, x)","s0(c, x) ∈ c","x ∈ s0(c, x)","s0(c, x).is_open","not s0(c, x).is_open"]}
{"goal":"net_limit_split_of_exterior_boundary","proof":["let s0: (Set[X], X) -> Set[X] satisfy { forall(x0: Set[X], x1: X) { not x1 ∈ x0.interior or s0(x0, x1) ∈ x1.net.sets } and forall(x2: Set[X], x3: X) { not x3 ∈ x2.interior or s0(x2, x3) ⊆ x2.interior } }","not s0(a.c, x) ∈ x.net.sets or not s0(a.c, x) ⊆ a.exterior","not x ∈ a.c.interior or s0(a.c, x) ∈ x.net.sets","not x ∈ a.c.interior or s0(a.c, x) ⊆ a.c.interior","a.c.interior = a.exterior","x ∈ a.c.interior","s0(a.c, x) ⊆ a.c.interior","s0(a.c, x) ∈ x.net.sets","s0(a.c, x) ⊆ a.exterior","not s0(a.c, x) ⊆ a.exterior"]}
{"goal":"a ∩ b = (a ∩ b).interior","proof":["not (a ∩ b).interior ⊇ a ∩ b or not (a ∩ b).interior ⊆ a ∩ b or (a ∩ b).interior = a ∩ b","(a ∩ b).interior ⊇ a ∩ b = a ∩ b ⊆ (a ∩ b).interior","(a ∩ b).interior ⊆ a ∩ b","(a ∩ b).interior ⊇ a ∩ b","not (a ∩ b).interior ⊇ a ∩ b"]}
{"goal":"x ∈ a.interior","proof":["let s0: Set[X] satisfy { s0 ∈ x.net.sets and s0 ⊆ a.c.c }","not s0 ∈ x.net.sets or not s0 ⊆ a or elem_in_interior(a, x)","x ∈ Set.new[X](elem_in_interior[X](a)) = elem_in_interior(a, x)","Set.new[X](elem_in_interior[X](a)) = a.interior","not x ∈ Set.new[X](elem_in_interior[X](a))","not elem_in_interior(a, x)","a.c.c = a","s0 ⊆ a","not s0 ⊆ a or elem_in_interior(a, x)"]}
{"goal":"x ∈ a.interior","proof":["not x ∈ a"]}
{"goal":"x ∈ (a ∩ b).interior","proof":["let s0: Set[X] satisfy { s0 ∈ x.net.sets and s0 ⊆ sa ∩ sb }","not s0 ∈ x.net.sets or not s0 ⊆ a ∩ b or elem_in_interior(a ∩ b, x)","not lib(util).is_transitive[Set[X]](Set.subset_eq[X]) or not s0 ⊆ sa ∩ sb or not sa ∩ sb ⊆ a ∩ b or s0 ⊆ a ∩ b","x ∈ Set.new[X](elem_in_interior[X](a ∩ b)) = elem_in_interior(a ∩ b, x)","Set.new[X](elem_in_interior[X](a ∩ b)) = (a ∩ b).interior","not x ∈ Set.new[X](elem_in_interior[X](a ∩ b))","not elem_in_interior(a ∩ b, x)","not s0 ⊆ a ∩ b or elem_in_interior(a ∩ b, x)","not sa ∩ sb ⊆ a ∩ b or s0 ⊆ a ∩ b","not s0 ⊆ a ∩ b","s0 ⊆ a ∩ b"]}
{"goal":"closed_iff_compl_open","proof":["a ∪ a.c != universe[X] or a ∩ a.c != empty[X] or a.c.c = a","a.c.c.is_closed = a.c.is_open","a.c.c.is_closed != a.is_closed","a.c.c != a","a ∪ a.c = universe[X]","a ∩ a.c = empty[X]"]}
{"goal":"x ∈ a.c","proof":["not b ⊆ a.c or not x ∈ b or x ∈ a.c","not b ⊆ a.c or not x ∈ b"]}
{"goal":"x ∈ union[X](c).interior","proof":["not b ∈ x.net.sets or not b ⊆ union[X](c) or elem_in_interior(union[X](c), x)","x ∈ Set.new[X](elem_in_interior[X](union[X](c))) = elem_in_interior(union[X](c), x)","Set.new[X](elem_in_interior[X](union[X](c))) = union[X](c).interior","not x ∈ Set.new[X](elem_in_interior[X](union[X](c)))","not elem_in_interior(union[X](c), x)","not b ⊆ union[X](c) or elem_in_interior(union[X](c), x)"]}
{"goal":"continuous_imp_inv_image_closure_subset_closure_inv_image","proof":["not b.closure.inv_image(f).is_closed or not b.inv_image(f) ⊆ b.closure.inv_image(f) or b.inv_image(f).closure ⊆ b.closure.inv_image(f)"]}
{"goal":"exists(k0: Set[X]) { k0 ∈ x.net.sets and k0 ⊆ sa ∩ sb }","proof":["let (s0: (Set[Set[X]], Set[X], Set[X]) -> Set[X], s1: Set[Set[X]] -> Set[X], s2: Set[Set[X]] -> Set[X]) satisfy { forall(x0: Set[Set[X]], x1: Set[X], x2: Set[X]) { not subset_two_intersection[X](x0) or not x1 ∈ x0 or not x2 ∈ x0 or s0(x0, x1, x2) ∈ x0 } and forall(x3: Set[Set[X]], x4: Set[X], x5: Set[X]) { not subset_two_intersection[X](x3) or not x4 ∈ x3 or not x5 ∈ x3 or s0(x3, x4, x5) ⊆ x4 ∩ x5 } and forall(x6: Set[Set[X]]) { s1(x6) ∈ x6 or subset_two_intersection[X](x6) } and forall(x7: Set[Set[X]]) { s2(x7) ∈ x7 or subset_two_intersection[X](x7) } and forall(x8: Set[X], x9: Set[Set[X]]) { not x8 ⊆ s1(x9) ∩ s2(x9) or not x8 ∈ x9 or subset_two_intersection[X](x9) } }","not s0(x.net.sets, sa, sb) ∈ x.net.sets or not s0(x.net.sets, sa, sb) ⊆ sa ∩ sb","not subset_two_intersection[X](x.net.sets) or not sa ∈ x.net.sets or not sb ∈ x.net.sets or s0(x.net.sets, sa, sb) ⊆ sa ∩ sb","not subset_two_intersection[X](x.net.sets) or not sa ∈ x.net.sets or not sb ∈ x.net.sets or s0(x.net.sets, sa, sb) ∈ x.net.sets","not sa ∈ x.net.sets or s0(x.net.sets, sa, sb) ∈ x.net.sets","s0(x.net.sets, sa, sb) ∈ x.net.sets","not sa ∈ x.net.sets or s0(x.net.sets, sa, sb) ⊆ sa ∩ sb","not s0(x.net.sets, sa, sb) ⊆ sa ∩ sb","s0(x.net.sets, sa, sb) ⊆ sa ∩ sb"]}
{"goal":"exterior_subset","proof":["let s0: (Set[X], Set[X]) -> X satisfy { forall(x0: Set[X], x1: Set[X], x2: X) { not x0 ⊆ x1 or not x2 ∈ x0 or x2 ∈ x1 } and forall(x3: Set[X], x4: Set[X]) { s0(x3, x4) ∈ x3 or x3 ⊆ x4 } and forall(x5: Set[X], x6: Set[X]) { not s0(x6, x5) ∈ x5 or x6 ⊆ x5 } }","not s0(a.exterior, a.c) ∈ a.exterior or s0(a.exterior, a.c) ∈ a.c","not s0(a.exterior, a.c) ∈ a.c or a.exterior ⊆ a.c","s0(a.exterior, a.c) ∈ a.exterior or a.exterior ⊆ a.c","s0(a.exterior, a.c) ∈ a.exterior","not s0(a.exterior, a.c) ∈ a.c","s0(a.exterior, a.c) ∈ a.c"]}
{"goal":"two_intersection_preserve_open","proof":[]}
{"goal":"interior_is_compl_exterior","proof":["not a.c.exterior ⊇ a.interior or not a.c.exterior ⊆ a.interior or a.c.exterior = a.interior"]}
{"goal":"a.closure ⊆ a.exterior.c","proof":["let s0: (Set[X], Set[X]) -> X satisfy { forall(x0: Set[X], x1: Set[X], x2: X) { not x0 ⊆ x1 or not x2 ∈ x0 or x2 ∈ x1 } and forall(x3: Set[X], x4: Set[X]) { s0(x3, x4) ∈ x3 or x3 ⊆ x4 } and forall(x5: Set[X], x6: Set[X]) { not s0(x6, x5) ∈ x5 or x6 ⊆ x5 } }","not s0(a.closure, a.exterior.c) ∈ a.closure or s0(a.closure, a.exterior.c) ∈ a.exterior.c","not s0(a.closure, a.exterior.c) ∈ a.exterior.c or a.closure ⊆ a.exterior.c","s0(a.closure, a.exterior.c) ∈ a.closure or a.closure ⊆ a.exterior.c","s0(a.closure, a.exterior.c) ∈ a.closure","not s0(a.closure, a.exterior.c) ∈ a.exterior.c","s0(a.closure, a.exterior.c) ∈ a.exterior.c"]}
{"goal":"closure_is_not_exterior","proof":["let s0: (Set[X], Set[X]) -> X satisfy { forall(x0: Set[X], x1: Set[X], x2: X) { not x0 ⊇ x1 or not x2 ∈ x1 or x2 ∈ x0 } and forall(x3: Set[X], x4: Set[X]) { s0(x4, x3) ∈ x3 or x4 ⊇ x3 } and forall(x5: Set[X], x6: Set[X]) { not s0(x5, x6) ∈ x5 or x5 ⊇ x6 } }","not s0(a.closure, a.exterior.c) ∈ a.exterior.c or s0(a.closure, a.exterior.c) ∈ a.closure","not s0(a.closure, a.exterior.c) ∈ a.closure or a.closure ⊇ a.exterior.c","s0(a.closure, a.exterior.c) ∈ a.exterior.c or a.closure ⊇ a.exterior.c","not a.closure ⊇ a.exterior.c or not a.closure ⊆ a.exterior.c or a.exterior.c = a.closure","not a.closure ⊇ a.exterior.c","not s0(a.closure, a.exterior.c) ∈ a.closure","s0(a.closure, a.exterior.c) ∈ a.exterior.c","not s0(a.closure, a.exterior.c) ∈ a.exterior.c"]}
{"goal":"x ∈ a.c.boundary = x ∈ a.boundary","proof":["x ∈ a.c.boundary or x ∈ a.boundary","x ∈ a.boundary","x ∈ a.c.boundary","not x ∈ a.c.boundary"]}
{"goal":"universe[X] = a.boundary ∪ a.interior ∪ a.exterior","proof":["a.boundary ∪ (a.interior ∪ a.exterior) = a.boundary ∪ a.interior ∪ a.exterior"]}
{"goal":"empty_is_open","proof":["let s0: (Set[X], Set[X]) -> X satisfy { forall(x0: Set[X], x1: Set[X]) { not x0 ⊂ x1 or s0(x0, x1) ∈ x1 } and forall(x2: Set[X], x3: Set[X]) { not x2 ⊂ x3 or s0(x2, x3) ∉ x2 } }","not a.interior ⊂ a or s0(a.interior, a) ∈ a","not a.interior ⊆ a or a.interior ⊂ a or a.interior = a","not a.is_empty or not s0(a.interior, a) ∈ a","a.interior != a or a.is_open","a.interior != a","a.interior ⊆ a","not s0(a.interior, a) ∈ a","a.interior ⊂ a"]}
{"goal":"b ∈ x.net.sets implies a ∩ b != empty[X] and a.c ∩ b != empty[X]","proof":["a ∩ b = empty[X]","a.c.c = a"]}
{"goal":"b ∈ x.net.sets implies a ∩ b != empty[X] and a.c ∩ b != empty[X]","proof":["not b ∈ x.net.sets or a.c ∩ b != empty[X] or not elem_in_boundary(a, x)","not b ∈ x.net.sets or not elem_in_boundary(a, x) or a ∩ b != empty[X]","x ∈ Set.new[X](elem_in_boundary[X](a)) = elem_in_boundary(a, x)","Set.new[X](elem_in_boundary[X](a)) = a.boundary","x ∈ Set.new[X](elem_in_boundary[X](a))","elem_in_boundary(a, x)","not elem_in_boundary(a, x) or a ∩ b != empty[X]","a.c ∩ b != empty[X] or not elem_in_boundary(a, x)","a ∩ b != empty[X]","a.c ∩ b != empty[X]","a.c ∩ b = empty[X]"]}
{"goal":"(a ∩ b).is_open","proof":["(a ∩ b).interior != a ∩ b or (a ∩ b).is_open"]}
{"goal":"continuous_imp_inv_image_preserve_open","proof":["let s0: Set[Y] satisfy { s0.is_open and not s0.inv_image(f).is_open }","not s0.is_open or s0.inv_image(f).is_open"]}
{"goal":"exterior_is_open","proof":["a.c.interior = a.exterior","not a.c.interior.is_open","a.c.interior.is_open"]}
{"goal":"x ∈ a.interior.c","proof":["not x ∈ a.interior.c ∩ a.exterior.c or x ∈ a.interior.c"]}
{"goal":"x ∈ a.closure","proof":["let s0: (Set[X], X) -> Set[X] satisfy { forall(x0: X, x1: Set[X], x2: Set[X]) { not x1 ∈ x0.net.sets or not limit_pt(x2, x0) or x2 ∩ x1 != empty[X] } and forall(x3: X, x4: Set[X]) { s0(x4, x3) ∈ x3.net.sets or limit_pt(x4, x3) } and forall(x5: Set[X], x6: X) { x5 ∩ s0(x5, x6) = empty[X] or limit_pt(x5, x6) } }","not s0(a, x) ∈ x.net.sets or a ∩ s0(a, x) != empty[X]","s0(a, x) ∈ x.net.sets or limit_pt(a, x)","a ∩ s0(a, x) = empty[X] or limit_pt(a, x)","x ∈ Set.new[X](limit_pt[X](a)) = limit_pt(a, x)","Set.new[X](limit_pt[X](a)) = a.closure","not x ∈ Set.new[X](limit_pt[X](a))","not limit_pt(a, x)","a ∩ s0(a, x) = empty[X]","s0(a, x) ∈ x.net.sets","not s0(a, x) ∈ x.net.sets"]}
{"goal":"(a.boundary ∪ a.interior) ∩ a.exterior = empty[X]","proof":["a.interior ∩ a.exterior ∪ a.boundary ∩ a.exterior = (a.interior ∪ a.boundary) ∩ a.exterior","a.interior ∪ a.boundary = a.boundary ∪ a.interior","a.interior ∩ a.exterior = empty[X]","a.interior ∩ a.exterior ∪ empty[X] = a.interior ∩ a.exterior"]}
{"goal":"a.closure.contains(x) = a.closure.closure.contains(x)","proof":["not x ∈ a.closure.closure"]}
{"goal":"a.closure.contains(x) = a.closure.closure.contains(x)","proof":["x ∈ a.closure.closure","x ∉ a.closure.closure != x ∈ a.closure.closure","not x ∉ a.closure.closure or not x ∈ a.closure.closure"]}
{"goal":"interior_preserve_subset","proof":["let s0: (Set[X], Set[X]) -> X satisfy { forall(x0: Set[X], x1: Set[X], x2: X) { not x0 ⊆ x1 or not x2 ∈ x0 or x2 ∈ x1 } and forall(x3: Set[X], x4: Set[X]) { s0(x3, x4) ∈ x3 or x3 ⊆ x4 } and forall(x5: Set[X], x6: Set[X]) { not s0(x6, x5) ∈ x5 or x6 ⊆ x5 } }","not s0(a.interior, b.interior) ∈ a.interior or s0(a.interior, b.interior) ∈ b.interior","not s0(a.interior, b.interior) ∈ b.interior or a.interior ⊆ b.interior","s0(a.interior, b.interior) ∈ a.interior or a.interior ⊆ b.interior","s0(a.interior, b.interior) ∈ a.interior","not s0(a.interior, b.interior) ∈ b.interior","s0(a.interior, b.interior) ∈ b.interior"]}
{"goal":"interior_is_largest_open_subset","proof":["not b ⊆ a or b.interior ⊆ a.interior","not b.is_open or b.interior = b","b.interior = b","b.interior ⊆ a.interior","not b.interior ⊆ a.interior"]}
{"goal":"b ∈ x.net.sets implies a.c ∩ b != empty[X] and a.c.c ∩ b != empty[X]","proof":["not b ∈ x.net.sets or a.c.c ∩ b != empty[X] or not elem_in_boundary(a.c, x)","not b ∈ x.net.sets or not elem_in_boundary(a.c, x) or a.c ∩ b != empty[X]","x ∈ Set.new[X](elem_in_boundary[X](a.c)) = elem_in_boundary(a.c, x)","Set.new[X](elem_in_boundary[X](a.c)) = a.c.boundary","x ∈ Set.new[X](elem_in_boundary[X](a.c))","elem_in_boundary(a.c, x)","not elem_in_boundary(a.c, x) or a.c ∩ b != empty[X]","a.c.c ∩ b != empty[X] or not elem_in_boundary(a.c, x)","a.c ∩ b != empty[X]","a.c.c ∩ b != empty[X]","a.c.c ∩ b = empty[X]"]}
{"goal":"b ∈ x.net.sets implies a.c ∩ b != empty[X] and a.c.c ∩ b != empty[X]","proof":["a.c.c ∩ b = empty[X]","a.c.c = a"]}
{"goal":"union[X](c) ⊆ union[X](c).interior","proof":["let s0: (Set[X], Set[X]) -> X satisfy { forall(x0: Set[X], x1: X, x2: Set[X]) { not x1 ∈ x0 or not x0 ⊆ x2 or x1 ∈ x2 } and forall(x3: Set[X], x4: Set[X]) { s0(x3, x4) ∈ x3 or x3 ⊆ x4 } and forall(x5: Set[X], x6: Set[X]) { not s0(x6, x5) ∈ x5 or x6 ⊆ x5 } }","not s0(union[X](c), union[X](c).interior) ∈ union[X](c) or s0(union[X](c), union[X](c).interior) ∈ union[X](c).interior","not s0(union[X](c), union[X](c).interior) ∈ union[X](c).interior or union[X](c) ⊆ union[X](c).interior","s0(union[X](c), union[X](c).interior) ∈ union[X](c) or union[X](c) ⊆ union[X](c).interior","s0(union[X](c), union[X](c).interior) ∈ union[X](c)","not s0(union[X](c), union[X](c).interior) ∈ union[X](c).interior","s0(union[X](c), union[X](c).interior) ∈ union[X](c).interior"]}
{"goal":"not b ⊆ a.c","proof":["not b ∈ x.net.sets or not b ⊆ a.c or elem_in_exterior(a, x)","x ∈ Set.new[X](elem_in_exterior[X](a)) = elem_in_exterior(a, x)","Set.new[X](elem_in_exterior[X](a)) = a.exterior","not b ∈ x.net.sets or elem_in_exterior(a, x)","elem_in_exterior(a, x)","not elem_in_exterior(a, x) or x ∈ Set.new[X](elem_in_exterior[X](a))","not x ∈ Set.new[X](elem_in_exterior[X](a))"]}
{"goal":"not x ∈ a.interior","proof":["x ∈ a.interior.c.c = x ∉ a.interior.c","x ∉ a.interior.c != x ∈ a.interior.c","a.interior.c.c = a.interior","x ∈ a.interior.c.c","x ∉ a.interior.c","not x ∉ a.interior.c or not x ∈ a.interior.c"]}
{"goal":"x ∈ a implies x ∈ a.closure","proof":["x ∈ Set.new[X](limit_pt[X](a)) = limit_pt(a, x)","Set.new[X](limit_pt[X](a)) = a.closure","not x ∈ Set.new[X](limit_pt[X](a))"]}
{"goal":"open_cover(x).image(f) ⊆ v","proof":["f(x) ∈ v or open_cover(x) = empty[X]","not f(x) ∈ v or open_cover(x).image(f) ⊆ v","not f(x) ∈ v","let s0: (Set[X], X -> Y, Set[Y]) -> X satisfy { forall(x0: Set[X], x1: X -> Y, x2: Set[Y]) { x0.image(x1) ⊆ x2 or s0(x0, x1, x2) ∈ x0 } and forall(x3: Set[Y], x4: X -> Y, x5: Set[X]) { not x4(s0(x5, x4, x3)) ∈ x3 or x5.image(x4) ⊆ x3 } }","open_cover(x).image(f) ⊆ v or s0(open_cover(x), f, v) ∈ open_cover(x)","not open_cover(x).is_empty or not s0(open_cover(x), f, v) ∈ open_cover(x)","open_cover(x) != empty[X] or open_cover(x).is_empty","s0(open_cover(x), f, v) ∈ open_cover(x)","not open_cover(x).is_empty","open_cover(x) = empty[X]","open_cover(x) != empty[X]"]}
{"goal":"closed_imp_compl_open","proof":["not a.is_closed or a.closure = a","a.exterior.c = a.closure","a.c.interior != a.c or a.c.is_open","a.c.interior != a.c","a.c.interior = a.exterior","a.c.interior.c.c = a.c.interior","a.closure = a"]}
{"goal":"b ∈ x.net.sets implies a ∩ b != empty[X]","proof":["b ∩ a.c.c != empty[X] or b ⊆ a.c","b ∩ a = a ∩ b","b ∩ a = empty[X]","a.c.c = a","b ∩ a.c.c != empty[X]","b ∩ a.c.c = empty[X]"]}
{"goal":"x ∈ open_cover(x)","proof":["not f(x) ∈ v or x ∈ open_cover(x)"]}
{"goal":"b.inv_image(f) ⊆ b.closure.inv_image(f)","proof":["not lib(util).is_transitive[Set[Y]](Set.subset_eq[Y]) or not b.inv_image(f).image(f) ⊆ b or not b ⊆ b.closure or b.inv_image(f).image(f) ⊆ b.closure","b.inv_image(f) ⊆ b.closure.inv_image(f) = b.inv_image(f).image(f) ⊆ b.closure","not b.inv_image(f).image(f) ⊆ b.closure","b.inv_image(f).image(f) ⊆ b","not b.inv_image(f).image(f) ⊆ b or b.inv_image(f).image(f) ⊆ b.closure"]}
{"goal":"x ∈ b.closure","proof":["let s0: (Set[X], X) -> Set[X] satisfy { forall(x0: X, x1: Set[X], x2: Set[X]) { not x1 ∈ x0.net.sets or not limit_pt(x2, x0) or x2 ∩ x1 != empty[X] } and forall(x3: X, x4: Set[X]) { s0(x4, x3) ∈ x3.net.sets or limit_pt(x4, x3) } and forall(x5: Set[X], x6: X) { x5 ∩ s0(x5, x6) = empty[X] or limit_pt(x5, x6) } }","not s0(b, x) ∈ x.net.sets or b ∩ s0(b, x) != empty[X]","s0(b, x) ∈ x.net.sets or limit_pt(b, x)","b ∩ s0(b, x) = empty[X] or limit_pt(b, x)","x ∈ Set.new[X](limit_pt[X](b)) = limit_pt(b, x)","Set.new[X](limit_pt[X](b)) = b.closure","not x ∈ Set.new[X](limit_pt[X](b))","not limit_pt(b, x)","b ∩ s0(b, x) = empty[X]","s0(b, x) ∈ x.net.sets","not s0(b, x) ∈ x.net.sets"]}
{"goal":"a.boundary = (a.interior ∪ a.exterior).c","proof":["(a.interior ∪ a.exterior).c = a.boundary"]}
{"goal":"boundary_is_compl_boundary","proof":["let s0: (Set[X], Set[X]) -> X satisfy { forall(x0: Set[X], x1: Set[X], x2: X) { not lib(set).set_eq_prop[X](x0, x1) or not x2 ∈ x0 or x2 ∈ x1 } and forall(x3: Set[X], x4: Set[X], x5: X) { not lib(set).set_eq_prop[X](x3, x4) or not x5 ∈ x4 or x5 ∈ x3 } and forall(x6: Set[X], x7: Set[X]) { s0(x6, x7) ∈ x6 or s0(x6, x7) ∈ x7 or lib(set).set_eq_prop[X](x6, x7) } and forall(x8: Set[X], x9: Set[X]) { not s0(x8, x9) ∈ x8 or s0(x8, x9) ∈ x8 or lib(set).set_eq_prop[X](x8, x9) } and forall(x10: Set[X], x11: Set[X]) { not s0(x11, x10) ∈ x10 or s0(x11, x10) ∈ x10 or lib(set).set_eq_prop[X](x11, x10) } and forall(x12: Set[X], x13: Set[X]) { not s0(x12, x13) ∈ x12 or not s0(x12, x13) ∈ x13 or lib(set).set_eq_prop[X](x12, x13) } }","s0(a.c.boundary, a.boundary) ∈ a.c.boundary = s0(a.c.boundary, a.boundary) ∈ a.boundary","not s0(a.c.boundary, a.boundary) ∈ a.c.boundary or not s0(a.c.boundary, a.boundary) ∈ a.boundary or lib(set).set_eq_prop[X](a.c.boundary, a.boundary)","s0(a.c.boundary, a.boundary) ∈ a.c.boundary or s0(a.c.boundary, a.boundary) ∈ a.boundary or lib(set).set_eq_prop[X](a.c.boundary, a.boundary)","not lib(set).set_eq_prop[X](a.c.boundary, a.boundary) or a.c.boundary = a.boundary","not lib(set).set_eq_prop[X](a.c.boundary, a.boundary)","s0(a.c.boundary, a.boundary) ∈ a.c.boundary != s0(a.c.boundary, a.boundary) ∈ a.boundary or s0(a.c.boundary, a.boundary) ∈ a.boundary or lib(set).set_eq_prop[X](a.c.boundary, a.boundary)","s0(a.c.boundary, a.boundary) ∈ a.boundary","not s0(a.c.boundary, a.boundary) ∈ a.c.boundary","s0(a.c.boundary, a.boundary) ∈ a.c.boundary"]}
{"goal":"b ∩ c != empty[X]","proof":["not a ⊆ b or not c ⊆ c or a ∩ c ⊆ b ∩ c","not empty[X] ⊇ a ∩ c or not empty[X] ⊆ a ∩ c or a ∩ c = empty[X]","empty[X] ⊇ a ∩ c = a ∩ c ⊆ empty[X]","c ⊆ c","empty[X] ⊆ a ∩ c","not empty[X] ⊇ a ∩ c","not a ∩ c ⊆ empty[X]","not c ⊆ c or a ∩ c ⊆ b ∩ c","a ∩ c ⊆ b ∩ c"]}
{"goal":"exists(k0: Set[X]) { if f(x) ∈ v { k0.is_open and x ∈ k0 and k0.image(f) ⊆ v } else { k0 = empty[X] } }","proof":["let (s0: (X -> Y, Set[Y], X) -> Set[X], s1: (X -> Y) -> Set[Y], s2: (X -> Y) -> X) satisfy { forall(x0: X -> Y, x1: Set[Y], x2: X) { not is_continuous[X, Y](x0) or not x1.is_open or not x0(x2) ∈ x1 or s0(x0, x1, x2).is_open } and forall(x3: X -> Y, x4: Set[Y], x5: X) { not is_continuous[X, Y](x3) or not x4.is_open or not x3(x5) ∈ x4 or x5 ∈ s0(x3, x4, x5) } and forall(x6: X -> Y, x7: Set[Y], x8: X) { not is_continuous[X, Y](x6) or not x7.is_open or not x6(x8) ∈ x7 or s0(x6, x7, x8).image(x6) ⊆ x7 } and forall(x9: X -> Y) { s1(x9).is_open or is_continuous[X, Y](x9) } and forall(x10: X -> Y) { x10(s2(x10)) ∈ s1(x10) or is_continuous[X, Y](x10) } and forall(x11: Set[X], x12: X -> Y) { not x11.image(x12) ⊆ s1(x12) or not s2(x12) ∈ x11 or not x11.is_open or is_continuous[X, Y](x12) } }","not s0(f, v, x).image(f) ⊆ v or not f(x) ∈ v or not x ∈ s0(f, v, x) or not s0(f, v, x).is_open","empty[X] != empty[X] or f(x) ∈ v","f(x) ∈ v","not is_continuous[X, Y](f) or not v.is_open or not f(x) ∈ v or s0(f, v, x).image(f) ⊆ v","not is_continuous[X, Y](f) or not v.is_open or not f(x) ∈ v or x ∈ s0(f, v, x)","not is_continuous[X, Y](f) or not v.is_open or not f(x) ∈ v or s0(f, v, x).is_open","s0(f, v, x).is_open","not s0(f, v, x).image(f) ⊆ v or not x ∈ s0(f, v, x) or not s0(f, v, x).is_open","x ∈ s0(f, v, x)","s0(f, v, x).image(f) ⊆ v","not s0(f, v, x).image(f) ⊆ v"]}
{"goal":"f(i).interior = f(i)","proof":["not f(i).is_open or f(i).interior = f(i)"]}
{"goal":"universe[X] = a.boundary ∪ (a.interior ∪ a.exterior)","proof":["(a.interior ∪ a.exterior).c = a.boundary","a.boundary ∪ (a.interior ∪ a.exterior) = a.interior ∪ a.exterior ∪ a.boundary","a.interior ∪ a.exterior ∪ a.boundary != universe[X]","a.interior ∪ a.exterior ∪ (a.interior ∪ a.exterior).c = universe[X]"]}
{"goal":"not x ∈ a.exterior","proof":["x ∈ a.exterior.c.c = x ∉ a.exterior.c","x ∉ a.exterior.c != x ∈ a.exterior.c","a.exterior.c.c = a.exterior","x ∈ a.exterior.c.c","x ∉ a.exterior.c","not x ∉ a.exterior.c or not x ∈ a.exterior.c"]}
{"goal":"not x ∈ a.exterior","proof":["x ∈ a.exterior.c.c = x ∉ a.exterior.c","x ∉ a.exterior.c != x ∈ a.exterior.c","a.exterior.c.c = a.exterior","x ∈ a.exterior.c.c","x ∉ a.exterior.c","not x ∉ a.exterior.c or not x ∈ a.exterior.c"]}
{"goal":"a ∩ a.c = empty[X]","proof":["let s0: (Set[X], Set[X]) -> X satisfy { forall(x0: Set[X], x1: Set[X], x2: X) { not x0 ⊆ x1 or not x2 ∈ x0 or x2 ∈ x1 } and forall(x3: Set[X], x4: Set[X]) { s0(x3, x4) ∈ x3 or x3 ⊆ x4 } and forall(x5: Set[X], x6: Set[X]) { not s0(x6, x5) ∈ x5 or x6 ⊆ x5 } }","not s0(a, a) ∈ a or a ⊆ a","s0(a, a) ∈ a or a ⊆ a","not a ⊆ a or a ∩ a.c = empty[X]","not a ⊆ a","not s0(a, a) ∈ a","s0(a, a) ∈ a"]}
{"goal":"b ⊆ a","proof":["a.c.c = a"]}
{"goal":"a.exterior ⊆ a.c","proof":["a.exterior ⊆ a.c"]}
{"goal":"compl_closure_is_exterior_or_boundary","proof":["a.c.interior ∪ a.c.boundary = a.c.closure","a.c.interior = a.exterior","a.c.boundary = a.boundary"]}
{"goal":"closure_preserve_subset","proof":["let s0: (Set[X], Set[X]) -> X satisfy { forall(x0: Set[X], x1: Set[X], x2: X) { not x0 ⊆ x1 or not x2 ∈ x0 or x2 ∈ x1 } and forall(x3: Set[X], x4: Set[X]) { s0(x3, x4) ∈ x3 or x3 ⊆ x4 } and forall(x5: Set[X], x6: Set[X]) { not s0(x6, x5) ∈ x5 or x6 ⊆ x5 } }","not s0(a.closure, b.closure) ∈ a.closure or s0(a.closure, b.closure) ∈ b.closure","not s0(a.closure, b.closure) ∈ b.closure or a.closure ⊆ b.closure","s0(a.closure, b.closure) ∈ a.closure or a.closure ⊆ b.closure","s0(a.closure, b.closure) ∈ a.closure","not s0(a.closure, b.closure) ∈ b.closure","s0(a.closure, b.closure) ∈ b.closure"]}
{"goal":"b ⊆ a.c.c","proof":["a.c.c = a"]}
{"goal":"contains_imp_limit_pt","proof":["let s0: (Set[X], X) -> Set[X] satisfy { forall(x0: X, x1: Set[X], x2: Set[X]) { not x1 ∈ x0.net.sets or not limit_pt(x2, x0) or x2 ∩ x1 != empty[X] } and forall(x3: X, x4: Set[X]) { s0(x4, x3) ∈ x3.net.sets or limit_pt(x4, x3) } and forall(x5: Set[X], x6: X) { x5 ∩ s0(x5, x6) = empty[X] or limit_pt(x5, x6) } }","not s0(a, x) ∈ x.net.sets or a ∩ s0(a, x) != empty[X]","s0(a, x) ∈ x.net.sets or limit_pt(a, x)","a ∩ s0(a, x) = empty[X] or limit_pt(a, x)","a ∩ s0(a, x) = empty[X]","s0(a, x) ∈ x.net.sets","not s0(a, x) ∈ x.net.sets"]}
{"goal":"exists(k0: Set[X]) { k0 ∈ x.net.sets and k0 ⊆ a.c.c }","proof":["let s0: (Set[X], X) -> Set[X] satisfy { forall(x0: Set[X], x1: X) { not elem_in_exterior(x0, x1) or s0(x0, x1) ∈ x1.net.sets } and forall(x2: Set[X], x3: X) { not elem_in_exterior(x2, x3) or s0(x2, x3) ⊆ x2.c } and forall(x4: X, x5: Set[X], x6: Set[X]) { not x5 ∈ x4.net.sets or not x5 ⊆ x6.c or elem_in_exterior(x6, x4) } }","not s0(a.c, x) ∈ x.net.sets or not s0(a.c, x) ⊆ a.c.c","not elem_in_exterior(a.c, x) or s0(a.c, x) ∈ x.net.sets","not elem_in_exterior(a.c, x) or s0(a.c, x) ⊆ a.c.c","x ∈ Set.new[X](elem_in_exterior[X](a.c)) = elem_in_exterior(a.c, x)","Set.new[X](elem_in_exterior[X](a.c)) = a.c.exterior","x ∈ Set.new[X](elem_in_exterior[X](a.c))","elem_in_exterior(a.c, x)","s0(a.c, x) ⊆ a.c.c","s0(a.c, x) ∈ x.net.sets","not s0(a.c, x) ∈ x.net.sets"]}
{"goal":"x ∉ a.closure","proof":["lib(set).negate_fn(a.closure.contains, x) = x ∉ a.closure","not lib(set).negate_fn(a.closure.contains, x)","lib(set).negate_fn(a.closure.contains, x) != x ∈ a.closure","lib(set).negate_fn(a.closure.contains, x) or x ∈ a.closure"]}
{"goal":"b.interior = b","proof":["not b.is_open or b.interior = b"]}
{"goal":"boundary_is_not_interior_or_exterior","proof":["not a.boundary ⊇ (a.interior ∪ a.exterior).c or not a.boundary ⊆ (a.interior ∪ a.exterior).c or (a.interior ∪ a.exterior).c = a.boundary"]}
{"goal":"exists(k0: I) { x ∈ f(k0) and f(k0).is_open }","proof":["let s0: (I -> Set[X], X) -> I satisfy { forall(x0: I -> Set[X], x1: X) { not lib(set).or_index[I, X](x0, x1) or x1 ∈ x0(s0(x0, x1)) } and forall(x2: I -> Set[X], x3: I, x4: X) { not x4 ∈ x2(x3) or lib(set).or_index[I, X](x2, x4) } }","not x ∈ f(s0(f, x)) or not f(s0(f, x)).is_open","f(s0(f, x)).is_open","not x ∈ f(s0(f, x))","not lib(set).or_index[I, X](f, x) or x ∈ f(s0(f, x))","not lib(set).or_index[I, X](f, x)","x ∈ Set.new[X](lib(set).or_index[I, X](f)) = lib(set).or_index[I, X](f, x)","Set.new[X](lib(set).or_index[I, X](f)) = union_index[I, X](f)","not x ∈ Set.new[X](lib(set).or_index[I, X](f)) or lib(set).or_index[I, X](f, x)","x ∈ Set.new[X](lib(set).or_index[I, X](f))"]}
{"goal":"inv_image_preserve_closed_imp_continuous","proof":["let s0: (X -> Y) -> Set[Y] satisfy { forall(x0: X -> Y) { s0(x0).is_open or is_continuous[X, Y](x0) } and forall(x1: X -> Y) { not s0(x1).inv_image(x1).is_open or is_continuous[X, Y](x1) } }","not s0(f).c.is_closed or s0(f).c.inv_image(f).is_closed","s0(f).inv_image(f).c = s0(f).c.inv_image(f)","not s0(f).inv_image(f).is_open or is_continuous[X, Y](f)","not s0(f).inv_image(f).is_open","s0(f).is_open or is_continuous[X, Y](f)","s0(f).is_open","s0(f).inv_image(f).c.is_closed = s0(f).inv_image(f).is_open","not s0(f).is_open or s0(f).c.is_closed","s0(f).c.is_closed","not s0(f).inv_image(f).c.is_closed","s0(f).c.inv_image(f).is_closed","not s0(f).c.inv_image(f).is_closed"]}
{"goal":"open_imp_compl_closed","proof":["not a.is_open or a.interior = a","a.c.exterior.c = a.c.closure","a.c.closure != a.c or a.c.is_closed","a.c.closure != a.c","a.c.exterior = a.interior","a.interior = a"]}
{"goal":"union_index[X, X](open_cover) ⊆ v.inv_image(f)","proof":["let s0: (X -> Set[X], X) -> X satisfy { forall(x0: X -> Set[X], x1: X) { not lib(set).or_index(x0, x1) or x1 ∈ x0(s0(x0, x1)) } and forall(x2: X -> Set[X], x3: X, x4: X) { not x4 ∈ x2(x3) or lib(set).or_index(x2, x4) } }","let s1: (Set[X], Set[X]) -> X satisfy { forall(x5: Set[X], x6: Set[X], x7: X) { not x5 ⊆ x6 or not x7 ∈ x5 or x7 ∈ x6 } and forall(x8: Set[X], x9: Set[X]) { s1(x8, x9) ∈ x8 or x8 ⊆ x9 } and forall(x10: Set[X], x11: Set[X]) { not s1(x11, x10) ∈ x10 or x11 ⊆ x10 } }","open_cover(s0(open_cover, s1(union_index[X, X](open_cover), v.inv_image(f)))) ⊆ v.inv_image(f)","not lib(set).or_index(open_cover, s1(union_index[X, X](open_cover), v.inv_image(f))) or s1(union_index[X, X](open_cover), v.inv_image(f)) ∈ open_cover(s0(open_cover, s1(union_index[X, X](open_cover), v.inv_image(f))))","not open_cover(s0(open_cover, s1(union_index[X, X](open_cover), v.inv_image(f)))) ⊆ v.inv_image(f) or not s1(union_index[X, X](open_cover), v.inv_image(f)) ∈ open_cover(s0(open_cover, s1(union_index[X, X](open_cover), v.inv_image(f)))) or s1(union_index[X, X](open_cover), v.inv_image(f)) ∈ v.inv_image(f)","not s1(union_index[X, X](open_cover), v.inv_image(f)) ∈ v.inv_image(f) or union_index[X, X](open_cover) ⊆ v.inv_image(f)","s1(union_index[X, X](open_cover), v.inv_image(f)) ∈ union_index[X, X](open_cover) or union_index[X, X](open_cover) ⊆ v.inv_image(f)","s1(union_index[X, X](open_cover), v.inv_image(f)) ∈ Set.new[X](lib(set).or_index[X, X](open_cover)) = lib(set).or_index(open_cover, s1(union_index[X, X](open_cover), v.inv_image(f)))","Set.new[X](lib(set).or_index[X, X](open_cover)) = union_index[X, X](open_cover)","s1(union_index[X, X](open_cover), v.inv_image(f)) ∈ union_index[X, X](open_cover)","not s1(union_index[X, X](open_cover), v.inv_image(f)) ∈ v.inv_image(f)","not s1(union_index[X, X](open_cover), v.inv_image(f)) ∈ open_cover(s0(open_cover, s1(union_index[X, X](open_cover), v.inv_image(f)))) or s1(union_index[X, X](open_cover), v.inv_image(f)) ∈ v.inv_image(f)","s1(union_index[X, X](open_cover), v.inv_image(f)) ∈ Set.new[X](lib(set).or_index[X, X](open_cover))","lib(set).or_index(open_cover, s1(union_index[X, X](open_cover), v.inv_image(f)))","not s1(union_index[X, X](open_cover), v.inv_image(f)) ∈ open_cover(s0(open_cover, s1(union_index[X, X](open_cover), v.inv_image(f))))"]}
{"goal":"x ∈ union_index[I, X](f).interior","proof":["not b ∈ x.net.sets or not b ⊆ union_index[I, X](f) or elem_in_interior(union_index[I, X](f), x)","x ∈ Set.new[X](elem_in_interior[X](union_index[I, X](f))) = elem_in_interior(union_index[I, X](f), x)","Set.new[X](elem_in_interior[X](union_index[I, X](f))) = union_index[I, X](f).interior","not x ∈ Set.new[X](elem_in_interior[X](union_index[I, X](f)))","not elem_in_interior(union_index[I, X](f), x)","not b ⊆ union_index[I, X](f) or elem_in_interior(union_index[I, X](f), x)"]}
{"goal":"continuous_imp_inv_image_preserve_closed","proof":["let s0: Set[Y] satisfy { s0.is_closed and not s0.inv_image(f).is_closed }","not is_continuous[X, Y](f) or not s0.c.is_open or s0.c.inv_image(f).is_open","s0.inv_image(f).c = s0.c.inv_image(f)","s0.inv_image(f).c.is_open = s0.inv_image(f).is_closed","not s0.inv_image(f).c.is_open","s0.c.is_open = s0.is_closed","s0.c.is_open","not s0.c.inv_image(f).is_open"]}
{"goal":"union[X](c) = union[X](c).interior","proof":["not union[X](c).interior ⊇ union[X](c) or not union[X](c).interior ⊆ union[X](c) or union[X](c).interior = union[X](c)","union[X](c).interior ⊇ union[X](c) = union[X](c) ⊆ union[X](c).interior","union[X](c).interior ⊆ union[X](c)","union[X](c).interior ⊇ union[X](c)","not union[X](c).interior ⊇ union[X](c)"]}
{"goal":"union_index[X, X](open_cover) = v.inv_image(f)","proof":["not lib(util).is_antisymmetric[Set[X]](Set.subset_eq[X]) or not v.inv_image(f) ⊆ union_index[X, X](open_cover) or not union_index[X, X](open_cover) ⊆ v.inv_image(f) or v.inv_image(f) = union_index[X, X](open_cover)","not lib(util).is_antisymmetric[Set[X]](Set.subset_eq[X])"]}
{"goal":"x ∈ a.exterior.c","proof":["not x ∈ a.interior.c ∩ a.exterior.c or x ∈ a.exterior.c"]}
{"goal":"x ∈ a.exterior.c","proof":["lib(set).negate_fn(a.exterior.contains, x) = x ∉ a.exterior","x ∈ a.exterior.c = x ∉ a.exterior","not x ∉ a.exterior","lib(set).negate_fn(a.exterior.contains, x) != x ∈ a.exterior","not lib(set).negate_fn(a.exterior.contains, x)","lib(set).negate_fn(a.exterior.contains, x) or x ∈ a.exterior"]}
{"goal":"open_cover(x) ⊆ v.inv_image(f)","proof":["open_cover(x) ⊆ v.inv_image(f) = open_cover(x).image(f) ⊆ v"]}
{"goal":"x ∉ a.closure.closure","proof":["not b ∈ x.net.sets or not limit_pt(a.closure, x) or a.closure ∩ b != empty[X]","x ∉ Set.new[X](limit_pt[X](a.closure)) != x ∈ Set.new[X](limit_pt[X](a.closure))","a.closure ∩ b = b ∩ a.closure","x ∈ Set.new[X](limit_pt[X](a.closure)) = limit_pt(a.closure, x)","Set.new[X](limit_pt[X](a.closure)) = a.closure.closure","not x ∉ Set.new[X](limit_pt[X](a.closure))","x ∉ Set.new[X](limit_pt[X](a.closure)) or x ∈ Set.new[X](limit_pt[X](a.closure))","a.closure ∩ b = empty[X]","not limit_pt(a.closure, x) or a.closure ∩ b != empty[X]","x ∈ Set.new[X](limit_pt[X](a.closure))","not limit_pt(a.closure, x)","limit_pt(a.closure, x)"]}
{"goal":"a ∩ b = empty[X]","proof":["not b ⊆ a.c or b ∩ a.c.c = empty[X]","b ∩ a = a ∩ b","b ∩ a != empty[X]","a.c.c = a","b ∩ a.c.c = empty[X]","b ∩ a.c.c != empty[X]"]}
{"goal":"v.inv_image(f) ⊆ union_index[X, X](open_cover)","proof":["let s0: (Set[X], Set[X]) -> X satisfy { forall(x0: Set[X], x1: Set[X], x2: X) { not x0 ⊆ x1 or not x2 ∈ x0 or x2 ∈ x1 } and forall(x3: Set[X], x4: Set[X]) { s0(x3, x4) ∈ x3 or x3 ⊆ x4 } and forall(x5: Set[X], x6: Set[X]) { not s0(x6, x5) ∈ x5 or x6 ⊆ x5 } }","not s0(v.inv_image(f), union_index[X, X](open_cover)) ∈ v.inv_image(f) or s0(v.inv_image(f), union_index[X, X](open_cover)) ∈ union_index[X, X](open_cover)","not s0(v.inv_image(f), union_index[X, X](open_cover)) ∈ union_index[X, X](open_cover) or v.inv_image(f) ⊆ union_index[X, X](open_cover)","s0(v.inv_image(f), union_index[X, X](open_cover)) ∈ v.inv_image(f) or v.inv_image(f) ⊆ union_index[X, X](open_cover)","not s0(v.inv_image(f), union_index[X, X](open_cover)) ∈ union_index[X, X](open_cover)","s0(v.inv_image(f), union_index[X, X](open_cover)) ∈ v.inv_image(f)","not s0(v.inv_image(f), union_index[X, X](open_cover)) ∈ v.inv_image(f)"]}
{"goal":"a.c.exterior ⊇ a.interior","proof":["let s0: (Set[X], Set[X]) -> X satisfy { forall(x0: Set[X], x1: Set[X], x2: X) { not x0 ⊇ x1 or not x2 ∈ x1 or x2 ∈ x0 } and forall(x3: Set[X], x4: Set[X]) { s0(x4, x3) ∈ x3 or x4 ⊇ x3 } and forall(x5: Set[X], x6: Set[X]) { not s0(x5, x6) ∈ x5 or x5 ⊇ x6 } }","not s0(a.c.exterior, a.interior) ∈ a.interior or s0(a.c.exterior, a.interior) ∈ a.c.exterior","not s0(a.c.exterior, a.interior) ∈ a.c.exterior or a.c.exterior ⊇ a.interior","s0(a.c.exterior, a.interior) ∈ a.interior or a.c.exterior ⊇ a.interior","s0(a.c.exterior, a.interior) ∈ a.interior","not s0(a.c.exterior, a.interior) ∈ a.c.exterior","s0(a.c.exterior, a.interior) ∈ a.c.exterior"]}
{"goal":"f(x) ∈ v","proof":["not v.inv_image(f).image(f) ⊆ v or not x ∈ v.inv_image(f) or f(x) ∈ v","v.inv_image(f).image(f) ⊆ v","not v.inv_image(f).image(f) ⊆ v or not x ∈ v.inv_image(f)"]}
{"goal":"union_preserve_open","proof":[]}
{"goal":"x ∈ a.interior.c ∩ a.exterior.c","proof":["a.interior.c ∩ a.exterior.c = (a.interior ∪ a.exterior).c"]}
{"goal":"x ∈ a implies limit_pt(a, x)","proof":["not x ∈ a or limit_pt(a, x)"]}
{"goal":"x ∈ a.c.boundary","proof":["let s0: (Set[X], X) -> Set[X] satisfy { forall(x0: X, x1: Set[X]) { s0(x1, x0) ∈ x0.net.sets or x0 ∈ x1.boundary } and forall(x2: Set[X], x3: X) { x2.c ∩ s0(x2, x3) = empty[X] or x3 ∈ x2.boundary or x2 ∩ s0(x2, x3) = empty[X] } }","not s0(a.c, x) ∈ x.net.sets or a.c ∩ s0(a.c, x) != empty[X]","not s0(a.c, x) ∈ x.net.sets or a.c.c ∩ s0(a.c, x) != empty[X]","a.c.c ∩ s0(a.c, x) = empty[X] or x ∈ a.c.boundary or a.c ∩ s0(a.c, x) = empty[X]","s0(a.c, x) ∈ x.net.sets or x ∈ a.c.boundary","s0(a.c, x) ∈ x.net.sets","a.c ∩ s0(a.c, x) != empty[X]","a.c.c ∩ s0(a.c, x) != empty[X]","a.c.c ∩ s0(a.c, x) = empty[X]"]}
{"goal":"x ∈ b.interior","proof":["let s0: Set[X] satisfy { s0 ∈ x.net.sets and s0 ⊆ a }","not lib(util).is_transitive[Set[X]](Set.subset_eq[X]) or not s0 ⊆ a or not a ⊆ b or s0 ⊆ b","not s0 ∈ x.net.sets or not s0 ⊆ b or elem_in_interior(b, x)","x ∈ Set.new[X](elem_in_interior[X](b)) = elem_in_interior(b, x)","Set.new[X](elem_in_interior[X](b)) = b.interior","not x ∈ Set.new[X](elem_in_interior[X](b))","not elem_in_interior(b, x)","not s0 ⊆ a or s0 ⊆ b","s0 ⊆ b","not s0 ⊆ b or elem_in_interior(b, x)"]}
{"goal":"x ∈ b.interior","proof":["not x ∈ b"]}
{"goal":"x ∈ b","proof":["not b ∈ x.net.sets or not x.net.have_common_pt(x) or x ∈ b","x.net.have_common_pt(x)","not b ∈ x.net.sets or not x.net.have_common_pt(x)"]}
{"goal":"x ∈ b","proof":["not b ∈ x.net.sets or not x.net.have_common_pt(x) or x ∈ b","x.net.have_common_pt(x)","not b ∈ x.net.sets or not x.net.have_common_pt(x)"]}
{"goal":"x ∈ b","proof":["not b ∈ x.net.sets or not x.net.have_common_pt(x) or x ∈ b","x.net.have_common_pt(x)","not b ∈ x.net.sets or not x.net.have_common_pt(x)"]}
{"goal":"x ∈ b","proof":["not x ∈ a ∩ b or x ∈ b"]}
{"goal":"x ∈ a","proof":["not b ⊆ a or not x ∈ b or x ∈ a","not b ⊆ a or not x ∈ b"]}
{"goal":"x ∈ a","proof":["not x ∈ a ∩ b or x ∈ a"]}
{"goal":"x ∈ a.exterior","proof":["x ∈ a.closure.c = x ∉ a.closure","a.exterior.c = a.closure","Set.new[X](elem_in_exterior[X](a)) = a.exterior","Set.new[X](Set.new[X](elem_in_exterior[X](a)).contains) = Set.new[X](elem_in_exterior[X](a))","Set.new[X](a.exterior.contains).c.c = Set.new[X](a.exterior.contains)"]}
{"goal":"x ∈ (a.interior ∪ a.exterior).c","proof":["x ∈ (a.interior ∪ a.exterior).c = x ∉ a.interior ∪ a.exterior"]}
{"goal":"b.closure.inv_image(f).is_closed","proof":["not is_continuous[X, Y](f) or not b.closure.is_closed or b.closure.inv_image(f).is_closed","not b.closure.is_closed","b.closure.is_closed"]}
{"goal":"x ∈ a.closure.closure","proof":["not x ∈ a.closure or limit_pt(a.closure, x)","x ∈ Set.new[X](limit_pt[X](a.closure)) = limit_pt(a.closure, x)","Set.new[X](limit_pt[X](a.closure)) = a.closure.closure","not x ∈ Set.new[X](limit_pt[X](a.closure))","limit_pt(a.closure, x)","not limit_pt(a.closure, x)"]}
{"goal":"exists(k0: Set[X]) { k0 ∈ x.net.sets and k0 ⊆ b }","proof":["let s0: (Set[X], X) -> Set[X] satisfy { forall(x0: Set[X], x1: X) { not x1 ∈ x0.interior or s0(x0, x1) ∈ x1.net.sets } and forall(x2: Set[X], x3: X) { not x3 ∈ x2.interior or s0(x2, x3) ⊆ x2.interior } }","not s0(b, x) ∈ x.net.sets or not s0(b, x) ⊆ b","not x ∈ b.interior or s0(b, x) ∈ x.net.sets","not x ∈ b.interior or s0(b, x) ⊆ b.interior","s0(b, x) ⊆ b.interior","s0(b, x) ⊆ b","s0(b, x) ∈ x.net.sets","not s0(b, x) ∈ x.net.sets"]}
{"goal":"b ⊆ b.closure","proof":["b ⊆ b.closure"]}
{"goal":"s ⊆ b","proof":["not s ⊆ a or not a ⊆ b or s ⊆ b","not s ⊆ a or not a ⊆ b"]}
{"goal":"continuous_imp_interior_inv_image_subset_inv_image_interior","proof":["not v.interior.inv_image(f).is_open or not v.interior.inv_image(f) ⊆ v.inv_image(f) or v.interior.inv_image(f) ⊆ v.inv_image(f).interior"]}
{"goal":"exists(k0: Set[X]) { k0 ∈ x.net.sets and k0 ⊆ a.c }","proof":["let s0: (Set[X], X) -> Set[X] satisfy { forall(x0: Set[X], x1: X) { not elem_in_exterior(x0, x1) or s0(x0, x1) ∈ x1.net.sets } and forall(x2: Set[X], x3: X) { not elem_in_exterior(x2, x3) or s0(x2, x3) ⊆ x2.c } and forall(x4: X, x5: Set[X], x6: Set[X]) { not x5 ∈ x4.net.sets or not x5 ⊆ x6.c or elem_in_exterior(x6, x4) } }","not s0(a, x) ∈ x.net.sets or not s0(a, x) ⊆ a.c","not elem_in_exterior(a, x) or s0(a, x) ∈ x.net.sets","not elem_in_exterior(a, x) or s0(a, x) ⊆ a.c","x ∈ Set.new[X](elem_in_exterior[X](a)) = elem_in_exterior(a, x)","Set.new[X](elem_in_exterior[X](a)) = a.exterior","x ∈ Set.new[X](elem_in_exterior[X](a))","elem_in_exterior(a, x)","s0(a, x) ⊆ a.c","s0(a, x) ∈ x.net.sets","not s0(a, x) ∈ x.net.sets"]}
{"goal":"exists(k0: Set[X]) { k0 ∈ x.net.sets and k0 ⊆ a.c }","proof":["let s0: (Set[X], X) -> Set[X] satisfy { forall(x0: Set[X], x1: X) { not elem_in_exterior(x0, x1) or s0(x0, x1) ∈ x1.net.sets } and forall(x2: Set[X], x3: X) { not elem_in_exterior(x2, x3) or s0(x2, x3) ⊆ x2.c } and forall(x4: X, x5: Set[X], x6: Set[X]) { not x5 ∈ x4.net.sets or not x5 ⊆ x6.c or elem_in_exterior(x6, x4) } }","not s0(a, x) ∈ x.net.sets or not s0(a, x) ⊆ a.c","not elem_in_exterior(a, x) or s0(a, x) ∈ x.net.sets","not elem_in_exterior(a, x) or s0(a, x) ⊆ a.c","x ∈ Set.new[X](elem_in_exterior[X](a)) = elem_in_exterior(a, x)","Set.new[X](elem_in_exterior[X](a)) = a.exterior","x ∈ Set.new[X](elem_in_exterior[X](a))","elem_in_exterior(a, x)","s0(a, x) ⊆ a.c","s0(a, x) ∈ x.net.sets","not s0(a, x) ∈ x.net.sets"]}
{"goal":"exists(k0: Set[X]) { k0 ∈ x.net.sets and k0 ⊆ a.c }","proof":["let s0: (Set[X], X) -> Set[X] satisfy { forall(x0: Set[X], x1: X) { not elem_in_exterior(x0, x1) or s0(x0, x1) ∈ x1.net.sets } and forall(x2: Set[X], x3: X) { not elem_in_exterior(x2, x3) or s0(x2, x3) ⊆ x2.c } and forall(x4: X, x5: Set[X], x6: Set[X]) { not x5 ∈ x4.net.sets or not x5 ⊆ x6.c or elem_in_exterior(x6, x4) } }","not s0(a, x) ∈ x.net.sets or not s0(a, x) ⊆ a.c","not elem_in_exterior(a, x) or s0(a, x) ∈ x.net.sets","not elem_in_exterior(a, x) or s0(a, x) ⊆ a.c","x ∈ Set.new[X](elem_in_exterior[X](a)) = elem_in_exterior(a, x)","Set.new[X](elem_in_exterior[X](a)) = a.exterior","x ∈ Set.new[X](elem_in_exterior[X](a))","elem_in_exterior(a, x)","s0(a, x) ⊆ a.c","s0(a, x) ∈ x.net.sets","not s0(a, x) ∈ x.net.sets"]}
{"goal":"interior_exterior_separate","proof":["not a.interior ∩ a.exterior ⊆ empty[X] or a.interior ∩ a.exterior ∪ empty[X] = empty[X]","a ∩ a.c = empty[X]","a.interior ∩ a.exterior ∪ empty[X] = a.interior ∩ a.exterior","a.interior ∩ a.exterior ⊆ empty[X]","a.interior ∩ a.exterior ∪ empty[X] != empty[X]","a.interior ∩ a.exterior ∪ empty[X] = empty[X]"]}
{"goal":"a.interior ⊆ a","proof":["a.interior ⊆ a"]}
{"goal":"exists(k0: Set[X]) { k0 ∈ x.net.sets and k0 ⊆ a }","proof":["let s0: (Set[X], X) -> Set[X] satisfy { forall(x0: Set[X], x1: X) { not elem_in_interior(x0, x1) or s0(x0, x1) ∈ x1.net.sets } and forall(x2: Set[X], x3: X) { not elem_in_interior(x2, x3) or s0(x2, x3) ⊆ x2 } and forall(x4: X, x5: Set[X], x6: Set[X]) { not x5 ∈ x4.net.sets or not x5 ⊆ x6 or elem_in_interior(x6, x4) } }","not s0(a, x) ∈ x.net.sets or not s0(a, x) ⊆ a","not elem_in_interior(a, x) or s0(a, x) ∈ x.net.sets","not elem_in_interior(a, x) or s0(a, x) ⊆ a","x ∈ Set.new[X](elem_in_interior[X](a)) = elem_in_interior(a, x)","Set.new[X](elem_in_interior[X](a)) = a.interior","x ∈ Set.new[X](elem_in_interior[X](a))","elem_in_interior(a, x)","s0(a, x) ⊆ a","s0(a, x) ∈ x.net.sets","not s0(a, x) ∈ x.net.sets"]}
{"goal":"exists(k0: Set[X]) { k0 ∈ x.net.sets and k0 ⊆ a }","proof":["let s0: (Set[X], X) -> Set[X] satisfy { forall(x0: Set[X], x1: X) { not elem_in_interior(x0, x1) or s0(x0, x1) ∈ x1.net.sets } and forall(x2: Set[X], x3: X) { not elem_in_interior(x2, x3) or s0(x2, x3) ⊆ x2 } and forall(x4: X, x5: Set[X], x6: Set[X]) { not x5 ∈ x4.net.sets or not x5 ⊆ x6 or elem_in_interior(x6, x4) } }","not s0(a, x) ∈ x.net.sets or not s0(a, x) ⊆ a","not elem_in_interior(a, x) or s0(a, x) ∈ x.net.sets","not elem_in_interior(a, x) or s0(a, x) ⊆ a","x ∈ Set.new[X](elem_in_interior[X](a)) = elem_in_interior(a, x)","Set.new[X](elem_in_interior[X](a)) = a.interior","x ∈ Set.new[X](elem_in_interior[X](a))","elem_in_interior(a, x)","s0(a, x) ⊆ a","s0(a, x) ∈ x.net.sets","not s0(a, x) ∈ x.net.sets"]}
{"goal":"exists(k0: Set[X]) { k0 ∈ x.net.sets and k0 ⊆ a }","proof":["let s0: (Set[X], X) -> Set[X] satisfy { forall(x0: Set[X], x1: X) { not elem_in_interior(x0, x1) or s0(x0, x1) ∈ x1.net.sets } and forall(x2: Set[X], x3: X) { not elem_in_interior(x2, x3) or s0(x2, x3) ⊆ x2 } and forall(x4: X, x5: Set[X], x6: Set[X]) { not x5 ∈ x4.net.sets or not x5 ⊆ x6 or elem_in_interior(x6, x4) } }","not s0(a, x) ∈ x.net.sets or not s0(a, x) ⊆ a","not elem_in_interior(a, x) or s0(a, x) ∈ x.net.sets","not elem_in_interior(a, x) or s0(a, x) ⊆ a","x ∈ Set.new[X](elem_in_interior[X](a)) = elem_in_interior(a, x)","Set.new[X](elem_in_interior[X](a)) = a.interior","x ∈ Set.new[X](elem_in_interior[X](a))","elem_in_interior(a, x)","s0(a, x) ⊆ a","s0(a, x) ∈ x.net.sets","not s0(a, x) ∈ x.net.sets"]}
{"goal":"exists(k0: Set[X]) { k0 ∈ x.net.sets and k0 ⊆ a }","proof":["let s0: (Set[X], X) -> Set[X] satisfy { forall(x0: Set[X], x1: X) { not elem_in_interior(x0, x1) or s0(x0, x1) ∈ x1.net.sets } and forall(x2: Set[X], x3: X) { not elem_in_interior(x2, x3) or s0(x2, x3) ⊆ x2 } and forall(x4: X, x5: Set[X], x6: Set[X]) { not x5 ∈ x4.net.sets or not x5 ⊆ x6 or elem_in_interior(x6, x4) } }","not s0(a, x) ∈ x.net.sets or not s0(a, x) ⊆ a","not elem_in_interior(a, x) or s0(a, x) ∈ x.net.sets","not elem_in_interior(a, x) or s0(a, x) ⊆ a","x ∈ Set.new[X](elem_in_interior[X](a)) = elem_in_interior(a, x)","Set.new[X](elem_in_interior[X](a)) = a.interior","x ∈ Set.new[X](elem_in_interior[X](a))","elem_in_interior(a, x)","s0(a, x) ⊆ a","s0(a, x) ∈ x.net.sets","not s0(a, x) ∈ x.net.sets"]}
{"goal":"exists(k0: Set[X]) { k0 ∈ x.net.sets and k0 ⊆ a }","proof":["let s0: (Set[X], X) -> Set[X] satisfy { forall(x0: Set[X], x1: X) { not x1 ∈ x0.interior or s0(x0, x1) ∈ x1.net.sets } and forall(x2: Set[X], x3: X) { not x3 ∈ x2.interior or s0(x2, x3) ⊆ x2.interior } }","not s0(a, x) ∈ x.net.sets or not s0(a, x) ⊆ a","not x ∈ a.interior or s0(a, x) ∈ x.net.sets","not x ∈ a.interior or s0(a, x) ⊆ a.interior","s0(a, x) ⊆ a.interior","s0(a, x) ⊆ a","s0(a, x) ∈ x.net.sets","not s0(a, x) ∈ x.net.sets"]}
{"goal":"not b ⊆ a","proof":["not b ∈ x.net.sets or not b ⊆ a or elem_in_interior(a, x)","x ∈ Set.new[X](elem_in_interior[X](a)) = elem_in_interior(a, x)","Set.new[X](elem_in_interior[X](a)) = a.interior","not b ∈ x.net.sets or elem_in_interior(a, x)","elem_in_interior(a, x)","not elem_in_interior(a, x) or x ∈ Set.new[X](elem_in_interior[X](a))","not x ∈ Set.new[X](elem_in_interior[X](a))"]}
{"goal":"a ∩ b != empty[X]","proof":["b ∩ a.c.c != empty[X] or b ⊆ a.c","b ∩ a = a ∩ b","b ∩ a = empty[X]","a.c.c = a","b ∩ a.c.c != empty[X]","b ∩ a.c.c = empty[X]"]}
{"goal":"a ∩ b != empty[X]","proof":["x ∈ empty[X]","not x ∈ empty[X] or lib(set).is_nonempty[X](empty[X])","lib(set).is_nonempty[X](empty[X])","not lib(set).is_nonempty[X](empty[X]) or Set.empty_set[X] != empty[X]","Set.empty_set[X] != empty[X]"]}
{"goal":"is_net[X](x.net.sets)","proof":["is_net[X](x.net.sets)"]}
{"goal":"b ⊆ union_index[I, X](f)","proof":["let s0: (Set[X], Set[X]) -> X satisfy { forall(x0: Set[X], x1: Set[X], x2: X) { not x0 ⊆ x1 or not x2 ∈ x0 or x2 ∈ x1 } and forall(x3: Set[X], x4: Set[X]) { s0(x3, x4) ∈ x3 or x3 ⊆ x4 } and forall(x5: Set[X], x6: Set[X]) { not s0(x6, x5) ∈ x5 or x6 ⊆ x5 } }","not b ⊆ f(i) or not s0(b, union_index[I, X](f)) ∈ b or s0(b, union_index[I, X](f)) ∈ f(i)","not s0(b, union_index[I, X](f)) ∈ union_index[I, X](f) or b ⊆ union_index[I, X](f)","s0(b, union_index[I, X](f)) ∈ b or b ⊆ union_index[I, X](f)","not s0(b, union_index[I, X](f)) ∈ f(i) or lib(set).or_index[I, X](f, s0(b, union_index[I, X](f)))","s0(b, union_index[I, X](f)) ∈ Set.new[X](lib(set).or_index[I, X](f)) = lib(set).or_index[I, X](f, s0(b, union_index[I, X](f)))","s0(b, union_index[I, X](f)) ∈ b","Set.new[X](lib(set).or_index[I, X](f)) = union_index[I, X](f)","not s0(b, union_index[I, X](f)) ∈ union_index[I, X](f)","not s0(b, union_index[I, X](f)) ∈ b or s0(b, union_index[I, X](f)) ∈ f(i)","not s0(b, union_index[I, X](f)) ∈ Set.new[X](lib(set).or_index[I, X](f))","not lib(set).or_index[I, X](f, s0(b, union_index[I, X](f)))","s0(b, union_index[I, X](f)) ∈ f(i)"]}
{"goal":"a.exterior.c = a.boundary ∪ a.interior","proof":["a.boundary ∪ a.interior ∪ a.exterior != universe[X] or (a.boundary ∪ a.interior) ∩ a.exterior != empty[X] or a.boundary ∪ a.interior = a.exterior.c"]}
{"goal":"a.is_open implies a.c.is_closed","proof":["not a.is_open or a.c.is_closed"]}
{"goal":"v.interior ⊆ v","proof":["v.interior ⊆ v"]}
{"goal":"x ∈ a ∩ b","proof":["not x ∈ a or not x ∈ b or x ∈ a ∩ b"]}
{"goal":"closure_is_interior_or_boundary","proof":["a.interior ∪ a.boundary = a.boundary ∪ a.interior"]}
{"goal":"a.boundary ⊇ (a.interior ∪ a.exterior).c","proof":["let s0: (Set[X], Set[X]) -> X satisfy { forall(x0: Set[X], x1: Set[X], x2: X) { not x0 ⊇ x1 or not x2 ∈ x1 or x2 ∈ x0 } and forall(x3: Set[X], x4: Set[X]) { s0(x4, x3) ∈ x3 or x4 ⊇ x3 } and forall(x5: Set[X], x6: Set[X]) { not s0(x5, x6) ∈ x5 or x5 ⊇ x6 } }","not s0(a.boundary, (a.interior ∪ a.exterior).c) ∈ (a.interior ∪ a.exterior).c or s0(a.boundary, (a.interior ∪ a.exterior).c) ∈ a.boundary","not s0(a.boundary, (a.interior ∪ a.exterior).c) ∈ a.boundary or a.boundary ⊇ (a.interior ∪ a.exterior).c","s0(a.boundary, (a.interior ∪ a.exterior).c) ∈ (a.interior ∪ a.exterior).c or a.boundary ⊇ (a.interior ∪ a.exterior).c","not s0(a.boundary, (a.interior ∪ a.exterior).c) ∈ a.boundary","s0(a.boundary, (a.interior ∪ a.exterior).c) ∈ (a.interior ∪ a.exterior).c","not s0(a.boundary, (a.interior ∪ a.exterior).c) ∈ (a.interior ∪ a.exterior).c"]}
{"goal":"a ∩ c != empty[X]","proof":["not c ∈ x.net.sets or not limit_pt(a, x) or a ∩ c != empty[X]","x ∈ Set.new[X](limit_pt[X](a)) = limit_pt(a, x)","Set.new[X](limit_pt[X](a)) = a.closure","not c ∈ x.net.sets or not limit_pt(a, x)","not limit_pt(a, x)","not x ∈ Set.new[X](limit_pt[X](a)) or limit_pt(a, x)","x ∈ Set.new[X](limit_pt[X](a))"]}
{"goal":"a.interior = a","proof":["not a.is_open or a.interior = a"]}
{"goal":"exists(k0: Set[X]) { k0 ∈ x.net.sets and k0 ⊆ a.exterior }","proof":["let s0: (Set[X], X) -> Set[X] satisfy { forall(x0: Set[X], x1: X) { not x1 ∈ x0.exterior or s0(x0, x1) ∈ x1.net.sets } and forall(x2: Set[X], x3: X) { not x3 ∈ x2.exterior or s0(x2, x3) ⊆ x2.exterior } }","not s0(a, x) ∈ x.net.sets or not s0(a, x) ⊆ a.exterior","not x ∈ a.exterior or s0(a, x) ∈ x.net.sets","not x ∈ a.exterior or s0(a, x) ⊆ a.exterior","s0(a, x) ⊆ a.exterior","s0(a, x) ∈ x.net.sets","not s0(a, x) ∈ x.net.sets"]}
{"goal":"x ∈ a.boundary","proof":["let s0: Set[X] satisfy { s0 ∈ x.net.sets or x ∈ a.boundary and (a.c ∩ s0 = empty[X] or x ∈ a.boundary or a ∩ s0 = empty[X]) }","not s0 ∈ x.net.sets or a.c ∩ s0 != empty[X]","not s0 ∈ x.net.sets or not s0 ⊆ a.c or elem_in_exterior(a, x)","a.c ∩ s0 != empty[X]","a ∩ s0 = empty[X]","s0 ∩ a.c.c != empty[X] or s0 ⊆ a.c","s0 ∩ a = a ∩ s0","x ∈ Set.new[X](elem_in_exterior[X](a)) = elem_in_exterior(a, x)","Set.new[X](elem_in_exterior[X](a)) = a.exterior","a.c.c = a","not s0 ⊆ a.c or elem_in_exterior(a, x)","not x ∈ Set.new[X](elem_in_exterior[X](a))","not elem_in_exterior(a, x)","s0 ∩ a = empty[X]","not s0 ⊆ a.c","s0 ∩ a.c.c = empty[X]","s0 ∩ a.c.c != empty[X]"]}
{"goal":"x ∈ a.boundary","proof":["let s0: (Set[X], X) -> Set[X] satisfy { forall(x0: X, x1: Set[X]) { s0(x1, x0) ∈ x0.net.sets or x0 ∈ x1.boundary } and forall(x2: Set[X], x3: X) { x2.c ∩ s0(x2, x3) = empty[X] or x3 ∈ x2.boundary or x2 ∩ s0(x2, x3) = empty[X] } }","not s0(a, x) ∈ x.net.sets or a ∩ s0(a, x) != empty[X]","not s0(a, x) ∈ x.net.sets or a.c ∩ s0(a, x) != empty[X]","a.c ∩ s0(a, x) = empty[X] or x ∈ a.boundary or a ∩ s0(a, x) = empty[X]","s0(a, x) ∈ x.net.sets or x ∈ a.boundary","s0(a, x) ∈ x.net.sets","a ∩ s0(a, x) != empty[X]","a.c ∩ s0(a, x) != empty[X]","a.c ∩ s0(a, x) = empty[X]"]}
{"goal":"subset_closure","proof":["let s0: (Set[X], Set[X]) -> X satisfy { forall(x0: Set[X], x1: Set[X], x2: X) { not x0 ⊆ x1 or not x2 ∈ x0 or x2 ∈ x1 } and forall(x3: Set[X], x4: Set[X]) { s0(x3, x4) ∈ x3 or x3 ⊆ x4 } and forall(x5: Set[X], x6: Set[X]) { not s0(x6, x5) ∈ x5 or x6 ⊆ x5 } }","not s0(a, a.closure) ∈ a or s0(a, a.closure) ∈ a.closure","not s0(a, a.closure) ∈ a.closure or a ⊆ a.closure","s0(a, a.closure) ∈ a or a ⊆ a.closure","s0(a, a.closure) ∈ a","not s0(a, a.closure) ∈ a.closure","s0(a, a.closure) ∈ a.closure"]}
{"goal":"a.c ∩ b != empty[X]","proof":["b ∩ a.c != empty[X] or b ⊆ a","a.c ∩ b = b ∩ a.c","b ∩ a.c != empty[X]","b ∩ a.c = empty[X]"]}
{"goal":"exterior_is_compl_interior","proof":["a ∪ a.c != universe[X] or a ∩ a.c != empty[X] or a.c.c = a","a.c.c.exterior = a.c.interior","a.c.c.exterior != a.exterior","a.c.c != a","a ∪ a.c = universe[X]","a ∩ a.c = empty[X]"]}
{"goal":"a.c.exterior ⊆ a.interior","proof":["let s0: (Set[X], Set[X]) -> X satisfy { forall(x0: Set[X], x1: Set[X], x2: X) { not x0 ⊆ x1 or not x2 ∈ x0 or x2 ∈ x1 } and forall(x3: Set[X], x4: Set[X]) { s0(x3, x4) ∈ x3 or x3 ⊆ x4 } and forall(x5: Set[X], x6: Set[X]) { not s0(x6, x5) ∈ x5 or x6 ⊆ x5 } }","not s0(a.c.exterior, a.interior) ∈ a.c.exterior or s0(a.c.exterior, a.interior) ∈ a.interior","not s0(a.c.exterior, a.interior) ∈ a.interior or a.c.exterior ⊆ a.interior","s0(a.c.exterior, a.interior) ∈ a.c.exterior or a.c.exterior ⊆ a.interior","not s0(a.c.exterior, a.interior) ∈ a.interior","s0(a.c.exterior, a.interior) ∈ a.c.exterior","not s0(a.c.exterior, a.interior) ∈ a.c.exterior"]}
{"goal":"a.interior ∩ a.exterior ⊆ a ∩ a.c","proof":["not a.interior ⊆ a or not a.exterior ⊆ a.c or a.interior ∩ a.exterior ⊆ a ∩ a.c"]}
{"goal":"v.inv_image(f).is_open","proof":[]}
{"goal":"b ∩ a.closure = empty[X]","proof":["not b ⊆ a.exterior or b ∩ a.exterior.c = empty[X]","a.exterior.c = a.closure","b ∩ a.exterior.c = empty[X]","b ∩ a.exterior.c != empty[X]"]}
{"goal":"a ∩ b ⊆ (a ∩ b).interior","proof":["let s0: (Set[X], Set[X]) -> X satisfy { forall(x0: Set[X], x1: Set[X], x2: X) { not x0 ⊆ x1 or not x2 ∈ x0 or x2 ∈ x1 } and forall(x3: Set[X], x4: Set[X]) { s0(x3, x4) ∈ x3 or x3 ⊆ x4 } and forall(x5: Set[X], x6: Set[X]) { not s0(x6, x5) ∈ x5 or x6 ⊆ x5 } }","not s0(a ∩ b, (a ∩ b).interior) ∈ a ∩ b or s0(a ∩ b, (a ∩ b).interior) ∈ (a ∩ b).interior","not s0(a ∩ b, (a ∩ b).interior) ∈ (a ∩ b).interior or a ∩ b ⊆ (a ∩ b).interior","s0(a ∩ b, (a ∩ b).interior) ∈ a ∩ b or a ∩ b ⊆ (a ∩ b).interior","s0(a ∩ b, (a ∩ b).interior) ∈ a ∩ b","not s0(a ∩ b, (a ∩ b).interior) ∈ (a ∩ b).interior","s0(a ∩ b, (a ∩ b).interior) ∈ (a ∩ b).interior"]}
{"goal":"false","proof":["let s0: Set[X] satisfy { s0 ∈ x.net.sets and s0 ⊆ a }","not s0 ∈ x.net.sets or a.c ∩ s0 != empty[X] or not elem_in_boundary(a, x)","not s0 ⊆ a or s0 ∩ a.c = empty[X]","s0 ∩ a.c = a.c ∩ s0","x ∈ Set.new[X](elem_in_boundary[X](a)) = elem_in_boundary(a, x)","Set.new[X](elem_in_boundary[X](a)) = a.boundary","x ∈ Set.new[X](elem_in_boundary[X](a))","elem_in_boundary(a, x)","s0 ∩ a.c = empty[X]","a.c ∩ s0 = empty[X]","a.c ∩ s0 != empty[X] or not elem_in_boundary(a, x)"]}
{"goal":"false","proof":["let s0: Set[X] satisfy { s0 ∈ x.net.sets and s0 ⊆ a.c }","not s0 ∈ x.net.sets or not elem_in_boundary(a, x) or a ∩ s0 != empty[X]","not s0 ⊆ a.c or s0 ∩ a.c.c = empty[X]","s0 ∩ a = a ∩ s0","x ∈ Set.new[X](elem_in_boundary[X](a)) = elem_in_boundary(a, x)","Set.new[X](elem_in_boundary[X](a)) = a.boundary","a.c.c = a","x ∈ Set.new[X](elem_in_boundary[X](a))","elem_in_boundary(a, x)","s0 ∩ a.c.c = empty[X]","s0 ∩ a = empty[X]","a ∩ s0 != empty[X] or not elem_in_boundary(a, x)","a ∩ s0 = empty[X]","a ∩ s0 != empty[X]"]}
{"goal":"false","proof":["let s0: Set[X] satisfy { s0 ∈ x.net.sets and s0 ⊆ a.c }","not s0 ∈ x.net.sets or not limit_pt(a, x) or a ∩ s0 != empty[X]","not s0 ⊆ a.c or s0 ∩ a.c.c = empty[X]","s0 ∩ a = a ∩ s0","x ∈ Set.new[X](limit_pt[X](a)) = limit_pt(a, x)","Set.new[X](limit_pt[X](a)) = a.closure","a.c.c = a","x ∈ Set.new[X](limit_pt[X](a))","limit_pt(a, x)","s0 ∩ a.c.c = empty[X]","s0 ∩ a = empty[X]","a ∩ s0 != empty[X] or not limit_pt(a, x)","a ∩ s0 = empty[X]","a ∩ s0 != empty[X]"]}
{"goal":"union_index[I, X](f) ⊆ union_index[I, X](f).interior","proof":["let s0: (Set[X], Set[X]) -> X satisfy { forall(x0: Set[X], x1: Set[X], x2: X) { not x0 ⊆ x1 or not x2 ∈ x0 or x2 ∈ x1 } and forall(x3: Set[X], x4: Set[X]) { s0(x3, x4) ∈ x3 or x3 ⊆ x4 } and forall(x5: Set[X], x6: Set[X]) { not s0(x6, x5) ∈ x5 or x6 ⊆ x5 } }","not s0(union_index[I, X](f), union_index[I, X](f).interior) ∈ union_index[I, X](f) or s0(union_index[I, X](f), union_index[I, X](f).interior) ∈ union_index[I, X](f).interior","not s0(union_index[I, X](f), union_index[I, X](f).interior) ∈ union_index[I, X](f).interior or union_index[I, X](f) ⊆ union_index[I, X](f).interior","s0(union_index[I, X](f), union_index[I, X](f).interior) ∈ union_index[I, X](f) or union_index[I, X](f) ⊆ union_index[I, X](f).interior","s0(union_index[I, X](f), union_index[I, X](f).interior) ∈ union_index[I, X](f)","not s0(union_index[I, X](f), union_index[I, X](f).interior) ∈ union_index[I, X](f).interior","s0(union_index[I, X](f), union_index[I, X](f).interior) ∈ union_index[I, X](f).interior"]}
{"goal":"b ∈ x.net.sets implies not b ⊆ a.c","proof":["not b ∈ x.net.sets or not b ⊆ a.c or elem_in_exterior(a, x)","x ∈ Set.new[X](elem_in_exterior[X](a)) = elem_in_exterior(a, x)","Set.new[X](elem_in_exterior[X](a)) = a.exterior","not b ∈ x.net.sets or elem_in_exterior(a, x)","elem_in_exterior(a, x)","not elem_in_exterior(a, x) or x ∈ Set.new[X](elem_in_exterior[X](a))","not x ∈ Set.new[X](elem_in_exterior[X](a))"]}
{"goal":"a.closure = a.exterior.c","proof":["a.exterior.c = a.closure"]}
{"goal":"v.interior.inv_image(f).is_open","proof":["not is_continuous[X, Y](f) or not v.interior.is_open or v.interior.inv_image(f).is_open","not v.interior.is_open","v.interior.is_open"]}
{"goal":"union_index[X, X](open_cover).is_open","proof":["let s0: (X -> Set[X]) -> X satisfy { forall(x0: X -> Set[X]) { not x0(s0(x0)).is_open or union_index[X, X](x0).is_open } }","f(s0(open_cover)) ∈ v or open_cover(s0(open_cover)) = empty[X]","not f(s0(open_cover)) ∈ v or open_cover(s0(open_cover)).is_open","not open_cover(s0(open_cover)).is_open or union_index[X, X](open_cover).is_open","not open_cover(s0(open_cover)).is_open","open_cover(s0(open_cover)) != empty[X] or open_cover(s0(open_cover)).is_empty","not open_cover(s0(open_cover)).is_empty or open_cover(s0(open_cover)).is_open","not open_cover(s0(open_cover)).is_empty","not f(s0(open_cover)) ∈ v","open_cover(s0(open_cover)) != empty[X]","open_cover(s0(open_cover)) = empty[X]"]}
{"goal":"interior_subset","proof":["let s0: (Set[X], Set[X]) -> X satisfy { forall(x0: Set[X], x1: Set[X], x2: X) { not x0 ⊆ x1 or not x2 ∈ x0 or x2 ∈ x1 } and forall(x3: Set[X], x4: Set[X]) { s0(x3, x4) ∈ x3 or x3 ⊆ x4 } and forall(x5: Set[X], x6: Set[X]) { not s0(x6, x5) ∈ x5 or x6 ⊆ x5 } }","not s0(a.interior, a) ∈ a.interior or s0(a.interior, a) ∈ a","not s0(a.interior, a) ∈ a or a.interior ⊆ a","s0(a.interior, a) ∈ a.interior or a.interior ⊆ a","not s0(a.interior, a) ∈ a","s0(a.interior, a) ∈ a.interior","not s0(a.interior, a) ∈ a.interior"]}
{"goal":"sa ∩ sb ⊆ a ∩ b","proof":["not sa ⊆ a or not sb ⊆ b or sa ∩ sb ⊆ a ∩ b"]}
{"goal":"closure_is_smallest_closed_superset","proof":["not a ⊆ b or a.closure ⊆ b.closure","not b.is_closed or b.closure = b","b.closure = b","a.closure ⊆ b.closure","not a.closure ⊆ b.closure"]}
{"goal":"union_index[I, X](f) = union_index[I, X](f).interior","proof":["not union_index[I, X](f).interior ⊇ union_index[I, X](f) or not union_index[I, X](f).interior ⊆ union_index[I, X](f) or union_index[I, X](f).interior = union_index[I, X](f)","union_index[I, X](f).interior ⊇ union_index[I, X](f) = union_index[I, X](f) ⊆ union_index[I, X](f).interior","union_index[I, X](f).interior ⊆ union_index[I, X](f)","union_index[I, X](f).interior ⊇ union_index[I, X](f)","not union_index[I, X](f).interior ⊇ union_index[I, X](f)"]}
{"goal":"union_index[I, X](f).is_open","proof":["union_index[I, X](f).interior != union_index[I, X](f) or union_index[I, X](f).is_open"]}
{"goal":"x ∉ a.interior ∪ a.exterior","proof":["not x ∈ a.interior ∪ a.exterior or x ∈ a.interior or x ∈ a.exterior","x ∉ a.interior ∪ a.exterior != x ∈ a.interior ∪ a.exterior","x ∉ a.interior ∪ a.exterior or x ∈ a.interior ∪ a.exterior","x ∈ a.interior ∪ a.exterior"]}
{"goal":"interior_is_open","proof":["a.c.exterior.c.is_closed = a.c.exterior.is_open","a.c.exterior.c = a.c.closure","a.c.exterior = a.interior","not a.c.exterior.is_open","a.c.closure.is_closed","not a.c.exterior.c.is_closed"]}
{"goal":"x ∈ a.c.exterior","proof":["let s0: Set[X] satisfy { s0 ∈ x.net.sets and s0 ⊆ a }","not s0 ∈ x.net.sets or not s0 ⊆ a.c.c or elem_in_exterior(a.c, x)","x ∈ Set.new[X](elem_in_exterior[X](a.c)) = elem_in_exterior(a.c, x)","Set.new[X](elem_in_exterior[X](a.c)) = a.c.exterior","not x ∈ Set.new[X](elem_in_exterior[X](a.c))","not elem_in_exterior(a.c, x)","a.c.c = a","s0 ⊆ a.c.c","not s0 ⊆ a.c.c or elem_in_exterior(a.c, x)"]}
{"goal":"s.interior = s","proof":["not s.is_open or s.interior = s"]}
{"goal":"b ⊆ union[X](c)","proof":["let s0: (Set[X], Set[X]) -> X satisfy { forall(x0: Set[X], x1: X, x2: Set[X]) { not x1 ∈ x0 or not x0 ⊆ x2 or x1 ∈ x2 } and forall(x3: Set[X], x4: Set[X]) { s0(x3, x4) ∈ x3 or x3 ⊆ x4 } and forall(x5: Set[X], x6: Set[X]) { not s0(x6, x5) ∈ x5 or x6 ⊆ x5 } }","not s0(b, union[X](c)) ∈ s or not s ∈ c or lib(set).elem_in_union_general(c, s0(b, union[X](c)))","not s0(b, union[X](c)) ∈ b or not b ⊆ s or s0(b, union[X](c)) ∈ s","not s0(b, union[X](c)) ∈ union[X](c) or b ⊆ union[X](c)","s0(b, union[X](c)) ∈ b or b ⊆ union[X](c)","s0(b, union[X](c)) ∈ Set.new[X](lib(set).elem_in_union_general[X](c)) = lib(set).elem_in_union_general(c, s0(b, union[X](c)))","s0(b, union[X](c)) ∈ b","Set.new[X](lib(set).elem_in_union_general[X](c)) = union[X](c)","not s0(b, union[X](c)) ∈ union[X](c)","not s0(b, union[X](c)) ∈ b or s0(b, union[X](c)) ∈ s","not s0(b, union[X](c)) ∈ s or lib(set).elem_in_union_general(c, s0(b, union[X](c)))","s0(b, union[X](c)) ∈ s","not s0(b, union[X](c)) ∈ Set.new[X](lib(set).elem_in_union_general[X](c))","lib(set).elem_in_union_general(c, s0(b, union[X](c)))","not lib(set).elem_in_union_general(c, s0(b, union[X](c)))"]}
{"goal":"union_index_preserve_open","proof":[]}
{"goal":"a.boundary ⊆ (a.interior ∪ a.exterior).c","proof":["let s0: (Set[X], Set[X]) -> X satisfy { forall(x0: Set[X], x1: Set[X], x2: X) { not x0 ⊆ x1 or not x2 ∈ x0 or x2 ∈ x1 } and forall(x3: Set[X], x4: Set[X]) { s0(x3, x4) ∈ x3 or x3 ⊆ x4 } and forall(x5: Set[X], x6: Set[X]) { not s0(x6, x5) ∈ x5 or x6 ⊆ x5 } }","not s0(a.boundary, (a.interior ∪ a.exterior).c) ∈ a.boundary or s0(a.boundary, (a.interior ∪ a.exterior).c) ∈ (a.interior ∪ a.exterior).c","not s0(a.boundary, (a.interior ∪ a.exterior).c) ∈ (a.interior ∪ a.exterior).c or a.boundary ⊆ (a.interior ∪ a.exterior).c","s0(a.boundary, (a.interior ∪ a.exterior).c) ∈ a.boundary or a.boundary ⊆ (a.interior ∪ a.exterior).c","s0(a.boundary, (a.interior ∪ a.exterior).c) ∈ a.boundary","not s0(a.boundary, (a.interior ∪ a.exterior).c) ∈ (a.interior ∪ a.exterior).c","s0(a.boundary, (a.interior ∪ a.exterior).c) ∈ (a.interior ∪ a.exterior).c"]}
{"goal":"union[X](c).is_open","proof":["union[X](c).interior != union[X](c) or union[X](c).is_open"]}
{"goal":"v.interior.inv_image(f) ⊆ v.inv_image(f)","proof":["not lib(util).is_transitive[Set[Y]](Set.subset_eq[Y]) or not v.interior.inv_image(f).image(f) ⊆ v.interior or not v.interior ⊆ v or v.interior.inv_image(f).image(f) ⊆ v","v.interior.inv_image(f) ⊆ v.inv_image(f) = v.interior.inv_image(f).image(f) ⊆ v","not v.interior.inv_image(f).image(f) ⊆ v","v.interior.inv_image(f).image(f) ⊆ v.interior","not v.interior.inv_image(f).image(f) ⊆ v.interior or v.interior.inv_image(f).image(f) ⊆ v"]}
{"goal":"subset_two_intersection[X](x.net.sets)","proof":["not is_net[X](x.net.sets) or subset_two_intersection[X](x.net.sets)"]}
{"goal":"x ∈ union_index[X, X](open_cover)","proof":["not x ∈ open_cover(x) or lib(set).or_index(open_cover, x)","x ∈ Set.new[X](lib(set).or_index[X, X](open_cover)) = lib(set).or_index(open_cover, x)","Set.new[X](lib(set).or_index[X, X](open_cover)) = union_index[X, X](open_cover)","not x ∈ Set.new[X](lib(set).or_index[X, X](open_cover))","lib(set).or_index(open_cover, x)","not lib(set).or_index(open_cover, x)"]}
{"goal":"open_iff_compl_closed","proof":["a.c.is_closed or a.is_open","not a.c.is_closed or not a.is_open","not a.is_open","a.c.is_closed","not a.c.is_closed or a.c.c.is_open","a.c.c = a","a.c.c.is_open","not a.c.c.is_open"]}
