{"goal":"comparable(a, b) implies comparable(b, a)","proof":["not comparable(a, b) or a <= b or b <= a","not a <= b or comparable(b, a)","not a <= b","b <= a","not b <= a or comparable(b, a)"]}
{"goal":"comparable_comm","proof":["comparable(b, a) or comparable(a, b)","comparable(b, a)","not comparable(a, b)","not comparable(b, a) or b <= a or a <= b","not b <= a or comparable(a, b)","not a <= b or comparable(a, b)","not a <= b","not b <= a","b <= a"]}
{"goal":"is_chain[P](c)","proof":["not is_chain_extention(c, s) or is_chain[P](c)"]}
{"goal":"s ∉ c","proof":["not is_chain_extention(c, s) or s ∉ c"]}
{"goal":"comparable(s1, s2)","proof":["not is_chain(c) or not s1 ∈ c or not s2 ∈ c or comparable(s1, s2)","not s2 ∈ c or not s1 ∈ c or not is_chain(c)"]}
{"goal":"s2 ∈ Set.singleton(s)","proof":["not s2 ∈ c ∪ Set.singleton(s) or s2 ∈ c or s2 ∈ Set.singleton(s)","not is_chain_extention(c, s) or c ∪ Set.singleton(s) = chain_extension(c, s)","not s2 ∈ c ∪ Set.singleton(s) or s2 ∈ c","not s2 ∈ c ∪ Set.singleton(s)","c ∪ Set.singleton(s) = chain_extension(c, s)"]}
{"goal":"s2 = s","proof":["not s2 ∈ Set.singleton(s) or s2 = s"]}
{"goal":"comparable(s1, s2)","proof":["not is_chain_extention(c, s2) or not s1 ∈ c or comparable(s1, s2)","not is_chain_extention(c, s2) or not s1 ∈ c","is_chain_extention(c, s2)","not is_chain_extention(c, s2)"]}
{"goal":"s1 ∈ Set.singleton(s)","proof":["not s1 ∈ c ∪ Set.singleton(s) or s1 ∈ c or s1 ∈ Set.singleton(s)","not is_chain_extention(c, s) or c ∪ Set.singleton(s) = chain_extension(c, s)","not s1 ∈ c ∪ Set.singleton(s) or s1 ∈ c","not s1 ∈ c ∪ Set.singleton(s)","c ∪ Set.singleton(s) = chain_extension(c, s)"]}
{"goal":"s1 = s","proof":["not s1 ∈ Set.singleton(s) or s1 = s"]}
{"goal":"comparable(s1, s2)","proof":["not is_chain_extention(c, s) or not s2 ∈ c or comparable(s2, s)","comparable(s2, s1) = comparable(s1, s2)","not comparable(s2, s1)","not comparable(s2, s)","not is_chain_extention(c, s) or comparable(s2, s)"]}
{"goal":"s2 ∈ Set.singleton(s)","proof":["not s2 ∈ c ∪ Set.singleton(s) or s2 ∈ c or s2 ∈ Set.singleton(s)","not is_chain_extention(c, s) or c ∪ Set.singleton(s) = chain_extension(c, s)","not s2 ∈ c ∪ Set.singleton(s) or s2 ∈ c","not s2 ∈ c ∪ Set.singleton(s)","c ∪ Set.singleton(s) = chain_extension(c, s)"]}
{"goal":"s2 = s","proof":["not s2 ∈ Set.singleton(s) or s2 = s"]}
{"goal":"comparable(s1, s2)","proof":["not s1 <= s2 or comparable(s1, s2)","not s1 <= s2","not s <= s2","s2 != s or s <= s2"]}
{"goal":"comparable(s1, s2)","proof":["let s0: (Set[ℝ], Set[ℝ]) -> ℝ satisfy { forall(x0: Set[ℝ], x1: ℝ, x2: Set[ℝ]) { not x1 ∈ x0 or not x0 ⊆ x2 or x1 ∈ x2 } and forall(x3: Set[ℝ], x4: Set[ℝ]) { s0(x3, x4) ∈ x3 or x3 ⊆ x4 } and forall(x5: Set[ℝ], x6: Set[ℝ]) { not s0(x6, x5) ∈ x5 or x6 ⊆ x5 } }","not s0(s, s) ∈ s or s ⊆ s","s0(s, s) ∈ s or s ⊆ s","not s2 ⊆ s1 or comparable(s1, s2)","not s2 ⊆ s1","not s ⊆ s1","not s ⊆ s","not s0(s, s) ∈ s","s0(s, s) ∈ s"]}
{"goal":"is_chain[P](chain_extension(c, s))","proof":["let (s0: Set[P] -> P, s1: Set[P] -> P) satisfy { forall(x0: Set[P], x1: P, x2: P) { not is_chain[P](x0) or not x1 ∈ x0 or not x2 ∈ x0 or comparable(x1, x2) } and forall(x3: Set[P]) { s0(x3) ∈ x3 or is_chain[P](x3) } and forall(x4: Set[P]) { s1(x4) ∈ x4 or is_chain[P](x4) } and forall(x5: Set[P]) { not comparable(s0(x5), s1(x5)) or is_chain[P](x5) } }","not s0(chain_extension(c, s)) ∈ chain_extension(c, s) or not s1(chain_extension(c, s)) ∈ chain_extension(c, s) or comparable(s0(chain_extension(c, s)), s1(chain_extension(c, s)))","not comparable(s0(chain_extension(c, s)), s1(chain_extension(c, s))) or is_chain[P](chain_extension(c, s))","s1(chain_extension(c, s)) ∈ chain_extension(c, s) or is_chain[P](chain_extension(c, s))","s0(chain_extension(c, s)) ∈ chain_extension(c, s) or is_chain[P](chain_extension(c, s))","s0(chain_extension(c, s)) ∈ chain_extension(c, s)","s1(chain_extension(c, s)) ∈ chain_extension(c, s)","not comparable(s0(chain_extension(c, s)), s1(chain_extension(c, s)))"]}
{"goal":"s ∈ Set.singleton(s)","proof":["s != s or s ∈ Set.singleton(s)"]}
{"goal":"s ∈ chain_extension(c, s)","proof":["not is_chain_extention(c, s) or c ∪ Set.singleton(s) = chain_extension(c, s)","not s ∈ Set.singleton(s) or s ∈ c ∪ Set.singleton(s)","s ∈ c ∪ Set.singleton(s)","c ∪ Set.singleton(s) = chain_extension(c, s)"]}
{"goal":"s ∉ c","proof":[]}
{"goal":"c ⊆ chain_extension(c, s)","proof":["not is_chain_extention(c, s) or c ∪ Set.singleton(s) = chain_extension(c, s)","not c ∪ Set.singleton(s) ⊆ chain_extension(c, s) or c ⊆ chain_extension(c, s)","c ∪ Set.singleton(s) != chain_extension(c, s) or c ∪ Set.singleton(s) ⊆ chain_extension(c, s)","not c ∪ Set.singleton(s) ⊆ chain_extension(c, s)","c ∪ Set.singleton(s) = chain_extension(c, s)"]}
{"goal":"c ⊂ chain_extension(c, s)","proof":["not c ⊆ chain_extension(c, s) or c ⊂ chain_extension(c, s) or chain_extension(c, s) = c","chain_extension(c, s) = c","s ∈ c","lib(set).negate_fn(c.contains, s) = s ∉ c","lib(set).negate_fn(c.contains, s) != s ∈ c","lib(set).negate_fn(c.contains, s)","not lib(set).negate_fn(c.contains, s) or not s ∈ c"]}
{"goal":"chain_extension_is_chain_extension","proof":["not c ⊂ chain_extension(c, s)"]}
{"goal":"not_maximal_chain_imp","proof":["let s0: Set[P] -> P satisfy { forall(x0: Set[P]) { not is_maximal_chain[P](x0) or is_chain[P](x0) } and forall(x1: Set[P], x2: P) { not is_maximal_chain[P](x1) or not is_chain_extention(x1, x2) } and forall(x3: Set[P]) { not is_chain[P](x3) or is_chain_extention(x3, s0(x3)) or is_maximal_chain[P](x3) } }","not is_chain_extention(c, s0(c))","not is_chain[P](c) or is_chain_extention(c, s0(c)) or is_maximal_chain[P](c)"]}
{"goal":"not_maximal_chain_imp_rev","proof":["let s0: P satisfy { is_chain_extention(c, s0) }","not is_maximal_chain[P](c) or not is_chain_extention(c, s0)"]}
{"goal":"exists(k0: P) { if is_non_maximal_chain[P](c) { is_chain_extention(c, k0) } else { k0 = P.default } }","proof":["let s0: Set[P] -> P satisfy { forall(x0: Set[P]) { not is_chain[P](x0) or is_chain_extention[P](x0, s0(x0)) or is_maximal_chain[P](x0) } }","not is_non_maximal_chain[P](c) or not is_chain_extention(c, s0(c))","P.default != P.default or is_non_maximal_chain[P](c)","is_non_maximal_chain[P](c)","not is_chain_extention(c, s0(c))","not is_chain[P](c) or is_chain_extention(c, s0(c)) or is_maximal_chain[P](c)","not is_non_maximal_chain[P](c) or not is_maximal_chain[P](c)","not is_maximal_chain[P](c)","not is_non_maximal_chain[P](c) or is_chain[P](c)","not is_chain[P](c)","is_chain[P](c)"]}
{"goal":"subchains","proof":["let s0: Set[Set[P]] satisfy { s0 ⊆ cs and not are_chains[P](s0) }","let s1: Set[Set[P]] -> Set[P] satisfy { forall(x0: Set[Set[P]], x1: Set[P]) { not x1 ∈ x0 or not are_chains[P](x0) or is_chain[P](x1) } and forall(x2: Set[Set[P]]) { s1(x2) ∈ x2 or are_chains[P](x2) } and forall(x3: Set[Set[P]]) { not is_chain[P](s1(x3)) or are_chains[P](x3) } }","not s0 ⊆ cs or not s1(s0) ∈ s0 or s1(s0) ∈ cs","not s1(s0) ∈ cs or not are_chains[P](cs) or is_chain[P](s1(s0))","s1(s0) ∈ s0 or are_chains[P](s0)","not is_chain[P](s1(s0)) or are_chains[P](s0)","not is_chain[P](s1(s0))","s1(s0) ∈ s0","not s1(s0) ∈ s0 or s1(s0) ∈ cs","not s1(s0) ∈ cs or is_chain[P](s1(s0))","s1(s0) ∈ cs","not s1(s0) ∈ cs"]}
{"goal":"is_chain_comparable[P](c1, c2) implies is_chain_comparable[P](c2, c1)","proof":["not is_chain_comparable[P](c1, c2) or c1 ⊆ c2 or c2 ⊆ c1","not c1 ⊆ c2 or is_chain_comparable[P](c2, c1)","not c1 ⊆ c2","c2 ⊆ c1","not c2 ⊆ c1 or is_chain_comparable[P](c2, c1)"]}
{"goal":"chain_comparable_comm","proof":["is_chain_comparable[P](c2, c1) or is_chain_comparable[P](c1, c2)","is_chain_comparable[P](c2, c1)","not is_chain_comparable[P](c1, c2)","not is_chain_comparable[P](c2, c1) or c2 ⊆ c1 or c1 ⊆ c2","not c2 ⊆ c1 or is_chain_comparable[P](c1, c2)","not c1 ⊆ c2 or is_chain_comparable[P](c1, c2)","not c1 ⊆ c2","not c2 ⊆ c1","c2 ⊆ c1"]}
{"goal":"sub_chains_of_linear_chains_is_linear","proof":["let (s0: Set[Set[P]] -> Set[P], s1: Set[Set[P]] -> Set[P]) satisfy { forall(x0: Set[Set[P]], x1: Set[P], x2: Set[P]) { not x1 ∈ x0 or not x2 ∈ x0 or not is_linear_chains[P](x0) or is_chain_comparable[P](x1, x2) } and forall(x3: Set[Set[P]]) { s0(x3) ∈ x3 or is_linear_chains[P](x3) } and forall(x4: Set[Set[P]]) { s1(x4) ∈ x4 or is_linear_chains[P](x4) } and forall(x5: Set[Set[P]]) { not is_chain_comparable[P](s0(x5), s1(x5)) or is_linear_chains[P](x5) } }","not s1(ds) ∈ cs or not s0(ds) ∈ cs or not is_linear_chains[P](cs) or is_chain_comparable[P](s1(ds), s0(ds))","not ds ⊆ cs or not s0(ds) ∈ ds or s0(ds) ∈ cs","not ds ⊆ cs or not s1(ds) ∈ ds or s1(ds) ∈ cs","not is_chain_comparable[P](s0(ds), s1(ds)) or is_linear_chains[P](ds)","s1(ds) ∈ ds or is_linear_chains[P](ds)","s0(ds) ∈ ds or is_linear_chains[P](ds)","is_chain_comparable[P](s1(ds), s0(ds)) = is_chain_comparable[P](s0(ds), s1(ds))","s0(ds) ∈ ds","s1(ds) ∈ ds","not is_chain_comparable[P](s0(ds), s1(ds))","not s0(ds) ∈ ds or s0(ds) ∈ cs","not s1(ds) ∈ ds or s1(ds) ∈ cs","not s1(ds) ∈ cs or not s0(ds) ∈ cs or is_chain_comparable[P](s1(ds), s0(ds))","not is_chain_comparable[P](s1(ds), s0(ds))","s1(ds) ∈ cs","s0(ds) ∈ cs","not s0(ds) ∈ cs"]}
{"goal":"exists(k0: Set[P]) { k0 ∈ cs and s1 ∈ k0 }","proof":["let s0: (Set[Set[P]], P) -> Set[P] satisfy { forall(x0: Set[Set[P]], x1: P) { not elem_in_union_general(x0, x1) or s0(x0, x1) ∈ x0 } and forall(x2: Set[Set[P]], x3: P) { not elem_in_union_general(x2, x3) or x3 ∈ s0(x2, x3) } and forall(x4: Set[Set[P]], x5: Set[P], x6: P) { not x5 ∈ x4 or not x6 ∈ x5 or elem_in_union_general(x4, x6) } }","not s0(cs, s1) ∈ cs or not s1 ∈ s0(cs, s1)","not elem_in_union_general(cs, s1) or s0(cs, s1) ∈ cs","not elem_in_union_general(cs, s1) or s1 ∈ s0(cs, s1)","Set.new[P](elem_in_union_general[P](cs)) = union[P](cs)","s1 ∈ Set.new[P](elem_in_union_general[P](cs)) = elem_in_union_general(cs, s1)","s1 ∈ Set.new[P](elem_in_union_general[P](cs))","elem_in_union_general(cs, s1)","s1 ∈ s0(cs, s1)","s0(cs, s1) ∈ cs","not s0(cs, s1) ∈ cs"]}
{"goal":"exists(k0: Set[P]) { k0 ∈ cs and s2 ∈ k0 }","proof":["let s0: (Set[Set[P]], P) -> Set[P] satisfy { forall(x0: Set[Set[P]], x1: P) { not elem_in_union_general(x0, x1) or s0(x0, x1) ∈ x0 } and forall(x2: Set[Set[P]], x3: P) { not elem_in_union_general(x2, x3) or x3 ∈ s0(x2, x3) } and forall(x4: Set[Set[P]], x5: Set[P], x6: P) { not x5 ∈ x4 or not x6 ∈ x5 or elem_in_union_general(x4, x6) } }","not s0(cs, s2) ∈ cs or not s2 ∈ s0(cs, s2)","not elem_in_union_general(cs, s2) or s0(cs, s2) ∈ cs","not elem_in_union_general(cs, s2) or s2 ∈ s0(cs, s2)","Set.new[P](elem_in_union_general[P](cs)) = union[P](cs)","s2 ∈ Set.new[P](elem_in_union_general[P](cs)) = elem_in_union_general(cs, s2)","s2 ∈ Set.new[P](elem_in_union_general[P](cs))","elem_in_union_general(cs, s2)","s2 ∈ s0(cs, s2)","s0(cs, s2) ∈ cs","not s0(cs, s2) ∈ cs"]}
{"goal":"is_chain[P](c1)","proof":["not c1 ∈ cs or not are_chains[P](cs) or is_chain[P](c1)"]}
{"goal":"is_chain[P](c2)","proof":["not c2 ∈ cs or not are_chains[P](cs) or is_chain[P](c2)"]}
{"goal":"c1 ⊆ c2 or c2 ⊆ c1","proof":["not c1 ∈ cs or not c2 ∈ cs or not is_linear_chains[P](cs) or is_chain_comparable[P](c1, c2)","not is_chain_comparable[P](c1, c2) or c1 ⊆ c2 or c2 ⊆ c1","not is_chain_comparable[P](c1, c2)","not c1 ∈ cs or is_chain_comparable[P](c1, c2)"]}
{"goal":"s1 ∈ c2","proof":["not c1 ⊆ c2 or not s1 ∈ c1 or s1 ∈ c2","not c1 ⊆ c2 or not s1 ∈ c1"]}
{"goal":"comparable(s1, s2)","proof":["not s1 ∈ c2 or not s2 ∈ c2 or not is_chain[P](c2) or comparable(s1, s2)","not s2 ∈ c2 or not s1 ∈ c2 or not is_chain[P](c2)"]}
{"goal":"c2 ⊆ c1","proof":[]}
{"goal":"s2 ∈ c1","proof":["not c2 ⊆ c1 or not s2 ∈ c2 or s2 ∈ c1","not c2 ⊆ c1 or not s2 ∈ c2"]}
{"goal":"comparable(s1, s2)","proof":["not s1 ∈ c1 or not s2 ∈ c1 or not is_chain[P](c1) or comparable(s1, s2)","not s2 ∈ c1 or not s1 ∈ c1 or not is_chain[P](c1)"]}
{"goal":"comparable(s1, s2)","proof":[]}
{"goal":"union_linear_chains_is_chain","proof":["let (s0: Set[P] -> P, s1: Set[P] -> P) satisfy { forall(x0: Set[P], x1: P, x2: P) { not x1 ∈ x0 or not x2 ∈ x0 or not is_chain[P](x0) or comparable(x1, x2) } and forall(x3: Set[P]) { s0(x3) ∈ x3 or is_chain[P](x3) } and forall(x4: Set[P]) { s1(x4) ∈ x4 or is_chain[P](x4) } and forall(x5: Set[P]) { not comparable(s0(x5), s1(x5)) or is_chain[P](x5) } }","not s0(union[P](cs)) ∈ union[P](cs) or not s1(union[P](cs)) ∈ union[P](cs) or comparable(s0(union[P](cs)), s1(union[P](cs)))","not comparable(s0(union[P](cs)), s1(union[P](cs))) or is_chain[P](union[P](cs))","s1(union[P](cs)) ∈ union[P](cs) or is_chain[P](union[P](cs))","s0(union[P](cs)) ∈ union[P](cs) or is_chain[P](union[P](cs))","s0(union[P](cs)) ∈ union[P](cs)","s1(union[P](cs)) ∈ union[P](cs)","not comparable(s0(union[P](cs)), s1(union[P](cs)))"]}
{"goal":"c ∈ all_chains[P] implies is_chain[P](c)","proof":["c ∈ Set[P].new(is_chain[P]) = is_chain[P](c)"]}
{"goal":"all_chains_are_chains","proof":["let s0: Set[Set[P]] -> Set[P] satisfy { forall(x0: Set[Set[P]], x1: Set[P]) { not x1 ∈ x0 or not are_chains[P](x0) or is_chain[P](x1) } and forall(x2: Set[Set[P]]) { s0(x2) ∈ x2 or are_chains[P](x2) } and forall(x3: Set[Set[P]]) { not is_chain[P](s0(x3)) or are_chains[P](x3) } }","not s0(all_chains[P]) ∈ all_chains[P] or is_chain[P](s0(all_chains[P]))","s0(all_chains[P]) ∈ all_chains[P] or are_chains[P](all_chains[P])","not is_chain[P](s0(all_chains[P])) or are_chains[P](all_chains[P])","not is_chain[P](s0(all_chains[P]))","s0(all_chains[P]) ∈ all_chains[P]","not s0(all_chains[P]) ∈ all_chains[P]"]}
{"goal":"are_chains[P](all_chains[P])","proof":[]}
{"goal":"Set.empty_set[P] ∈ all_chains[P]","proof":["Set.empty_set[P] ∈ Set[P].new(is_chain[P]) = is_chain[P](Set.empty_set[P])","let  (s0: Set[P] -> P, s1: Set[P] -> P) satisfy { forall(x0: Set[P], x1: P, x2: P) { not is_chain[P](x0) or not x1 ∈ x0 or not x2 ∈ x0 or comparable[P](x1, x2) } and forall(x3: Set[P]) { s0(x3) ∈ x3 or is_chain[P](x3) } and forall(x4: Set[P]) { s1(x4) ∈ x4 or is_chain[P](x4) } and forall(x5: Set[P]) { not comparable[P](s0(x5), s1(x5)) or is_chain[P](x5) } }","s0(Set.empty_set[P]) ∈ Set.empty_set[P] or is_chain[P](Set.empty_set[P])","not s0(Set.empty_set[P]) ∈ Set.empty_set[P] or Set.empty_set[P].is_nonempty","Set.empty_set[P] != Set.empty_set[P] or not Set.empty_set[P].is_nonempty","not Set.empty_set[P].is_nonempty","not Set.empty_set[P] ∈ Set[P].new(is_chain[P])","not is_chain[P](Set.empty_set[P])","s0(Set.empty_set[P]) ∈ Set.empty_set[P]"]}
{"goal":"is_chain[P](c)","proof":["not c ∈ all_chains[P] or not are_chains[P](all_chains[P]) or is_chain[P](c)"]}
{"goal":"is_chain[P](suc[P](c))","proof":["not is_chain_extention(c, chain_extend_fn[P](c)) or is_chain[P](chain_extension(c, chain_extend_fn[P](c)))","chain_extension(c, chain_extend_fn[P](c)) = suc[P](c)","chain_extension(c, chain_extend_fn[P](c)) = c or is_chain_extention(c, chain_extend_fn[P](c))","not is_chain[P](chain_extension(c, chain_extend_fn[P](c)))","not is_chain_extention(c, chain_extend_fn[P](c))","chain_extension(c, chain_extend_fn[P](c)) = c"]}
{"goal":"suc[P](c) ∈ all_chains[P]","proof":["suc[P](c) ∈ Set[P].new(is_chain[P]) = is_chain[P](suc[P](c))"]}
{"goal":"contains_suc[P](all_chains[P])","proof":["let s0: Set[Set[P]] -> Set[P] satisfy { forall(x0: Set[Set[P]], x1: Set[P]) { not x1 ∈ x0 or not contains_suc[P](x0) or suc[P](x1) ∈ x0 } and forall(x2: Set[Set[P]]) { s0(x2) ∈ x2 or contains_suc[P](x2) } and forall(x3: Set[Set[P]]) { not suc[P](s0(x3)) ∈ x3 or contains_suc[P](x3) } }","not s0(all_chains[P]) ∈ all_chains[P] or suc[P](s0(all_chains[P])) ∈ all_chains[P]","not suc[P](s0(all_chains[P])) ∈ all_chains[P] or contains_suc[P](all_chains[P])","s0(all_chains[P]) ∈ all_chains[P] or contains_suc[P](all_chains[P])","s0(all_chains[P]) ∈ all_chains[P]","not suc[P](s0(all_chains[P])) ∈ all_chains[P]","suc[P](s0(all_chains[P])) ∈ all_chains[P]"]}
{"goal":"are_chains[P](all_chains[P])","proof":[]}
{"goal":"are_chains[P](ds)","proof":["not ds ⊆ all_chains[P] or not are_chains[P](all_chains[P]) or are_chains[P](ds)"]}
{"goal":"is_chain[P](union[P](ds))","proof":["not is_linear_chains[P](ds) or not are_chains[P](ds) or is_chain[P](union[P](ds))"]}
{"goal":"union[P](ds) ∈ all_chains[P]","proof":["union[P](ds) ∈ Set[P].new(is_chain[P]) = is_chain[P](union[P](ds))"]}
{"goal":"contains_extension_of_linear_subchains[P](all_chains[P])","proof":["let s0: Set[Set[P]] -> Set[Set[P]] satisfy { forall(x0: Set[Set[P]], x1: Set[Set[P]]) { not x0 ⊆ x1 or not contains_extension_of_linear_subchains[P](x1) or not is_linear_chains[P](x0) or union[P](x0) ∈ x1 } and forall(x2: Set[Set[P]]) { s0(x2) ⊆ x2 or contains_extension_of_linear_subchains[P](x2) } and forall(x3: Set[Set[P]]) { is_linear_chains[P](s0(x3)) or contains_extension_of_linear_subchains[P](x3) } and forall(x4: Set[Set[P]]) { not union[P](s0(x4)) ∈ x4 or contains_extension_of_linear_subchains[P](x4) } }","not s0(all_chains[P]) ⊆ all_chains[P] or not is_linear_chains[P](s0(all_chains[P])) or union[P](s0(all_chains[P])) ∈ all_chains[P]","not union[P](s0(all_chains[P])) ∈ all_chains[P] or contains_extension_of_linear_subchains[P](all_chains[P])","s0(all_chains[P]) ⊆ all_chains[P] or contains_extension_of_linear_subchains[P](all_chains[P])","is_linear_chains[P](s0(all_chains[P])) or contains_extension_of_linear_subchains[P](all_chains[P])","is_linear_chains[P](s0(all_chains[P]))","s0(all_chains[P]) ⊆ all_chains[P]","not union[P](s0(all_chains[P])) ∈ all_chains[P]","union[P](s0(all_chains[P])) ∈ all_chains[P]"]}
{"goal":"all_chains_are_inductive_chain","proof":["not Set.empty_set[P] ∈ all_chains[P] or not contains_suc[P](all_chains[P]) or not contains_extension_of_linear_subchains[P](all_chains[P]) or not are_chains[P](all_chains[P]) or are_inductive_chains[P](all_chains[P])"]}
{"goal":"exists_inductive_chain","proof":["not are_inductive_chains[P](all_chains[P])"]}
{"goal":"smallest_inductive_chains_is_smallest","proof":["let s0: (Set[Set[P]], Set[Set[P]]) -> Set[P] satisfy { forall(x0: Set[Set[P]], x1: Set[Set[P]], x2: Set[P]) { not x0 ⊆ x1 or not x2 ∈ x0 or x2 ∈ x1 } and forall(x3: Set[Set[P]], x4: Set[Set[P]]) { s0(x3, x4) ∈ x3 or x3 ⊆ x4 } and forall(x5: Set[Set[P]], x6: Set[Set[P]]) { not s0(x6, x5) ∈ x5 or x6 ⊆ x5 } }","not s0(smallest_inductive_chains[P], cs) ∈ cs or smallest_inductive_chains[P] ⊆ cs","s0(smallest_inductive_chains[P], cs) ∈ smallest_inductive_chains[P] or smallest_inductive_chains[P] ⊆ cs","not elem_in_smallest_inductive_chains[P](s0(smallest_inductive_chains[P], cs)) or not are_inductive_chains[P](cs) or s0(smallest_inductive_chains[P], cs) ∈ cs","s0(smallest_inductive_chains[P], cs) ∈ Set[P].new(elem_in_smallest_inductive_chains[P]) = elem_in_smallest_inductive_chains[P](s0(smallest_inductive_chains[P], cs))","not s0(smallest_inductive_chains[P], cs) ∈ cs","s0(smallest_inductive_chains[P], cs) ∈ smallest_inductive_chains[P]","not s0(smallest_inductive_chains[P], cs) ∈ Set[P].new(elem_in_smallest_inductive_chains[P]) or elem_in_smallest_inductive_chains[P](s0(smallest_inductive_chains[P], cs))","not elem_in_smallest_inductive_chains[P](s0(smallest_inductive_chains[P], cs))","s0(smallest_inductive_chains[P], cs) ∈ Set[P].new(elem_in_smallest_inductive_chains[P])","not s0(smallest_inductive_chains[P], cs) ∈ Set[P].new(elem_in_smallest_inductive_chains[P])"]}
{"goal":"are_inductive_chains[P](cs) implies Set.empty_set[P] ∈ cs","proof":["not are_inductive_chains[P](cs) or Set.empty_set[P] ∈ cs"]}
{"goal":"smallest_inductive_chains_contains_empty","proof":["Set.empty_set[P] ∈ Set[P].new(elem_in_smallest_inductive_chains[P]) = elem_in_smallest_inductive_chains[P](Set.empty_set[P])","let s0: Set[P] -> Set[Set[P]] satisfy { forall(x0: Set[P], x1: Set[Set[P]]) { not elem_in_smallest_inductive_chains[P](x0) or not are_inductive_chains[P](x1) or x0 ∈ x1 } and forall(x2: Set[P]) { are_inductive_chains[P](s0(x2)) or elem_in_smallest_inductive_chains[P](x2) } and forall(x3: Set[P]) { not x3 ∈ s0(x3) or elem_in_smallest_inductive_chains[P](x3) } }","not are_inductive_chains[P](s0(Set.empty_set[P])) or Set.empty_set[P] ∈ s0(Set.empty_set[P])","not Set.empty_set[P] ∈ s0(Set.empty_set[P]) or elem_in_smallest_inductive_chains[P](Set.empty_set[P])","are_inductive_chains[P](s0(Set.empty_set[P])) or elem_in_smallest_inductive_chains[P](Set.empty_set[P])","not Set.empty_set[P] ∈ Set[P].new(elem_in_smallest_inductive_chains[P])","not elem_in_smallest_inductive_chains[P](Set.empty_set[P])","are_inductive_chains[P](s0(Set.empty_set[P]))","not Set.empty_set[P] ∈ s0(Set.empty_set[P])","Set.empty_set[P] ∈ s0(Set.empty_set[P])"]}
{"goal":"exists(k0: Set[Set[P]]) { c ∈ k0 and are_inductive_chains[P](k0) }","proof":["not c ∈ all_chains[P] or not are_inductive_chains[P](all_chains[P])","not elem_in_smallest_inductive_chains[P](c) or not are_inductive_chains[P](all_chains[P]) or c ∈ all_chains[P]","c ∈ Set[P].new(elem_in_smallest_inductive_chains[P]) = elem_in_smallest_inductive_chains[P](c)","not c ∈ all_chains[P]","c ∈ Set[P].new(elem_in_smallest_inductive_chains[P])","not elem_in_smallest_inductive_chains[P](c)","elem_in_smallest_inductive_chains[P](c)"]}
{"goal":"are_chains[P](cs)","proof":["not are_inductive_chains[P](cs) or are_chains[P](cs)"]}
{"goal":"is_chain[P](c)","proof":["not c ∈ cs or not are_chains[P](cs) or is_chain[P](c)"]}
{"goal":"smallest_inductive_chains_are_chains","proof":["let s0: Set[Set[P]] -> Set[P] satisfy { forall(x0: Set[Set[P]], x1: Set[P]) { not x1 ∈ x0 or not are_chains[P](x0) or is_chain[P](x1) } and forall(x2: Set[Set[P]]) { s0(x2) ∈ x2 or are_chains[P](x2) } and forall(x3: Set[Set[P]]) { not is_chain[P](s0(x3)) or are_chains[P](x3) } }","not s0(smallest_inductive_chains[P]) ∈ smallest_inductive_chains[P] or is_chain[P](s0(smallest_inductive_chains[P]))","s0(smallest_inductive_chains[P]) ∈ smallest_inductive_chains[P] or are_chains[P](smallest_inductive_chains[P])","not is_chain[P](s0(smallest_inductive_chains[P])) or are_chains[P](smallest_inductive_chains[P])","not is_chain[P](s0(smallest_inductive_chains[P]))","s0(smallest_inductive_chains[P]) ∈ smallest_inductive_chains[P]","not s0(smallest_inductive_chains[P]) ∈ smallest_inductive_chains[P]"]}
{"goal":"contains_suc[P](cs)","proof":["not are_inductive_chains[P](cs) or contains_suc[P](cs)"]}
{"goal":"c ∈ cs","proof":["not elem_in_smallest_inductive_chains[P](c) or not are_inductive_chains[P](cs) or c ∈ cs","not elem_in_smallest_inductive_chains[P](c)","c ∈ Set[P].new(elem_in_smallest_inductive_chains[P]) = elem_in_smallest_inductive_chains[P](c)"]}
{"goal":"suc[P](c) ∈ cs","proof":["not c ∈ cs or not contains_suc[P](cs) or suc[P](c) ∈ cs"]}
{"goal":"suc[P](c) ∈ smallest_inductive_chains[P]","proof":["let s0: Set[P] -> Set[Set[P]] satisfy { forall(x0: Set[P], x1: Set[Set[P]]) { not elem_in_smallest_inductive_chains[P](x0) or not are_inductive_chains[P](x1) or x0 ∈ x1 } and forall(x2: Set[P]) { are_inductive_chains[P](s0(x2)) or elem_in_smallest_inductive_chains[P](x2) } and forall(x3: Set[P]) { not x3 ∈ s0(x3) or elem_in_smallest_inductive_chains[P](x3) } }","not are_inductive_chains[P](s0(suc[P](c))) or suc[P](c) ∈ s0(suc[P](c))","suc[P](c) ∈ Set[P].new(elem_in_smallest_inductive_chains[P]) = elem_in_smallest_inductive_chains[P](suc[P](c))","not suc[P](c) ∈ s0(suc[P](c)) or elem_in_smallest_inductive_chains[P](suc[P](c))","are_inductive_chains[P](s0(suc[P](c))) or elem_in_smallest_inductive_chains[P](suc[P](c))","not suc[P](c) ∈ Set[P].new(elem_in_smallest_inductive_chains[P])","not elem_in_smallest_inductive_chains[P](suc[P](c))","are_inductive_chains[P](s0(suc[P](c)))","not suc[P](c) ∈ s0(suc[P](c))","suc[P](c) ∈ s0(suc[P](c))"]}
{"goal":"smallest_inductive_chains_contains_suc","proof":["let s0: Set[Set[P]] -> Set[P] satisfy { forall(x0: Set[Set[P]], x1: Set[P]) { not x1 ∈ x0 or not contains_suc[P](x0) or suc[P](x1) ∈ x0 } and forall(x2: Set[Set[P]]) { s0(x2) ∈ x2 or contains_suc[P](x2) } and forall(x3: Set[Set[P]]) { not suc[P](s0(x3)) ∈ x3 or contains_suc[P](x3) } }","not s0(smallest_inductive_chains[P]) ∈ smallest_inductive_chains[P] or suc[P](s0(smallest_inductive_chains[P])) ∈ smallest_inductive_chains[P]","not suc[P](s0(smallest_inductive_chains[P])) ∈ smallest_inductive_chains[P] or contains_suc[P](smallest_inductive_chains[P])","s0(smallest_inductive_chains[P]) ∈ smallest_inductive_chains[P] or contains_suc[P](smallest_inductive_chains[P])","s0(smallest_inductive_chains[P]) ∈ smallest_inductive_chains[P]","not suc[P](s0(smallest_inductive_chains[P])) ∈ smallest_inductive_chains[P]","suc[P](s0(smallest_inductive_chains[P])) ∈ smallest_inductive_chains[P]"]}
{"goal":"ds ⊆ cs","proof":["not lib(util).is_transitive[Set[Set[P]]](Set[P].subset_eq) or not ds ⊆ smallest_inductive_chains[P] or not smallest_inductive_chains[P] ⊆ cs or ds ⊆ cs","not are_inductive_chains[P](cs) or smallest_inductive_chains[P] ⊆ cs","not smallest_inductive_chains[P] ⊆ cs or not ds ⊆ smallest_inductive_chains[P]","smallest_inductive_chains[P] ⊆ cs","not smallest_inductive_chains[P] ⊆ cs"]}
{"goal":"union[P](ds) ∈ cs","proof":["not ds ⊆ cs or not contains_extension_of_linear_subchains[P](cs) or not is_linear_chains[P](ds) or union[P](ds) ∈ cs","not contains_extension_of_linear_subchains[P](cs)","not are_inductive_chains[P](cs) or contains_extension_of_linear_subchains[P](cs)"]}
{"goal":"union[P](ds) ∈ smallest_inductive_chains[P]","proof":["let s0: Set[P] -> Set[Set[P]] satisfy { forall(x0: Set[P], x1: Set[Set[P]]) { not elem_in_smallest_inductive_chains[P](x0) or not are_inductive_chains[P](x1) or x0 ∈ x1 } and forall(x2: Set[P]) { are_inductive_chains[P](s0(x2)) or elem_in_smallest_inductive_chains[P](x2) } and forall(x3: Set[P]) { not x3 ∈ s0(x3) or elem_in_smallest_inductive_chains[P](x3) } }","not are_inductive_chains[P](s0(union[P](ds))) or union[P](ds) ∈ s0(union[P](ds))","union[P](ds) ∈ Set[P].new(elem_in_smallest_inductive_chains[P]) = elem_in_smallest_inductive_chains[P](union[P](ds))","not union[P](ds) ∈ s0(union[P](ds)) or elem_in_smallest_inductive_chains[P](union[P](ds))","are_inductive_chains[P](s0(union[P](ds))) or elem_in_smallest_inductive_chains[P](union[P](ds))","not union[P](ds) ∈ Set[P].new(elem_in_smallest_inductive_chains[P])","not elem_in_smallest_inductive_chains[P](union[P](ds))","are_inductive_chains[P](s0(union[P](ds)))","not union[P](ds) ∈ s0(union[P](ds))","union[P](ds) ∈ s0(union[P](ds))"]}
{"goal":"smallest_inductive_chains_contains_extension_of_linear_subchains","proof":["let s0: Set[Set[P]] -> Set[Set[P]] satisfy { forall(x0: Set[Set[P]], x1: Set[Set[P]]) { not x0 ⊆ x1 or not contains_extension_of_linear_subchains[P](x1) or not is_linear_chains[P](x0) or union[P](x0) ∈ x1 } and forall(x2: Set[Set[P]]) { s0(x2) ⊆ x2 or contains_extension_of_linear_subchains[P](x2) } and forall(x3: Set[Set[P]]) { is_linear_chains[P](s0(x3)) or contains_extension_of_linear_subchains[P](x3) } and forall(x4: Set[Set[P]]) { not union[P](s0(x4)) ∈ x4 or contains_extension_of_linear_subchains[P](x4) } }","not s0(smallest_inductive_chains[P]) ⊆ smallest_inductive_chains[P] or not is_linear_chains[P](s0(smallest_inductive_chains[P])) or union[P](s0(smallest_inductive_chains[P])) ∈ smallest_inductive_chains[P]","not union[P](s0(smallest_inductive_chains[P])) ∈ smallest_inductive_chains[P] or contains_extension_of_linear_subchains[P](smallest_inductive_chains[P])","s0(smallest_inductive_chains[P]) ⊆ smallest_inductive_chains[P] or contains_extension_of_linear_subchains[P](smallest_inductive_chains[P])","is_linear_chains[P](s0(smallest_inductive_chains[P])) or contains_extension_of_linear_subchains[P](smallest_inductive_chains[P])","is_linear_chains[P](s0(smallest_inductive_chains[P]))","s0(smallest_inductive_chains[P]) ⊆ smallest_inductive_chains[P]","not union[P](s0(smallest_inductive_chains[P])) ∈ smallest_inductive_chains[P]","union[P](s0(smallest_inductive_chains[P])) ∈ smallest_inductive_chains[P]"]}
{"goal":"smallest_inductive_chains_are_inductive_chains","proof":["not Set.empty_set[P] ∈ smallest_inductive_chains[P] or not contains_suc[P](smallest_inductive_chains[P]) or not contains_extension_of_linear_subchains[P](smallest_inductive_chains[P]) or not are_chains[P](smallest_inductive_chains[P]) or are_inductive_chains[P](smallest_inductive_chains[P])","not are_chains[P](smallest_inductive_chains[P])"]}
{"goal":"empty_is_comparable_chain","proof":["let s0: Set[P] -> Set[P] satisfy { forall(x0: Set[P]) { not is_comparable_chain[P](x0) or x0 ∈ smallest_inductive_chains[P] } and forall(x1: Set[P], x2: Set[P]) { not x1 ∈ smallest_inductive_chains[P] or not is_comparable_chain[P](x2) or is_chain_comparable[P](x2, x1) } and forall(x3: Set[P]) { not x3 ∈ smallest_inductive_chains[P] or s0(x3) ∈ smallest_inductive_chains[P] or is_comparable_chain[P](x3) } and forall(x4: Set[P]) { not x4 ∈ smallest_inductive_chains[P] or not is_chain_comparable[P](x4, s0(x4)) or is_comparable_chain[P](x4) } }","not Set.empty_set[P] ∈ smallest_inductive_chains[P] or not is_chain_comparable[P](Set.empty_set[P], s0(Set.empty_set[P])) or is_comparable_chain[P](Set.empty_set[P])","not empty[P] ⊆ s0(Set.empty_set[P]) or is_chain_comparable[P](empty[P], s0(Set.empty_set[P]))","empty[P] ⊆ s0(Set.empty_set[P])","not is_chain_comparable[P](Set.empty_set[P], s0(Set.empty_set[P]))","not is_chain_comparable[P](empty[P], s0(Set.empty_set[P]))"]}
{"goal":"exists(k0: P) { k0 ∈ c and k0 ∉ a }","proof":["let s0: (Set[P], Set[P]) -> P satisfy { forall(x0: Set[P], x1: Set[P]) { not x0 ⊂ x1 or s0(x0, x1) ∈ x1 } and forall(x2: Set[P], x3: Set[P]) { not x2 ⊂ x3 or s0(x2, x3) ∉ x2 } }","not s0(a, c) ∉ a or not s0(a, c) ∈ c","not a ⊂ c or s0(a, c) ∉ a","not a ⊂ c or s0(a, c) ∈ c","s0(a, c) ∈ c","s0(a, c) ∉ a","not s0(a, c) ∉ a"]}
{"goal":"is_chain_extention(a, s)","proof":["let s0: (Set[P], P) -> P satisfy { forall(x0: Set[P], x1: P) { not is_chain_extention(x0, x1) or is_chain[P](x0) } and forall(x2: Set[P], x3: P) { not is_chain_extention(x2, x3) or x3 ∉ x2 } and forall(x4: Set[P], x5: P, x6: P) { not is_chain_extention(x4, x5) or not x6 ∈ x4 or comparable(x6, x5) } and forall(x7: Set[P], x8: P) { not is_chain[P](x7) or not x8 ∉ x7 or s0(x7, x8) ∈ x7 or is_chain_extention(x7, x8) } and forall(x9: Set[P], x10: P) { not comparable(s0(x9, x10), x10) or not is_chain[P](x9) or not x10 ∉ x9 or is_chain_extention(x9, x10) } }","not comparable(s0(a, s), s) or not is_chain[P](a) or not s ∉ a or is_chain_extention(a, s)","not is_chain[P](a) or not s ∉ a or s0(a, s) ∈ a or is_chain_extention(a, s)","not is_chain[P](c) or not s0(a, s) ∈ c or not s ∈ c or comparable(s0(a, s), s)","not s0(a, s) ∈ a or s0(a, s) ∈ a ∪ c","not a ∈ smallest_inductive_chains[P] or not are_chains[P](smallest_inductive_chains[P]) or is_chain[P](a)","not c ∈ smallest_inductive_chains[P] or not are_chains[P](smallest_inductive_chains[P]) or is_chain[P](c)","not is_comparable_chain[P](c) or c ∈ smallest_inductive_chains[P]","not a ⊆ c or a ∪ c = c","not a ⊂ c or a ⊆ c","is_chain[P](a)","s0(a, s) ∈ a","not comparable(s0(a, s), s)","a ⊆ c","c ∈ smallest_inductive_chains[P]","not is_chain[P](c) or not s0(a, s) ∈ c or comparable(s0(a, s), s)","is_chain[P](c)","a ∪ c = c","s0(a, s) ∈ a ∪ c","not s0(a, s) ∈ c"]}
{"goal":"is_non_maximal_chain[P](a)","proof":["not a ∈ smallest_inductive_chains[P] or not are_chains[P](smallest_inductive_chains[P]) or is_chain[P](a)","not is_chain[P](a) or is_non_maximal_chain[P](a) or is_maximal_chain[P](a)","not is_maximal_chain[P](a) or not is_chain_extention(a, s)","not is_chain[P](a) or is_maximal_chain[P](a)","is_chain[P](a)","not is_maximal_chain[P](a)","is_maximal_chain[P](a)"]}
{"goal":"c ⊂ suc[P](a)","proof":["not a ∈ smallest_inductive_chains[P] or not contains_suc[P](smallest_inductive_chains[P]) or suc[P](a) ∈ smallest_inductive_chains[P]","not suc[P](a) ∈ smallest_inductive_chains[P] or not is_comparable_chain[P](c) or is_chain_comparable[P](c, suc[P](a))","not is_chain_comparable[P](c, suc[P](a)) or c ⊆ suc[P](a) or suc[P](a) ⊆ c","not c ⊆ suc[P](a) or c ⊂ suc[P](a) or suc[P](a) = c","suc[P](a) != c or suc[P](a) ⊆ c","suc[P](a) != c","not c ⊆ suc[P](a)","not is_chain_comparable[P](c, suc[P](a))","suc[P](a) ∈ smallest_inductive_chains[P]","not suc[P](a) ∈ smallest_inductive_chains[P]"]}
{"goal":"exists(k0: P) { k0 ∈ suc[P](a) and k0 ∉ c }","proof":["let s0: (Set[P], Set[P]) -> P satisfy { forall(x0: Set[P], x1: Set[P]) { not x0 ⊂ x1 or s0(x0, x1) ∈ x1 } and forall(x2: Set[P], x3: Set[P]) { not x2 ⊂ x3 or s0(x2, x3) ∉ x2 } }","not s0(c, suc[P](a)) ∈ suc[P](a) or not s0(c, suc[P](a)) ∉ c","not c ⊂ suc[P](a) or s0(c, suc[P](a)) ∉ c","not c ⊂ suc[P](a) or s0(c, suc[P](a)) ∈ suc[P](a)","s0(c, suc[P](a)) ∉ c","s0(c, suc[P](a)) ∈ suc[P](a)","not s0(c, suc[P](a)) ∈ suc[P](a)"]}
{"goal":"t ∈ c","proof":["not a ⊆ c or not t ∈ a or t ∈ c","not a ⊂ c or a ⊆ c","not a ⊆ c or not t ∈ a","a ⊆ c","not a ⊆ c"]}
{"goal":"false","proof":["t ∉ c != t ∈ c","not t ∉ c or not t ∈ c"]}
{"goal":"not t ∈ a","proof":[]}
{"goal":"suc[P](a) = a ∪ Set.singleton(chain_extend_fn[P](a))","proof":["not is_chain_extention(a, chain_extend_fn[P](a)) or a ∪ Set.singleton(chain_extend_fn[P](a)) = chain_extension(a, chain_extend_fn[P](a))","chain_extension(a, chain_extend_fn[P](a)) = suc[P](a)","not is_non_maximal_chain[P](a) or is_chain_extention(a, chain_extend_fn[P](a))","is_chain_extention(a, chain_extend_fn[P](a))","a ∪ Set.singleton(chain_extend_fn[P](a)) != chain_extension(a, chain_extend_fn[P](a))","a ∪ Set.singleton(chain_extend_fn[P](a)) = chain_extension(a, chain_extend_fn[P](a))"]}
{"goal":"c ⊂ a ∪ Set.singleton(chain_extend_fn[P](a))","proof":[]}
{"goal":"t ∈ Set.singleton(chain_extend_fn[P](a))","proof":["not t ∈ a ∪ Set.singleton(chain_extend_fn[P](a)) or t ∈ a or t ∈ Set.singleton(chain_extend_fn[P](a))","not t ∈ a ∪ Set.singleton(chain_extend_fn[P](a)) or t ∈ a","t ∈ a ∪ Set.singleton(chain_extend_fn[P](a))","not t ∈ a ∪ Set.singleton(chain_extend_fn[P](a))"]}
{"goal":"t = chain_extend_fn[P](a)","proof":["not t ∈ Set.singleton(chain_extend_fn[P](a)) or chain_extend_fn[P](a) = t"]}
{"goal":"c ⊂ a ∪ Set.singleton(t)","proof":["not c ⊂ a ∪ Set.singleton(chain_extend_fn[P](a))"]}
{"goal":"u != t","proof":["t ∈ c","t ∉ c != t ∈ c","not t ∉ c or not t ∈ c"]}
{"goal":"u ∉ Set.singleton(t)","proof":["not u ∈ Set.singleton(chain_extend_fn[P](a)) or chain_extend_fn[P](a) = u","u ∉ Set.singleton(chain_extend_fn[P](a)) != u ∈ Set.singleton(chain_extend_fn[P](a))","not u ∉ Set.singleton(chain_extend_fn[P](a))","chain_extend_fn[P](a) != u","u ∉ Set.singleton(chain_extend_fn[P](a)) or u ∈ Set.singleton(chain_extend_fn[P](a))","not u ∈ Set.singleton(chain_extend_fn[P](a))","u ∈ Set.singleton(chain_extend_fn[P](a))"]}
{"goal":"u ∈ a","proof":["not u ∈ a ∪ Set.singleton(t) or u ∈ a or u ∈ Set.singleton(t)","not c ⊆ a ∪ Set.singleton(t) or not u ∈ c or u ∈ a ∪ Set.singleton(t)","not u ∈ Set.singleton(t) or u = t","not c ⊂ a ∪ Set.singleton(t) or c ⊆ a ∪ Set.singleton(t)","not u ∈ a ∪ Set.singleton(t) or u ∈ Set.singleton(t)","not u ∈ Set.singleton(t)","not c ⊆ a ∪ Set.singleton(t) or u ∈ a ∪ Set.singleton(t)","c ⊆ a ∪ Set.singleton(t)","not u ∈ a ∪ Set.singleton(t)","u ∈ a ∪ Set.singleton(t)"]}
{"goal":"c ⊂ a","proof":["let s0: P satisfy { s0 ∈ c and s0 ∉ a }","not s0 ∈ c or s0 ∈ a","s0 ∉ a != s0 ∈ a","s0 ∈ a","not s0 ∉ a or not s0 ∈ a"]}
{"goal":"false","proof":["not lib(util).is_acyclic[Set[P]](Set.subset[P]) or not a ⊂ c or not c ⊂ a","not lib(util).is_acyclic[Set[P]](Set.subset[P])"]}
{"goal":"inductive_compare_subset_not_eq","proof":[]}
{"goal":"inductive_compare_subset","proof":["let s0: (Set[Set[P]], Set[Set[P]]) -> Set[P] satisfy { forall(x0: Set[Set[P]], x1: Set[Set[P]], x2: Set[P]) { not x0 ⊆ x1 or not x2 ∈ x0 or x2 ∈ x1 } and forall(x3: Set[Set[P]], x4: Set[Set[P]]) { s0(x3, x4) ∈ x3 or x3 ⊆ x4 } and forall(x5: Set[Set[P]], x6: Set[Set[P]]) { not s0(x6, x5) ∈ x5 or x6 ⊆ x5 } }","not s0(suc_compare[P](c), smallest_inductive_chains[P]) ∈ smallest_inductive_chains[P] or suc_compare[P](c) ⊆ smallest_inductive_chains[P]","s0(suc_compare[P](c), smallest_inductive_chains[P]) ∈ suc_compare[P](c) or suc_compare[P](c) ⊆ smallest_inductive_chains[P]","not elem_in_suc_compare[P](c, s0(suc_compare[P](c), smallest_inductive_chains[P])) or s0(suc_compare[P](c), smallest_inductive_chains[P]) ∈ smallest_inductive_chains[P]","s0(suc_compare[P](c), smallest_inductive_chains[P]) ∈ Set[P].new(elem_in_suc_compare[P](c)) = elem_in_suc_compare[P](c, s0(suc_compare[P](c), smallest_inductive_chains[P]))","Set[P].new(elem_in_suc_compare[P](c)) = suc_compare[P](c)","not s0(suc_compare[P](c), smallest_inductive_chains[P]) ∈ Set[P].new(elem_in_suc_compare[P](c)) or elem_in_suc_compare[P](c, s0(suc_compare[P](c), smallest_inductive_chains[P]))","not s0(suc_compare[P](c), smallest_inductive_chains[P]) ∈ smallest_inductive_chains[P]","s0(suc_compare[P](c), smallest_inductive_chains[P]) ∈ suc_compare[P](c)","not elem_in_suc_compare[P](c, s0(suc_compare[P](c), smallest_inductive_chains[P]))","s0(suc_compare[P](c), smallest_inductive_chains[P]) ∈ Set[P].new(elem_in_suc_compare[P](c))"]}
{"goal":"are_chains[P](suc_compare[P](c))","proof":["not suc_compare[P](c) ⊆ smallest_inductive_chains[P] or not are_chains[P](smallest_inductive_chains[P]) or are_chains[P](suc_compare[P](c))","suc_compare[P](c) ⊆ smallest_inductive_chains[P]","not suc_compare[P](c) ⊆ smallest_inductive_chains[P] or not are_chains[P](smallest_inductive_chains[P])"]}
{"goal":"Set.empty_set[P] ⊆ c","proof":["empty[P] ⊆ c"]}
{"goal":"Set.empty_set[P] ∈ suc_compare[P](c)","proof":["not Set.empty_set[P] ∈ smallest_inductive_chains[P] or not is_comparable_chain[P](c) or not Set.empty_set[P] ⊆ c or elem_in_suc_compare[P](c, Set.empty_set[P])","Set.empty_set[P] ∈ Set[P].new(elem_in_suc_compare[P](c)) = elem_in_suc_compare[P](c, Set.empty_set[P])","Set[P].new(elem_in_suc_compare[P](c)) = suc_compare[P](c)","elem_in_suc_compare[P](c, Set.empty_set[P])","not elem_in_suc_compare[P](c, Set.empty_set[P]) or Set.empty_set[P] ∈ Set[P].new(elem_in_suc_compare[P](c))","not Set.empty_set[P] ∈ Set[P].new(elem_in_suc_compare[P](c))","Set.empty_set[P] ∈ Set[P].new(elem_in_suc_compare[P](c))"]}
{"goal":"a ∈ smallest_inductive_chains[P]","proof":["not suc_compare[P](c) ⊆ smallest_inductive_chains[P] or not a ∈ suc_compare[P](c) or a ∈ smallest_inductive_chains[P]","suc_compare[P](c) ⊆ smallest_inductive_chains[P]","not suc_compare[P](c) ⊆ smallest_inductive_chains[P] or not a ∈ suc_compare[P](c)"]}
{"goal":"suc[P](a) ∈ smallest_inductive_chains[P]","proof":["not a ∈ smallest_inductive_chains[P] or not contains_suc[P](smallest_inductive_chains[P]) or suc[P](a) ∈ smallest_inductive_chains[P]","not contains_suc[P](smallest_inductive_chains[P])"]}
{"goal":"suc[P](a) ⊆ c","proof":["not a ∈ smallest_inductive_chains[P] or not is_comparable_chain[P](c) or not a ⊂ c or suc[P](a) ⊆ c"]}
{"goal":"suc[P](a) ∈ suc_compare[P](c)","proof":["not suc[P](a) ∈ smallest_inductive_chains[P] or not is_comparable_chain[P](c) or not suc[P](a) ⊆ c or elem_in_suc_compare[P](c, suc[P](a))","suc[P](a) ∈ Set[P].new(elem_in_suc_compare[P](c)) = elem_in_suc_compare[P](c, suc[P](a))","Set[P].new(elem_in_suc_compare[P](c)) = suc_compare[P](c)","not suc[P](a) ∈ Set[P].new(elem_in_suc_compare[P](c))","elem_in_suc_compare[P](c, suc[P](a))","not elem_in_suc_compare[P](c, suc[P](a))"]}
{"goal":"suc[P](a) = suc[P](c)","proof":["a != c"]}
{"goal":"suc[P](c) ⊆ suc[P](a)","proof":["not suc[P](c) ⊆ suc[P](c)","let s0: (Set[P], Set[P]) -> P satisfy { forall(x0: Set[P], x1: Set[P], x2: P) { not x0 ⊆ x1 or not x2 ∈ x0 or x2 ∈ x1 } and forall(x3: Set[P], x4: Set[P]) { s0(x3, x4) ∈ x3 or x3 ⊆ x4 } and forall(x5: Set[P], x6: Set[P]) { not s0(x6, x5) ∈ x5 or x6 ⊆ x5 } }","not s0(suc[P](c), suc[P](c)) ∈ suc[P](c) or suc[P](c) ⊆ suc[P](c)","s0(suc[P](c), suc[P](c)) ∈ suc[P](c) or suc[P](c) ⊆ suc[P](c)","not s0(suc[P](c), suc[P](c)) ∈ suc[P](c)","s0(suc[P](c), suc[P](c)) ∈ suc[P](c)"]}
{"goal":"suc[P](a) ∈ suc_compare[P](c)","proof":["not suc[P](a) ∈ smallest_inductive_chains[P] or not suc[P](c) ⊆ suc[P](a) or not is_comparable_chain[P](c) or elem_in_suc_compare[P](c, suc[P](a))","suc[P](a) ∈ Set[P].new(elem_in_suc_compare[P](c)) = elem_in_suc_compare[P](c, suc[P](a))","Set[P].new(elem_in_suc_compare[P](c)) = suc_compare[P](c)","not suc[P](a) ∈ Set[P].new(elem_in_suc_compare[P](c))","elem_in_suc_compare[P](c, suc[P](a))","not elem_in_suc_compare[P](c, suc[P](a))"]}
{"goal":"suc[P](c) ⊆ a","proof":["not elem_in_suc_compare[P](c, a) or suc[P](c) ⊆ a or a ⊆ c","not a ⊆ c or a ⊂ c or a = c","a ∈ Set[P].new(elem_in_suc_compare[P](c)) = elem_in_suc_compare[P](c, a)","Set[P].new(elem_in_suc_compare[P](c)) = suc_compare[P](c)","not elem_in_suc_compare[P](c, a) or a ⊆ c","not a ⊆ c","not elem_in_suc_compare[P](c, a)","not a ∈ Set[P].new(elem_in_suc_compare[P](c)) or elem_in_suc_compare[P](c, a)","a ∈ Set[P].new(elem_in_suc_compare[P](c))","not a ∈ Set[P].new(elem_in_suc_compare[P](c))"]}
{"goal":"a ⊆ suc[P](a)","proof":["not is_chain_extention(a, chain_extend_fn[P](a)) or a ⊂ chain_extension(a, chain_extend_fn[P](a))","chain_extension(a, chain_extend_fn[P](a)) = suc[P](a)","chain_extension(a, chain_extend_fn[P](a)) = a or is_chain_extention(a, chain_extend_fn[P](a))","not a ⊂ chain_extension(a, chain_extend_fn[P](a)) or a ⊆ chain_extension(a, chain_extend_fn[P](a))","chain_extension(a, chain_extend_fn[P](a)) != a or a ⊆ chain_extension(a, chain_extend_fn[P](a))","not a ⊆ chain_extension(a, chain_extend_fn[P](a))","chain_extension(a, chain_extend_fn[P](a)) != a","not a ⊂ chain_extension(a, chain_extend_fn[P](a))","is_chain_extention(a, chain_extend_fn[P](a))","not is_chain_extention(a, chain_extend_fn[P](a))"]}
{"goal":"suc[P](c) ⊆ suc[P](a)","proof":["not lib(util).is_transitive[Set[P]](Set.subset_eq[P]) or not suc[P](c) ⊆ a or not a ⊆ suc[P](a) or suc[P](c) ⊆ suc[P](a)","not a ⊆ suc[P](a) or not suc[P](c) ⊆ a"]}
{"goal":"suc[P](a) ∈ suc_compare[P](c)","proof":["not suc[P](a) ∈ smallest_inductive_chains[P] or not suc[P](c) ⊆ suc[P](a) or not is_comparable_chain[P](c) or elem_in_suc_compare[P](c, suc[P](a))","suc[P](a) ∈ Set[P].new(elem_in_suc_compare[P](c)) = elem_in_suc_compare[P](c, suc[P](a))","Set[P].new(elem_in_suc_compare[P](c)) = suc_compare[P](c)","not suc[P](a) ∈ Set[P].new(elem_in_suc_compare[P](c))","elem_in_suc_compare[P](c, suc[P](a))","not elem_in_suc_compare[P](c, suc[P](a))"]}
{"goal":"suc[P](a) ∈ suc_compare[P](c)","proof":["not suc[P](a) ∈ smallest_inductive_chains[P] or not is_comparable_chain[P](c) or not suc[P](a) ⊆ c or elem_in_suc_compare[P](c, suc[P](a))","suc[P](a) ∈ Set[P].new(elem_in_suc_compare[P](c)) = elem_in_suc_compare[P](c, suc[P](a))","Set[P].new(elem_in_suc_compare[P](c)) = suc_compare[P](c)","not suc[P](a) ∈ Set[P].new(elem_in_suc_compare[P](c))","elem_in_suc_compare[P](c, suc[P](a))","not elem_in_suc_compare[P](c, suc[P](a))"]}
{"goal":"suc[P](a) ∈ suc_compare[P](c)","proof":["not suc[P](a) ∈ smallest_inductive_chains[P] or not suc[P](c) ⊆ suc[P](a) or not is_comparable_chain[P](c) or elem_in_suc_compare[P](c, suc[P](a))","suc[P](a) ∈ Set[P].new(elem_in_suc_compare[P](c)) = elem_in_suc_compare[P](c, suc[P](a))","Set[P].new(elem_in_suc_compare[P](c)) = suc_compare[P](c)","not suc[P](a) ∈ Set[P].new(elem_in_suc_compare[P](c))","elem_in_suc_compare[P](c, suc[P](a))","not elem_in_suc_compare[P](c, suc[P](a))"]}
{"goal":"contains_suc[P](suc_compare[P](c))","proof":["let s0: Set[Set[P]] -> Set[P] satisfy { forall(x0: Set[Set[P]], x1: Set[P]) { not x1 ∈ x0 or not contains_suc[P](x0) or suc[P](x1) ∈ x0 } and forall(x2: Set[Set[P]]) { s0(x2) ∈ x2 or contains_suc[P](x2) } and forall(x3: Set[Set[P]]) { not suc[P](s0(x3)) ∈ x3 or contains_suc[P](x3) } }","not s0(suc_compare[P](c)) ∈ suc_compare[P](c) or suc[P](s0(suc_compare[P](c))) ∈ suc_compare[P](c)","not suc[P](s0(suc_compare[P](c))) ∈ suc_compare[P](c) or contains_suc[P](suc_compare[P](c))","s0(suc_compare[P](c)) ∈ suc_compare[P](c) or contains_suc[P](suc_compare[P](c))","s0(suc_compare[P](c)) ∈ suc_compare[P](c)","not suc[P](s0(suc_compare[P](c))) ∈ suc_compare[P](c)","suc[P](s0(suc_compare[P](c))) ∈ suc_compare[P](c)"]}
{"goal":"suc_compare[P](c) ⊆ smallest_inductive_chains[P]","proof":["suc_compare[P](c) ⊆ smallest_inductive_chains[P]"]}
{"goal":"ds ⊆ smallest_inductive_chains[P]","proof":["not ds ⊆ suc_compare[P](c) or not suc_compare[P](c) ⊆ smallest_inductive_chains[P] or ds ⊆ smallest_inductive_chains[P]","not suc_compare[P](c) ⊆ smallest_inductive_chains[P] or not ds ⊆ suc_compare[P](c)"]}
{"goal":"union[P](ds) ∈ smallest_inductive_chains[P]","proof":["not ds ⊆ smallest_inductive_chains[P] or not contains_extension_of_linear_subchains[P](smallest_inductive_chains[P]) or not is_linear_chains[P](ds) or union[P](ds) ∈ smallest_inductive_chains[P]","not contains_extension_of_linear_subchains[P](smallest_inductive_chains[P])"]}
{"goal":"elem_in_union_general(ds, a)","proof":["Set.new[P](elem_in_union_general[P](ds)) = union[P](ds)","a ∈ Set.new[P](elem_in_union_general[P](ds)) = elem_in_union_general(ds, a)"]}
{"goal":"exists(k0: Set[P]) { k0 ∈ ds and a ∈ k0 }","proof":["let s0: (Set[Set[P]], P) -> Set[P] satisfy { forall(x0: Set[Set[P]], x1: P) { not elem_in_union_general(x0, x1) or s0(x0, x1) ∈ x0 } and forall(x2: Set[Set[P]], x3: P) { not elem_in_union_general(x2, x3) or x3 ∈ s0(x2, x3) } and forall(x4: Set[Set[P]], x5: Set[P], x6: P) { not x5 ∈ x4 or not x6 ∈ x5 or elem_in_union_general(x4, x6) } }","not s0(ds, a) ∈ ds or not a ∈ s0(ds, a)","not elem_in_union_general(ds, a) or s0(ds, a) ∈ ds","not elem_in_union_general(ds, a) or a ∈ s0(ds, a)","a ∈ s0(ds, a)","s0(ds, a) ∈ ds","not s0(ds, a) ∈ ds"]}
{"goal":"d ∈ suc_compare[P](c)","proof":["not ds ⊆ suc_compare[P](c) or not d ∈ ds or d ∈ suc_compare[P](c)","not ds ⊆ suc_compare[P](c) or not d ∈ ds"]}
{"goal":"d ⊆ c or suc[P](c) ⊆ d","proof":["not elem_in_suc_compare[P](c, d) or suc[P](c) ⊆ d or d ⊆ c","not elem_in_suc_compare[P](c, d)","d ∈ Set[P].new(elem_in_suc_compare[P](c)) = elem_in_suc_compare[P](c, d)","Set[P].new(elem_in_suc_compare[P](c)) = suc_compare[P](c)"]}
{"goal":"d ⊆ union[P](ds)","proof":["not d ∈ ds or d ⊆ union[P](ds)"]}
{"goal":"a ∈ c or suc[P](c) ⊆ union[P](ds)","proof":["not lib(util).is_transitive[Set[P]](Set.subset_eq[P]) or not suc[P](c) ⊆ d or not d ⊆ union[P](ds) or suc[P](c) ⊆ union[P](ds)","not d ⊆ c or not a ∈ d or a ∈ c","not d ⊆ c or not a ∈ d","not d ⊆ c","suc[P](c) ⊆ d","not suc[P](c) ⊆ d or not d ⊆ union[P](ds)"]}
{"goal":"union[P](ds) ⊆ c or suc[P](c) ⊆ union[P](ds)","proof":["let s0: (Set[P], Set[P]) -> P satisfy { forall(x0: Set[P], x1: Set[P], x2: P) { not x0 ⊆ x1 or not x2 ∈ x0 or x2 ∈ x1 } and forall(x3: Set[P], x4: Set[P]) { s0(x3, x4) ∈ x3 or x3 ⊆ x4 } and forall(x5: Set[P], x6: Set[P]) { not s0(x6, x5) ∈ x5 or x6 ⊆ x5 } }","not s0(union[P](ds), c) ∈ union[P](ds) or suc[P](c) ⊆ union[P](ds) or s0(union[P](ds), c) ∈ c","not s0(union[P](ds), c) ∈ union[P](ds) or s0(union[P](ds), c) ∈ c","not s0(union[P](ds), c) ∈ c or union[P](ds) ⊆ c","s0(union[P](ds), c) ∈ union[P](ds) or union[P](ds) ⊆ c","not s0(union[P](ds), c) ∈ c","s0(union[P](ds), c) ∈ union[P](ds)","not s0(union[P](ds), c) ∈ union[P](ds)"]}
{"goal":"union[P](ds) ∈ suc_compare[P](c)","proof":["not union[P](ds) ∈ smallest_inductive_chains[P] or not is_comparable_chain[P](c) or not union[P](ds) ⊆ c or elem_in_suc_compare[P](c, union[P](ds))","not union[P](ds) ∈ smallest_inductive_chains[P] or not suc[P](c) ⊆ union[P](ds) or not is_comparable_chain[P](c) or elem_in_suc_compare[P](c, union[P](ds))","union[P](ds) ∈ Set[P].new(elem_in_suc_compare[P](c)) = elem_in_suc_compare[P](c, union[P](ds))","Set[P].new(elem_in_suc_compare[P](c)) = suc_compare[P](c)","not union[P](ds) ∈ Set[P].new(elem_in_suc_compare[P](c))","not elem_in_suc_compare[P](c, union[P](ds))","not union[P](ds) ∈ smallest_inductive_chains[P] or not union[P](ds) ⊆ c or elem_in_suc_compare[P](c, union[P](ds))","not union[P](ds) ⊆ c","not suc[P](c) ⊆ union[P](ds)","suc[P](c) ⊆ union[P](ds)"]}
{"goal":"contains_extension_of_linear_subchains[P](suc_compare[P](c))","proof":["let s0: Set[Set[P]] -> Set[Set[P]] satisfy { forall(x0: Set[Set[P]], x1: Set[Set[P]]) { not x0 ⊆ x1 or not contains_extension_of_linear_subchains[P](x1) or not is_linear_chains[P](x0) or union[P](x0) ∈ x1 } and forall(x2: Set[Set[P]]) { s0(x2) ⊆ x2 or contains_extension_of_linear_subchains[P](x2) } and forall(x3: Set[Set[P]]) { is_linear_chains[P](s0(x3)) or contains_extension_of_linear_subchains[P](x3) } and forall(x4: Set[Set[P]]) { not union[P](s0(x4)) ∈ x4 or contains_extension_of_linear_subchains[P](x4) } }","not s0(suc_compare[P](c)) ⊆ suc_compare[P](c) or not is_linear_chains[P](s0(suc_compare[P](c))) or union[P](s0(suc_compare[P](c))) ∈ suc_compare[P](c)","not union[P](s0(suc_compare[P](c))) ∈ suc_compare[P](c) or contains_extension_of_linear_subchains[P](suc_compare[P](c))","s0(suc_compare[P](c)) ⊆ suc_compare[P](c) or contains_extension_of_linear_subchains[P](suc_compare[P](c))","is_linear_chains[P](s0(suc_compare[P](c))) or contains_extension_of_linear_subchains[P](suc_compare[P](c))","is_linear_chains[P](s0(suc_compare[P](c)))","s0(suc_compare[P](c)) ⊆ suc_compare[P](c)","not union[P](s0(suc_compare[P](c))) ∈ suc_compare[P](c)","union[P](s0(suc_compare[P](c))) ∈ suc_compare[P](c)"]}
{"goal":"inductive_compare_are_inductive_chains","proof":["not Set.empty_set[P] ∈ suc_compare[P](c) or not contains_suc[P](suc_compare[P](c)) or not contains_extension_of_linear_subchains[P](suc_compare[P](c)) or not are_chains[P](suc_compare[P](c)) or are_inductive_chains[P](suc_compare[P](c))"]}
{"goal":"are_inductive_chains[P](suc_compare[P](c))","proof":["not is_comparable_chain[P](c) or are_inductive_chains[P](suc_compare[P](c))"]}
{"goal":"smallest_inductive_chains[P] ⊆ suc_compare[P](c)","proof":["not are_inductive_chains[P](suc_compare[P](c)) or smallest_inductive_chains[P] ⊆ suc_compare[P](c)"]}
{"goal":"suc_compare[P](c) ⊆ smallest_inductive_chains[P]","proof":["suc_compare[P](c) ⊆ smallest_inductive_chains[P]"]}
{"goal":"inductive_compare_is_smallest_inductive_chains","proof":["not suc_compare[P](c) ⊇ smallest_inductive_chains[P] or not suc_compare[P](c) ⊆ smallest_inductive_chains[P] or suc_compare[P](c) = smallest_inductive_chains[P]","suc_compare[P](c) ⊇ smallest_inductive_chains[P] = smallest_inductive_chains[P] ⊆ suc_compare[P](c)","not suc_compare[P](c) ⊇ smallest_inductive_chains[P]","suc_compare[P](c) ⊇ smallest_inductive_chains[P]"]}
{"goal":"a ∈ suc_compare[P](c)","proof":["not is_comparable_chain[P](c) or suc_compare[P](c) = smallest_inductive_chains[P]","suc_compare[P](c) = smallest_inductive_chains[P]"]}
{"goal":"a ⊆ c","proof":["not elem_in_suc_compare[P](c, a) or suc[P](c) ⊆ a or a ⊆ c","not elem_in_suc_compare[P](c, a)","a ∈ Set[P].new(elem_in_suc_compare[P](c)) = elem_in_suc_compare[P](c, a)","Set[P].new(elem_in_suc_compare[P](c)) = suc_compare[P](c)"]}
{"goal":"c ⊆ suc[P](c)","proof":["not is_chain_extention(c, chain_extend_fn[P](c)) or c ⊂ chain_extension(c, chain_extend_fn[P](c))","chain_extension(c, chain_extend_fn[P](c)) = suc[P](c)","chain_extension(c, chain_extend_fn[P](c)) = c or is_chain_extention(c, chain_extend_fn[P](c))","not c ⊂ chain_extension(c, chain_extend_fn[P](c)) or c ⊆ chain_extension(c, chain_extend_fn[P](c))","chain_extension(c, chain_extend_fn[P](c)) != c or c ⊆ chain_extension(c, chain_extend_fn[P](c))","not c ⊆ chain_extension(c, chain_extend_fn[P](c))","chain_extension(c, chain_extend_fn[P](c)) != c","not c ⊂ chain_extension(c, chain_extend_fn[P](c))","is_chain_extention(c, chain_extend_fn[P](c))","not is_chain_extention(c, chain_extend_fn[P](c))"]}
{"goal":"a ⊆ suc[P](c)","proof":["not a ∪ c ⊆ suc[P](c) or a ⊆ suc[P](c)","not a ⊆ c or a ∪ c = c","not a ∪ c ⊆ suc[P](c)","a ∪ c = c"]}
{"goal":"a ⊆ suc[P](c) or suc[P](c) ⊆ a","proof":[]}
{"goal":"suc[P](c) ∈ smallest_inductive_chains[P]","proof":["not c ∈ smallest_inductive_chains[P] or not contains_suc[P](smallest_inductive_chains[P]) or suc[P](c) ∈ smallest_inductive_chains[P]","not is_comparable_chain[P](c) or c ∈ smallest_inductive_chains[P]","c ∈ smallest_inductive_chains[P]","not c ∈ smallest_inductive_chains[P]"]}
{"goal":"is_comparable_chain[P](suc[P](c))","proof":["let s0: Set[P] -> Set[P] satisfy { forall(x0: Set[P]) { not is_comparable_chain[P](x0) or x0 ∈ smallest_inductive_chains[P] } and forall(x1: Set[P], x2: Set[P]) { not x1 ∈ smallest_inductive_chains[P] or not is_comparable_chain[P](x2) or is_chain_comparable[P](x2, x1) } and forall(x3: Set[P]) { not x3 ∈ smallest_inductive_chains[P] or s0(x3) ∈ smallest_inductive_chains[P] or is_comparable_chain[P](x3) } and forall(x4: Set[P]) { not x4 ∈ smallest_inductive_chains[P] or not is_chain_comparable[P](x4, s0(x4)) or is_comparable_chain[P](x4) } }","not s0(suc[P](c)) ∈ smallest_inductive_chains[P] or suc[P](c) ⊆ s0(suc[P](c)) or s0(suc[P](c)) ⊆ suc[P](c)","not suc[P](c) ∈ smallest_inductive_chains[P] or s0(suc[P](c)) ∈ smallest_inductive_chains[P] or is_comparable_chain[P](suc[P](c))","not suc[P](c) ∈ smallest_inductive_chains[P] or not is_chain_comparable[P](suc[P](c), s0(suc[P](c))) or is_comparable_chain[P](suc[P](c))","not s0(suc[P](c)) ⊆ suc[P](c) or is_chain_comparable[P](suc[P](c), s0(suc[P](c)))","not suc[P](c) ⊆ s0(suc[P](c)) or is_chain_comparable[P](suc[P](c), s0(suc[P](c)))","not is_chain_comparable[P](suc[P](c), s0(suc[P](c)))","s0(suc[P](c)) ∈ smallest_inductive_chains[P]","not suc[P](c) ⊆ s0(suc[P](c))","not s0(suc[P](c)) ⊆ suc[P](c)","s0(suc[P](c)) ⊆ suc[P](c)"]}
{"goal":"suc_preserve_comparable_chain","proof":[]}
{"goal":"comparable_chains_subset","proof":["let s0: (Set[Set[P]], Set[Set[P]]) -> Set[P] satisfy { forall(x0: Set[Set[P]], x1: Set[Set[P]], x2: Set[P]) { not x0 ⊆ x1 or not x2 ∈ x0 or x2 ∈ x1 } and forall(x3: Set[Set[P]], x4: Set[Set[P]]) { s0(x3, x4) ∈ x3 or x3 ⊆ x4 } and forall(x5: Set[Set[P]], x6: Set[Set[P]]) { not s0(x6, x5) ∈ x5 or x6 ⊆ x5 } }","not s0(comparable_chains[P], smallest_inductive_chains[P]) ∈ smallest_inductive_chains[P] or comparable_chains[P] ⊆ smallest_inductive_chains[P]","s0(comparable_chains[P], smallest_inductive_chains[P]) ∈ comparable_chains[P] or comparable_chains[P] ⊆ smallest_inductive_chains[P]","s0(comparable_chains[P], smallest_inductive_chains[P]) ∈ Set[P].new(is_comparable_chain[P]) = is_comparable_chain[P](s0(comparable_chains[P], smallest_inductive_chains[P]))","not is_comparable_chain[P](s0(comparable_chains[P], smallest_inductive_chains[P])) or s0(comparable_chains[P], smallest_inductive_chains[P]) ∈ smallest_inductive_chains[P]","s0(comparable_chains[P], smallest_inductive_chains[P]) ∈ comparable_chains[P]","not s0(comparable_chains[P], smallest_inductive_chains[P]) ∈ smallest_inductive_chains[P]","not s0(comparable_chains[P], smallest_inductive_chains[P]) ∈ Set[P].new(is_comparable_chain[P]) or is_comparable_chain[P](s0(comparable_chains[P], smallest_inductive_chains[P]))","not is_comparable_chain[P](s0(comparable_chains[P], smallest_inductive_chains[P]))","s0(comparable_chains[P], smallest_inductive_chains[P]) ∈ Set[P].new(is_comparable_chain[P])","not s0(comparable_chains[P], smallest_inductive_chains[P]) ∈ Set[P].new(is_comparable_chain[P])"]}
{"goal":"suc_preserve_comparable_chain_by_comparable_chains","proof":["c ∈ Set[P].new(is_comparable_chain[P]) = is_comparable_chain[P](c)","suc[P](c) ∈ Set[P].new(is_comparable_chain[P]) = is_comparable_chain[P](suc[P](c))","not is_comparable_chain[P](c) or is_comparable_chain[P](suc[P](c))","not suc[P](c) ∈ Set[P].new(is_comparable_chain[P])","not is_comparable_chain[P](suc[P](c))","c ∈ Set[P].new(is_comparable_chain[P])","not is_comparable_chain[P](c)","is_comparable_chain[P](c)"]}
{"goal":"are_chains[P](comparable_chains[P])","proof":["not comparable_chains[P] ⊆ smallest_inductive_chains[P] or not are_chains[P](smallest_inductive_chains[P]) or are_chains[P](comparable_chains[P])","not comparable_chains[P] ⊆ smallest_inductive_chains[P] or not are_chains[P](smallest_inductive_chains[P])"]}
{"goal":"Set.empty_set[P] ∈ comparable_chains[P]","proof":["Set.empty_set[P] ∈ Set[P].new(is_comparable_chain[P]) = is_comparable_chain[P](Set.empty_set[P])","not Set.empty_set[P] ∈ Set[P].new(is_comparable_chain[P])"]}
{"goal":"contains_suc[P](comparable_chains[P])","proof":["let s0: Set[Set[P]] -> Set[P] satisfy { forall(x0: Set[Set[P]], x1: Set[P]) { not x1 ∈ x0 or not contains_suc[P](x0) or suc[P](x1) ∈ x0 } and forall(x2: Set[Set[P]]) { s0(x2) ∈ x2 or contains_suc[P](x2) } and forall(x3: Set[Set[P]]) { not suc[P](s0(x3)) ∈ x3 or contains_suc[P](x3) } }","not s0(comparable_chains[P]) ∈ comparable_chains[P] or suc[P](s0(comparable_chains[P])) ∈ comparable_chains[P]","not suc[P](s0(comparable_chains[P])) ∈ comparable_chains[P] or contains_suc[P](comparable_chains[P])","s0(comparable_chains[P]) ∈ comparable_chains[P] or contains_suc[P](comparable_chains[P])","s0(comparable_chains[P]) ∈ comparable_chains[P]","not suc[P](s0(comparable_chains[P])) ∈ comparable_chains[P]","suc[P](s0(comparable_chains[P])) ∈ comparable_chains[P]"]}
{"goal":"cs ⊆ smallest_inductive_chains[P]","proof":["not cs ⊆ comparable_chains[P] or not comparable_chains[P] ⊆ smallest_inductive_chains[P] or cs ⊆ smallest_inductive_chains[P]","not comparable_chains[P] ⊆ smallest_inductive_chains[P] or not cs ⊆ comparable_chains[P]"]}
{"goal":"union[P](cs) ∈ smallest_inductive_chains[P]","proof":["not cs ⊆ smallest_inductive_chains[P] or not contains_extension_of_linear_subchains[P](smallest_inductive_chains[P]) or not is_linear_chains[P](cs) or union[P](cs) ∈ smallest_inductive_chains[P]","not contains_extension_of_linear_subchains[P](smallest_inductive_chains[P])"]}
{"goal":"union[P](cs) ⊆ d","proof":["let s0: (Set[Set[P]], Set[P]) -> Set[P] satisfy { forall(x0: Set[Set[P]], x1: Set[P]) { s0(x0, x1) ∈ x0 or union[P](x0) ⊆ x1 } and forall(x2: Set[Set[P]], x3: Set[P]) { not s0(x2, x3) ⊆ x3 or union[P](x2) ⊆ x3 } }","not s0(cs, d) ∈ cs or s0(cs, d) ⊆ d","s0(cs, d) ∈ cs or union[P](cs) ⊆ d","not s0(cs, d) ⊆ d or union[P](cs) ⊆ d","not s0(cs, d) ⊆ d","s0(cs, d) ∈ cs","not s0(cs, d) ∈ cs"]}
{"goal":"is_chain_comparable[P](union[P](cs), d)","proof":["is_chain_comparable[P](d, union[P](cs)) = is_chain_comparable[P](union[P](cs), d)","not union[P](cs) ⊆ d or is_chain_comparable[P](d, union[P](cs))","not is_chain_comparable[P](d, union[P](cs))","is_chain_comparable[P](d, union[P](cs))"]}
{"goal":"exists(k0: Set[P]) { k0 ∈ cs and not k0 ⊆ d }","proof":["let s0: Set[P] satisfy { s0 ∈ cs and not s0 ⊆ d }","not s0 ∈ cs or s0 ⊆ d","not s0 ∈ cs"]}
{"goal":"c ∈ comparable_chains[P]","proof":["not cs ⊆ comparable_chains[P] or not c ∈ cs or c ∈ comparable_chains[P]","not cs ⊆ comparable_chains[P] or not c ∈ cs"]}
{"goal":"is_chain_comparable[P](c, d)","proof":["not d ∈ smallest_inductive_chains[P] or not is_comparable_chain[P](c) or is_chain_comparable[P](c, d)","not is_comparable_chain[P](c)","c ∈ Set[P].new(is_comparable_chain[P]) = is_comparable_chain[P](c)"]}
{"goal":"d ⊂ c","proof":["not is_chain_comparable[P](c, d) or c ⊆ d or d ⊆ c","not d ⊆ c or d ⊂ c or c = d","c != d or c ⊆ d","not d ⊆ c or c = d","c != d","d ⊆ c","not d ⊆ c"]}
{"goal":"d ⊆ c","proof":["not is_chain_comparable[P](c, d) or c ⊆ d or d ⊆ c"]}
{"goal":"c ⊆ union[P](cs)","proof":["not c ∈ cs or c ⊆ union[P](cs)"]}
{"goal":"d ⊆ union[P](cs)","proof":["not d ∪ c ⊆ union[P](cs) or d ⊆ union[P](cs)","not d ⊆ c or d ∪ c = c","not d ∪ c ⊆ union[P](cs)","d ∪ c = c"]}
{"goal":"is_chain_comparable[P](union[P](cs), d)","proof":["not d ⊆ union[P](cs) or is_chain_comparable[P](union[P](cs), d)"]}
{"goal":"is_chain_comparable[P](union[P](cs), d)","proof":[]}
{"goal":"union[P](cs) ∈ comparable_chains[P]","proof":["let s0: Set[P] -> Set[P] satisfy { forall(x0: Set[P]) { not is_comparable_chain[P](x0) or x0 ∈ smallest_inductive_chains[P] } and forall(x1: Set[P], x2: Set[P]) { not x1 ∈ smallest_inductive_chains[P] or not is_comparable_chain[P](x2) or is_chain_comparable[P](x2, x1) } and forall(x3: Set[P]) { not x3 ∈ smallest_inductive_chains[P] or s0(x3) ∈ smallest_inductive_chains[P] or is_comparable_chain[P](x3) } and forall(x4: Set[P]) { not x4 ∈ smallest_inductive_chains[P] or not is_chain_comparable[P](x4, s0(x4)) or is_comparable_chain[P](x4) } }","not s0(union[P](cs)) ∈ smallest_inductive_chains[P] or is_chain_comparable[P](union[P](cs), s0(union[P](cs)))","not union[P](cs) ∈ smallest_inductive_chains[P] or s0(union[P](cs)) ∈ smallest_inductive_chains[P] or is_comparable_chain[P](union[P](cs))","not union[P](cs) ∈ smallest_inductive_chains[P] or not is_chain_comparable[P](union[P](cs), s0(union[P](cs))) or is_comparable_chain[P](union[P](cs))","union[P](cs) ∈ Set[P].new(is_comparable_chain[P]) = is_comparable_chain[P](union[P](cs))","not union[P](cs) ∈ Set[P].new(is_comparable_chain[P])","not is_comparable_chain[P](union[P](cs))","not is_chain_comparable[P](union[P](cs), s0(union[P](cs)))","s0(union[P](cs)) ∈ smallest_inductive_chains[P]","not s0(union[P](cs)) ∈ smallest_inductive_chains[P]"]}
{"goal":"contains_extension_of_linear_subchains[P](comparable_chains[P])","proof":["let s0: Set[Set[P]] -> Set[Set[P]] satisfy { forall(x0: Set[Set[P]], x1: Set[Set[P]]) { not x0 ⊆ x1 or not contains_extension_of_linear_subchains[P](x1) or not is_linear_chains[P](x0) or union[P](x0) ∈ x1 } and forall(x2: Set[Set[P]]) { s0(x2) ⊆ x2 or contains_extension_of_linear_subchains[P](x2) } and forall(x3: Set[Set[P]]) { is_linear_chains[P](s0(x3)) or contains_extension_of_linear_subchains[P](x3) } and forall(x4: Set[Set[P]]) { not union[P](s0(x4)) ∈ x4 or contains_extension_of_linear_subchains[P](x4) } }","not s0(comparable_chains[P]) ⊆ comparable_chains[P] or not is_linear_chains[P](s0(comparable_chains[P])) or union[P](s0(comparable_chains[P])) ∈ comparable_chains[P]","not union[P](s0(comparable_chains[P])) ∈ comparable_chains[P] or contains_extension_of_linear_subchains[P](comparable_chains[P])","s0(comparable_chains[P]) ⊆ comparable_chains[P] or contains_extension_of_linear_subchains[P](comparable_chains[P])","is_linear_chains[P](s0(comparable_chains[P])) or contains_extension_of_linear_subchains[P](comparable_chains[P])","is_linear_chains[P](s0(comparable_chains[P]))","s0(comparable_chains[P]) ⊆ comparable_chains[P]","not union[P](s0(comparable_chains[P])) ∈ comparable_chains[P]","union[P](s0(comparable_chains[P])) ∈ comparable_chains[P]"]}
{"goal":"are_inductive_chains[P](comparable_chains[P])","proof":["not Set.empty_set[P] ∈ comparable_chains[P] or not contains_suc[P](comparable_chains[P]) or not contains_extension_of_linear_subchains[P](comparable_chains[P]) or not are_chains[P](comparable_chains[P]) or are_inductive_chains[P](comparable_chains[P])"]}
{"goal":"smallest_inductive_chains[P] ⊆ comparable_chains[P]","proof":["not are_inductive_chains[P](comparable_chains[P]) or smallest_inductive_chains[P] ⊆ comparable_chains[P]"]}
{"goal":"comparable_chains_is_smallest_inductive_chains","proof":["not comparable_chains[P] ⊇ smallest_inductive_chains[P] or not comparable_chains[P] ⊆ smallest_inductive_chains[P] or comparable_chains[P] = smallest_inductive_chains[P]","comparable_chains[P] ⊇ smallest_inductive_chains[P] = smallest_inductive_chains[P] ⊆ comparable_chains[P]","comparable_chains[P] ⊇ smallest_inductive_chains[P]","not comparable_chains[P] ⊇ smallest_inductive_chains[P]"]}
{"goal":"c1 ∈ comparable_chains[P]","proof":[]}
{"goal":"is_chain_comparable[P](c1, c2)","proof":["not c2 ∈ smallest_inductive_chains[P] or not is_comparable_chain[P](c1) or is_chain_comparable[P](c1, c2)","not is_comparable_chain[P](c1)","c1 ∈ Set[P].new(is_comparable_chain[P]) = is_comparable_chain[P](c1)"]}
{"goal":"smallest_inductive_chains_is_linear_chains","proof":["let (s0: Set[Set[P]] -> Set[P], s1: Set[Set[P]] -> Set[P]) satisfy { forall(x0: Set[Set[P]], x1: Set[P], x2: Set[P]) { not x1 ∈ x0 or not x2 ∈ x0 or not is_linear_chains[P](x0) or is_chain_comparable[P](x1, x2) } and forall(x3: Set[Set[P]]) { s0(x3) ∈ x3 or is_linear_chains[P](x3) } and forall(x4: Set[Set[P]]) { s1(x4) ∈ x4 or is_linear_chains[P](x4) } and forall(x5: Set[Set[P]]) { not is_chain_comparable[P](s0(x5), s1(x5)) or is_linear_chains[P](x5) } }","not s0(smallest_inductive_chains[P]) ∈ smallest_inductive_chains[P] or not s1(smallest_inductive_chains[P]) ∈ smallest_inductive_chains[P] or is_chain_comparable[P](s0(smallest_inductive_chains[P]), s1(smallest_inductive_chains[P]))","not is_chain_comparable[P](s0(smallest_inductive_chains[P]), s1(smallest_inductive_chains[P])) or is_linear_chains[P](smallest_inductive_chains[P])","s1(smallest_inductive_chains[P]) ∈ smallest_inductive_chains[P] or is_linear_chains[P](smallest_inductive_chains[P])","s0(smallest_inductive_chains[P]) ∈ smallest_inductive_chains[P] or is_linear_chains[P](smallest_inductive_chains[P])","s0(smallest_inductive_chains[P]) ∈ smallest_inductive_chains[P]","s1(smallest_inductive_chains[P]) ∈ smallest_inductive_chains[P]","not is_chain_comparable[P](s0(smallest_inductive_chains[P]), s1(smallest_inductive_chains[P]))"]}
{"goal":"chosen_maximal_chain_is_linear","proof":["not is_linear_chains[P](smallest_inductive_chains[P]) or not are_chains[P](smallest_inductive_chains[P]) or is_chain[P](union[P](smallest_inductive_chains[P]))","not is_chain[P](union[P](smallest_inductive_chains[P]))","not are_chains[P](smallest_inductive_chains[P])"]}
{"goal":"chosen_maximal_chain_in_smallest_inductive_chains","proof":["not smallest_inductive_chains[P] ⊆ smallest_inductive_chains[P] or not contains_extension_of_linear_subchains[P](smallest_inductive_chains[P]) or not is_linear_chains[P](smallest_inductive_chains[P]) or union[P](smallest_inductive_chains[P]) ∈ smallest_inductive_chains[P]","smallest_inductive_chains[P] ⊆ smallest_inductive_chains[P]","not union[P](smallest_inductive_chains[P]) ∈ smallest_inductive_chains[P]"]}
{"goal":"is_chain[P](chosen_maximal_chain[P])","proof":[]}
{"goal":"contains_suc[P](smallest_inductive_chains[P])","proof":[]}
{"goal":"chosen_maximal_chain[P] ∈ smallest_inductive_chains[P]","proof":[]}
{"goal":"suc[P](chosen_maximal_chain[P]) ∈ smallest_inductive_chains[P]","proof":["not chosen_maximal_chain[P] ∈ smallest_inductive_chains[P] or not contains_suc[P](smallest_inductive_chains[P]) or suc[P](chosen_maximal_chain[P]) ∈ smallest_inductive_chains[P]"]}
{"goal":"suc[P](chosen_maximal_chain[P]) = chosen_maximal_chain[P] ∪ Set.singleton(chain_extend_fn[P](chosen_maximal_chain[P]))","proof":["not is_chain_extention(chosen_maximal_chain[P], chain_extend_fn[P](chosen_maximal_chain[P])) or chosen_maximal_chain[P] ∪ Set.singleton(chain_extend_fn[P](chosen_maximal_chain[P])) = chain_extension(chosen_maximal_chain[P], chain_extend_fn[P](chosen_maximal_chain[P]))","not is_chain[P](chosen_maximal_chain[P]) or is_non_maximal_chain[P](chosen_maximal_chain[P]) or is_maximal_chain[P](chosen_maximal_chain[P])","chain_extension(chosen_maximal_chain[P], chain_extend_fn[P](chosen_maximal_chain[P])) = suc[P](chosen_maximal_chain[P])","not is_non_maximal_chain[P](chosen_maximal_chain[P]) or is_chain_extention(chosen_maximal_chain[P], chain_extend_fn[P](chosen_maximal_chain[P]))","is_non_maximal_chain[P](chosen_maximal_chain[P])","chosen_maximal_chain[P] ∪ Set.singleton(chain_extend_fn[P](chosen_maximal_chain[P])) != chain_extension(chosen_maximal_chain[P], chain_extend_fn[P](chosen_maximal_chain[P]))","is_chain_extention(chosen_maximal_chain[P], chain_extend_fn[P](chosen_maximal_chain[P]))","not is_chain_extention(chosen_maximal_chain[P], chain_extend_fn[P](chosen_maximal_chain[P]))"]}
{"goal":"chain_extend_fn[P](chosen_maximal_chain[P]) ∉ chosen_maximal_chain[P]","proof":["not is_chain[P](chosen_maximal_chain[P]) or is_non_maximal_chain[P](chosen_maximal_chain[P]) or is_maximal_chain[P](chosen_maximal_chain[P])","not is_non_maximal_chain[P](chosen_maximal_chain[P]) or is_chain_extention(chosen_maximal_chain[P], chain_extend_fn[P](chosen_maximal_chain[P]))","not is_chain_extention(chosen_maximal_chain[P], chain_extend_fn[P](chosen_maximal_chain[P])) or chain_extend_fn[P](chosen_maximal_chain[P]) ∉ chosen_maximal_chain[P]","not is_chain_extention(chosen_maximal_chain[P], chain_extend_fn[P](chosen_maximal_chain[P]))","is_non_maximal_chain[P](chosen_maximal_chain[P])","not is_non_maximal_chain[P](chosen_maximal_chain[P])"]}
{"goal":"suc[P](chosen_maximal_chain[P]) ⊆ union[P](smallest_inductive_chains[P])","proof":["not suc[P](chosen_maximal_chain[P]) ∈ smallest_inductive_chains[P] or suc[P](chosen_maximal_chain[P]) ⊆ union[P](smallest_inductive_chains[P])"]}
{"goal":"suc[P](chosen_maximal_chain[P]) ⊆ chosen_maximal_chain[P]","proof":[]}
{"goal":"Set.singleton(chain_extend_fn[P](chosen_maximal_chain[P])) ⊆ chosen_maximal_chain[P]","proof":["not chosen_maximal_chain[P] ∪ Set.singleton(chain_extend_fn[P](chosen_maximal_chain[P])) ⊆ chosen_maximal_chain[P] or Set.singleton(chain_extend_fn[P](chosen_maximal_chain[P])) ⊆ chosen_maximal_chain[P]","not chosen_maximal_chain[P] ∪ Set.singleton(chain_extend_fn[P](chosen_maximal_chain[P])) ⊆ chosen_maximal_chain[P]"]}
{"goal":"chain_extend_fn[P](chosen_maximal_chain[P]) ∈ chosen_maximal_chain[P]","proof":["Set.singleton(chain_extend_fn[P](chosen_maximal_chain[P])) ⊆ chosen_maximal_chain[P] = chain_extend_fn[P](chosen_maximal_chain[P]) ∈ chosen_maximal_chain[P]"]}
{"goal":"false","proof":["lib(set).negate_fn(chosen_maximal_chain[P].contains, chain_extend_fn[P](chosen_maximal_chain[P])) = chain_extend_fn[P](chosen_maximal_chain[P]) ∉ chosen_maximal_chain[P]","lib(set).negate_fn(chosen_maximal_chain[P].contains, chain_extend_fn[P](chosen_maximal_chain[P])) != chain_extend_fn[P](chosen_maximal_chain[P]) ∈ chosen_maximal_chain[P]","not lib(set).negate_fn(chosen_maximal_chain[P].contains, chain_extend_fn[P](chosen_maximal_chain[P])) or not chain_extend_fn[P](chosen_maximal_chain[P]) ∈ chosen_maximal_chain[P]","lib(set).negate_fn(chosen_maximal_chain[P].contains, chain_extend_fn[P](chosen_maximal_chain[P]))","not lib(set).negate_fn(chosen_maximal_chain[P].contains, chain_extend_fn[P](chosen_maximal_chain[P]))"]}
{"goal":"chosen_maximal_chain_is_maximal","proof":[]}
{"goal":"maximal_principle","proof":["not is_maximal_chain[P](chosen_maximal_chain[P])"]}
{"goal":"union[P](ds) ∈ smallest_inductive_chains[P]","proof":["let s0: Set[P] -> Set[Set[P]] satisfy { forall(x0: Set[P], x1: Set[Set[P]]) { not elem_in_smallest_inductive_chains[P](x0) or not are_inductive_chains[P](x1) or x0 ∈ x1 } and forall(x2: Set[P]) { are_inductive_chains[P](s0(x2)) or elem_in_smallest_inductive_chains[P](x2) } and forall(x3: Set[P]) { not x3 ∈ s0(x3) or elem_in_smallest_inductive_chains[P](x3) } }","not are_inductive_chains[P](s0(union[P](ds))) or union[P](ds) ∈ s0(union[P](ds))","union[P](ds) ∈ Set[P].new(elem_in_smallest_inductive_chains[P]) = elem_in_smallest_inductive_chains[P](union[P](ds))","not union[P](ds) ∈ s0(union[P](ds)) or elem_in_smallest_inductive_chains[P](union[P](ds))","are_inductive_chains[P](s0(union[P](ds))) or elem_in_smallest_inductive_chains[P](union[P](ds))","not union[P](ds) ∈ Set[P].new(elem_in_smallest_inductive_chains[P])","not elem_in_smallest_inductive_chains[P](union[P](ds))","are_inductive_chains[P](s0(union[P](ds)))","not union[P](ds) ∈ s0(union[P](ds))","union[P](ds) ∈ s0(union[P](ds))"]}
{"goal":"c ⊂ a","proof":["not s ∈ c or s ∈ a","lib(set).negate_fn(a.contains, s) = s ∉ a","lib(set).negate_fn(a.contains, s) != s ∈ a","s ∈ a","not lib(set).negate_fn(a.contains, s) or not s ∈ a","lib(set).negate_fn(a.contains, s)","not lib(set).negate_fn(a.contains, s)"]}
{"goal":"exists(k0: P) { if is_non_maximal_chain[P](c) { is_chain_extention(c, k0) } else { k0 = void[P] } }","proof":["let s0: Set[P] -> P satisfy { forall(x0: Set[P]) { not is_chain[P](x0) or is_chain_extention(x0, s0(x0)) or is_maximal_chain[P](x0) } }","not is_non_maximal_chain[P](c) or not is_chain_extention(c, s0(c))","void[P] != void[P] or is_non_maximal_chain[P](c)","is_non_maximal_chain[P](c)","not is_chain_extention(c, s0(c))","not is_chain[P](c) or is_chain_extention(c, s0(c)) or is_maximal_chain[P](c)","not is_non_maximal_chain[P](c) or not is_maximal_chain[P](c)","not is_maximal_chain[P](c)","not is_non_maximal_chain[P](c) or is_chain[P](c)","not is_chain[P](c)","is_chain[P](c)"]}
{"goal":"ds ⊆ cs","proof":["not lib(util).is_transitive[Set[Set[P]]](Set[P].subset_eq) or not ds ⊆ smallest_inductive_chains[P] or not smallest_inductive_chains[P] ⊆ cs or ds ⊆ cs","not are_inductive_chains[P](cs) or smallest_inductive_chains[P] ⊆ cs","not smallest_inductive_chains[P] ⊆ cs or not ds ⊆ smallest_inductive_chains[P]","smallest_inductive_chains[P] ⊆ cs","not smallest_inductive_chains[P] ⊆ cs"]}
{"goal":"a ⊆ c","proof":["not elem_in_suc_compare[P](c, a) or suc[P](c) ⊆ a or a ⊆ c","not elem_in_suc_compare[P](c, a)","a ∈ Set[P].new(elem_in_suc_compare[P](c)) = elem_in_suc_compare[P](c, a)","Set[P].new(elem_in_suc_compare[P](c)) = suc_compare[P](c)"]}
{"goal":"exists(k0: P) { true }","proof":[]}
{"goal":"suc[P](c) ⊆ a","proof":["not elem_in_suc_compare[P](c, a) or suc[P](c) ⊆ a or a ⊆ c","not a ⊆ c or a ⊂ c or a = c","a ∈ Set[P].new(elem_in_suc_compare[P](c)) = elem_in_suc_compare[P](c, a)","Set[P].new(elem_in_suc_compare[P](c)) = suc_compare[P](c)","not elem_in_suc_compare[P](c, a) or a ⊆ c","not a ⊆ c","not elem_in_suc_compare[P](c, a)","not a ∈ Set[P].new(elem_in_suc_compare[P](c)) or elem_in_suc_compare[P](c, a)","a ∈ Set[P].new(elem_in_suc_compare[P](c))","not a ∈ Set[P].new(elem_in_suc_compare[P](c))"]}
{"goal":"suc_preserve_comparable_chain_by_comparable_chains","proof":["c ∈ Set[P].new(is_comparable_chain[P]) = is_comparable_chain[P](c)","suc[P](c) ∈ Set[P].new(is_comparable_chain[P]) = is_comparable_chain[P](suc[P](c))","not is_comparable_chain[P](c) or is_comparable_chain[P](suc[P](c))","not suc[P](c) ∈ Set[P].new(is_comparable_chain[P])","not is_comparable_chain[P](suc[P](c))","c ∈ Set[P].new(is_comparable_chain[P])","not is_comparable_chain[P](c)","is_comparable_chain[P](c)"]}
{"goal":"u != t","proof":["u ∉ c","lib(set).negate_fn(c.contains, u) = u ∉ c","lib(set).negate_fn(c.contains, u) != u ∈ c","not lib(set).negate_fn(c.contains, u) or not u ∈ c","lib(set).negate_fn(c.contains, u)","not lib(set).negate_fn(c.contains, u)"]}
{"goal":"suc[P](c) ∈ smallest_inductive_chains[P]","proof":["let s0: Set[P] -> Set[Set[P]] satisfy { forall(x0: Set[P], x1: Set[Set[P]]) { not elem_in_smallest_inductive_chains[P](x0) or not are_inductive_chains[P](x1) or x0 ∈ x1 } and forall(x2: Set[P]) { are_inductive_chains[P](s0(x2)) or elem_in_smallest_inductive_chains[P](x2) } and forall(x3: Set[P]) { not x3 ∈ s0(x3) or elem_in_smallest_inductive_chains[P](x3) } }","not are_inductive_chains[P](s0(suc[P](c))) or suc[P](c) ∈ s0(suc[P](c))","suc[P](c) ∈ Set[P].new(elem_in_smallest_inductive_chains[P]) = elem_in_smallest_inductive_chains[P](suc[P](c))","not suc[P](c) ∈ s0(suc[P](c)) or elem_in_smallest_inductive_chains[P](suc[P](c))","are_inductive_chains[P](s0(suc[P](c))) or elem_in_smallest_inductive_chains[P](suc[P](c))","not suc[P](c) ∈ Set[P].new(elem_in_smallest_inductive_chains[P])","not elem_in_smallest_inductive_chains[P](suc[P](c))","are_inductive_chains[P](s0(suc[P](c)))","not suc[P](c) ∈ s0(suc[P](c))","suc[P](c) ∈ s0(suc[P](c))"]}
{"goal":"Set.empty_set[P] ∈ all_chains[P]","proof":["Set.empty_set[P] ∈ Set[P].new(is_chain[P]) = is_chain[P](Set.empty_set[P])","let  (s0: Set[P] -> P, s1: Set[P] -> P) satisfy { forall(x0: Set[P], x1: P, x2: P) { not is_chain[P](x0) or not x1 ∈ x0 or not x2 ∈ x0 or comparable[P](x1, x2) } and forall(x3: Set[P]) { s0(x3) ∈ x3 or is_chain[P](x3) } and forall(x4: Set[P]) { s1(x4) ∈ x4 or is_chain[P](x4) } and forall(x5: Set[P]) { not comparable[P](s0(x5), s1(x5)) or is_chain[P](x5) } }","s0(Set.empty_set[P]) ∈ Set.empty_set[P] or is_chain[P](Set.empty_set[P])","not s0(Set.empty_set[P]) ∈ Set.empty_set[P] or Set.empty_set[P].is_nonempty","Set.empty_set[P] != Set.empty_set[P] or not Set.empty_set[P].is_nonempty","not Set.empty_set[P].is_nonempty","not Set.empty_set[P] ∈ Set[P].new(is_chain[P])","not is_chain[P](Set.empty_set[P])","s0(Set.empty_set[P]) ∈ Set.empty_set[P]"]}
{"goal":"u ∉ Set.singleton(t)","proof":["lib(set).negate_fn(Set.singleton(t).contains, u) = u ∉ Set.singleton(t)","not u ∈ Set.singleton(t) or u = t","lib(set).negate_fn(Set.singleton(t).contains, u) != u ∈ Set.singleton(t)","not lib(set).negate_fn(Set.singleton(t).contains, u)","lib(set).negate_fn(Set.singleton(t).contains, u) or u ∈ Set.singleton(t)","not u ∈ Set.singleton(t)","u ∈ Set.singleton(t)"]}
{"goal":"d ⊆ c or suc[P](c) ⊆ d","proof":["not elem_in_suc_compare[P](c, d) or suc[P](c) ⊆ d or d ⊆ c","not elem_in_suc_compare[P](c, d)","d ∈ Set[P].new(elem_in_suc_compare[P](c)) = elem_in_suc_compare[P](c, d)","Set[P].new(elem_in_suc_compare[P](c)) = suc_compare[P](c)"]}
{"goal":"c ∈ all_chains[P] implies is_chain[P](c)","proof":["c ∈ Set[P].new(is_chain[P]) = is_chain[P](c)"]}
{"goal":"smallest_inductive_chains_is_smallest","proof":["let s0: (Set[Set[P]], Set[Set[P]]) -> Set[P] satisfy { forall(x0: Set[Set[P]], x1: Set[Set[P]], x2: Set[P]) { not x0 ⊆ x1 or not x2 ∈ x0 or x2 ∈ x1 } and forall(x3: Set[Set[P]], x4: Set[Set[P]]) { s0(x3, x4) ∈ x3 or x3 ⊆ x4 } and forall(x5: Set[Set[P]], x6: Set[Set[P]]) { not s0(x6, x5) ∈ x5 or x6 ⊆ x5 } }","not s0(smallest_inductive_chains[P], cs) ∈ cs or smallest_inductive_chains[P] ⊆ cs","s0(smallest_inductive_chains[P], cs) ∈ smallest_inductive_chains[P] or smallest_inductive_chains[P] ⊆ cs","not elem_in_smallest_inductive_chains[P](s0(smallest_inductive_chains[P], cs)) or not are_inductive_chains[P](cs) or s0(smallest_inductive_chains[P], cs) ∈ cs","s0(smallest_inductive_chains[P], cs) ∈ Set[P].new(elem_in_smallest_inductive_chains[P]) = elem_in_smallest_inductive_chains[P](s0(smallest_inductive_chains[P], cs))","not s0(smallest_inductive_chains[P], cs) ∈ cs","s0(smallest_inductive_chains[P], cs) ∈ smallest_inductive_chains[P]","not s0(smallest_inductive_chains[P], cs) ∈ Set[P].new(elem_in_smallest_inductive_chains[P]) or elem_in_smallest_inductive_chains[P](s0(smallest_inductive_chains[P], cs))","not elem_in_smallest_inductive_chains[P](s0(smallest_inductive_chains[P], cs))","s0(smallest_inductive_chains[P], cs) ∈ Set[P].new(elem_in_smallest_inductive_chains[P])","not s0(smallest_inductive_chains[P], cs) ∈ Set[P].new(elem_in_smallest_inductive_chains[P])"]}
{"goal":"exists(k0: Set[Set[P]]) { c ∈ k0 and are_inductive_chains[P](k0) }","proof":["not c ∈ all_chains[P] or not are_inductive_chains[P](all_chains[P])","not elem_in_smallest_inductive_chains[P](c) or not are_inductive_chains[P](all_chains[P]) or c ∈ all_chains[P]","c ∈ Set[P].new(elem_in_smallest_inductive_chains[P]) = elem_in_smallest_inductive_chains[P](c)","not c ∈ all_chains[P]","c ∈ Set[P].new(elem_in_smallest_inductive_chains[P])","not elem_in_smallest_inductive_chains[P](c)","elem_in_smallest_inductive_chains[P](c)"]}
{"goal":"c ∈ cs","proof":["not elem_in_smallest_inductive_chains[P](c) or not are_inductive_chains[P](cs) or c ∈ cs","not elem_in_smallest_inductive_chains[P](c)","c ∈ Set[P].new(elem_in_smallest_inductive_chains[P]) = elem_in_smallest_inductive_chains[P](c)"]}
{"goal":"is_chain_comparable[P](c, d)","proof":["not d ∈ smallest_inductive_chains[P] or not is_comparable_chain[P](c) or is_chain_comparable[P](c, d)","not is_comparable_chain[P](c)","c ∈ Set[P].new(is_comparable_chain[P]) = is_comparable_chain[P](c)"]}
{"goal":"is_chain_comparable[P](c1, c2)","proof":["not c2 ∈ smallest_inductive_chains[P] or not is_comparable_chain[P](c1) or is_chain_comparable[P](c1, c2)","not is_comparable_chain[P](c1)","c1 ∈ Set[P].new(is_comparable_chain[P]) = is_comparable_chain[P](c1)"]}
{"goal":"Set.empty_set[P] ∈ suc_compare[P](c)","proof":["not Set.empty_set[P] ∈ smallest_inductive_chains[P] or not is_comparable_chain[P](c) or not Set.empty_set[P] ⊆ c or elem_in_suc_compare[P](c, Set.empty_set[P])","Set.empty_set[P] ∈ Set[P].new(elem_in_suc_compare[P](c)) = elem_in_suc_compare[P](c, Set.empty_set[P])","Set[P].new(elem_in_suc_compare[P](c)) = suc_compare[P](c)","elem_in_suc_compare[P](c, Set.empty_set[P])","not elem_in_suc_compare[P](c, Set.empty_set[P]) or Set.empty_set[P] ∈ Set[P].new(elem_in_suc_compare[P](c))","not Set.empty_set[P] ∈ Set[P].new(elem_in_suc_compare[P](c))","Set.empty_set[P] ∈ Set[P].new(elem_in_suc_compare[P](c))"]}
{"goal":"false","proof":["lib(set).negate_fn(c.contains, t) = t ∉ c","lib(set).negate_fn(c.contains, t) != t ∈ c","not lib(set).negate_fn(c.contains, t) or not t ∈ c","lib(set).negate_fn(c.contains, t)","not lib(set).negate_fn(c.contains, t)"]}
{"goal":"Set.empty_set[P] ∈ comparable_chains[P]","proof":["Set.empty_set[P] ∈ Set[P].new(is_comparable_chain[P]) = is_comparable_chain[P](Set.empty_set[P])","not Set.empty_set[P] ∈ Set[P].new(is_comparable_chain[P])"]}
{"goal":"union[P](cs) ∈ comparable_chains[P]","proof":["let s0: Set[P] -> Set[P] satisfy { forall(x0: Set[P]) { not is_comparable_chain[P](x0) or x0 ∈ smallest_inductive_chains[P] } and forall(x1: Set[P], x2: Set[P]) { not x1 ∈ smallest_inductive_chains[P] or not is_comparable_chain[P](x2) or is_chain_comparable[P](x2, x1) } and forall(x3: Set[P]) { not x3 ∈ smallest_inductive_chains[P] or s0(x3) ∈ smallest_inductive_chains[P] or is_comparable_chain[P](x3) } and forall(x4: Set[P]) { not x4 ∈ smallest_inductive_chains[P] or not is_chain_comparable[P](x4, s0(x4)) or is_comparable_chain[P](x4) } }","not s0(union[P](cs)) ∈ smallest_inductive_chains[P] or is_chain_comparable[P](union[P](cs), s0(union[P](cs)))","not union[P](cs) ∈ smallest_inductive_chains[P] or s0(union[P](cs)) ∈ smallest_inductive_chains[P] or is_comparable_chain[P](union[P](cs))","not union[P](cs) ∈ smallest_inductive_chains[P] or not is_chain_comparable[P](union[P](cs), s0(union[P](cs))) or is_comparable_chain[P](union[P](cs))","union[P](cs) ∈ Set[P].new(is_comparable_chain[P]) = is_comparable_chain[P](union[P](cs))","not union[P](cs) ∈ Set[P].new(is_comparable_chain[P])","not is_comparable_chain[P](union[P](cs))","not is_chain_comparable[P](union[P](cs), s0(union[P](cs)))","s0(union[P](cs)) ∈ smallest_inductive_chains[P]","not s0(union[P](cs)) ∈ smallest_inductive_chains[P]"]}
{"goal":"smallest_inductive_chains_contains_empty","proof":["Set.empty_set[P] ∈ Set[P].new(elem_in_smallest_inductive_chains[P]) = elem_in_smallest_inductive_chains[P](Set.empty_set[P])","let s0: Set[P] -> Set[Set[P]] satisfy { forall(x0: Set[P], x1: Set[Set[P]]) { not elem_in_smallest_inductive_chains[P](x0) or not are_inductive_chains[P](x1) or x0 ∈ x1 } and forall(x2: Set[P]) { are_inductive_chains[P](s0(x2)) or elem_in_smallest_inductive_chains[P](x2) } and forall(x3: Set[P]) { not x3 ∈ s0(x3) or elem_in_smallest_inductive_chains[P](x3) } }","not are_inductive_chains[P](s0(Set.empty_set[P])) or Set.empty_set[P] ∈ s0(Set.empty_set[P])","not Set.empty_set[P] ∈ s0(Set.empty_set[P]) or elem_in_smallest_inductive_chains[P](Set.empty_set[P])","are_inductive_chains[P](s0(Set.empty_set[P])) or elem_in_smallest_inductive_chains[P](Set.empty_set[P])","not Set.empty_set[P] ∈ Set[P].new(elem_in_smallest_inductive_chains[P])","not elem_in_smallest_inductive_chains[P](Set.empty_set[P])","are_inductive_chains[P](s0(Set.empty_set[P]))","not Set.empty_set[P] ∈ s0(Set.empty_set[P])","Set.empty_set[P] ∈ s0(Set.empty_set[P])"]}
{"goal":"inductive_compare_subset","proof":["let s0: (Set[Set[P]], Set[Set[P]]) -> Set[P] satisfy { forall(x0: Set[Set[P]], x1: Set[Set[P]], x2: Set[P]) { not x0 ⊆ x1 or not x2 ∈ x0 or x2 ∈ x1 } and forall(x3: Set[Set[P]], x4: Set[Set[P]]) { s0(x3, x4) ∈ x3 or x3 ⊆ x4 } and forall(x5: Set[Set[P]], x6: Set[Set[P]]) { not s0(x6, x5) ∈ x5 or x6 ⊆ x5 } }","not s0(suc_compare[P](c), smallest_inductive_chains[P]) ∈ smallest_inductive_chains[P] or suc_compare[P](c) ⊆ smallest_inductive_chains[P]","s0(suc_compare[P](c), smallest_inductive_chains[P]) ∈ suc_compare[P](c) or suc_compare[P](c) ⊆ smallest_inductive_chains[P]","not elem_in_suc_compare[P](c, s0(suc_compare[P](c), smallest_inductive_chains[P])) or s0(suc_compare[P](c), smallest_inductive_chains[P]) ∈ smallest_inductive_chains[P]","s0(suc_compare[P](c), smallest_inductive_chains[P]) ∈ Set[P].new(elem_in_suc_compare[P](c)) = elem_in_suc_compare[P](c, s0(suc_compare[P](c), smallest_inductive_chains[P]))","Set[P].new(elem_in_suc_compare[P](c)) = suc_compare[P](c)","not s0(suc_compare[P](c), smallest_inductive_chains[P]) ∈ Set[P].new(elem_in_suc_compare[P](c)) or elem_in_suc_compare[P](c, s0(suc_compare[P](c), smallest_inductive_chains[P]))","not s0(suc_compare[P](c), smallest_inductive_chains[P]) ∈ smallest_inductive_chains[P]","s0(suc_compare[P](c), smallest_inductive_chains[P]) ∈ suc_compare[P](c)","not elem_in_suc_compare[P](c, s0(suc_compare[P](c), smallest_inductive_chains[P]))","s0(suc_compare[P](c), smallest_inductive_chains[P]) ∈ Set[P].new(elem_in_suc_compare[P](c))"]}
{"goal":"union[P](ds) ∈ suc_compare[P](c)","proof":["not union[P](ds) ∈ smallest_inductive_chains[P] or not is_comparable_chain[P](c) or not union[P](ds) ⊆ c or elem_in_suc_compare[P](c, union[P](ds))","not union[P](ds) ∈ smallest_inductive_chains[P] or not suc[P](c) ⊆ union[P](ds) or not is_comparable_chain[P](c) or elem_in_suc_compare[P](c, union[P](ds))","union[P](ds) ∈ Set[P].new(elem_in_suc_compare[P](c)) = elem_in_suc_compare[P](c, union[P](ds))","Set[P].new(elem_in_suc_compare[P](c)) = suc_compare[P](c)","not union[P](ds) ∈ Set[P].new(elem_in_suc_compare[P](c))","not elem_in_suc_compare[P](c, union[P](ds))","not union[P](ds) ∈ smallest_inductive_chains[P] or not union[P](ds) ⊆ c or elem_in_suc_compare[P](c, union[P](ds))","not union[P](ds) ⊆ c","not suc[P](c) ⊆ union[P](ds)","suc[P](c) ⊆ union[P](ds)"]}
{"goal":"union[P](ds) ∈ all_chains[P]","proof":["union[P](ds) ∈ Set[P].new(is_chain[P]) = is_chain[P](union[P](ds))"]}
{"goal":"suc[P](c) ∈ all_chains[P]","proof":["suc[P](c) ∈ Set[P].new(is_chain[P]) = is_chain[P](suc[P](c))"]}
{"goal":"comparable_chains_subset","proof":["let s0: (Set[Set[P]], Set[Set[P]]) -> Set[P] satisfy { forall(x0: Set[Set[P]], x1: Set[Set[P]], x2: Set[P]) { not x0 ⊆ x1 or not x2 ∈ x0 or x2 ∈ x1 } and forall(x3: Set[Set[P]], x4: Set[Set[P]]) { s0(x3, x4) ∈ x3 or x3 ⊆ x4 } and forall(x5: Set[Set[P]], x6: Set[Set[P]]) { not s0(x6, x5) ∈ x5 or x6 ⊆ x5 } }","not s0(comparable_chains[P], smallest_inductive_chains[P]) ∈ smallest_inductive_chains[P] or comparable_chains[P] ⊆ smallest_inductive_chains[P]","s0(comparable_chains[P], smallest_inductive_chains[P]) ∈ comparable_chains[P] or comparable_chains[P] ⊆ smallest_inductive_chains[P]","s0(comparable_chains[P], smallest_inductive_chains[P]) ∈ Set[P].new(is_comparable_chain[P]) = is_comparable_chain[P](s0(comparable_chains[P], smallest_inductive_chains[P]))","not is_comparable_chain[P](s0(comparable_chains[P], smallest_inductive_chains[P])) or s0(comparable_chains[P], smallest_inductive_chains[P]) ∈ smallest_inductive_chains[P]","s0(comparable_chains[P], smallest_inductive_chains[P]) ∈ comparable_chains[P]","not s0(comparable_chains[P], smallest_inductive_chains[P]) ∈ smallest_inductive_chains[P]","not s0(comparable_chains[P], smallest_inductive_chains[P]) ∈ Set[P].new(is_comparable_chain[P]) or is_comparable_chain[P](s0(comparable_chains[P], smallest_inductive_chains[P]))","not is_comparable_chain[P](s0(comparable_chains[P], smallest_inductive_chains[P]))","s0(comparable_chains[P], smallest_inductive_chains[P]) ∈ Set[P].new(is_comparable_chain[P])","not s0(comparable_chains[P], smallest_inductive_chains[P]) ∈ Set[P].new(is_comparable_chain[P])"]}
{"goal":"suc[P](a) ∈ suc_compare[P](c)","proof":["not suc[P](a) ∈ smallest_inductive_chains[P] or not suc[P](c) ⊆ suc[P](a) or not is_comparable_chain[P](c) or elem_in_suc_compare[P](c, suc[P](a))","suc[P](a) ∈ Set[P].new(elem_in_suc_compare[P](c)) = elem_in_suc_compare[P](c, suc[P](a))","Set[P].new(elem_in_suc_compare[P](c)) = suc_compare[P](c)","not suc[P](a) ∈ Set[P].new(elem_in_suc_compare[P](c))","elem_in_suc_compare[P](c, suc[P](a))","not elem_in_suc_compare[P](c, suc[P](a))"]}
{"goal":"suc[P](a) ∈ suc_compare[P](c)","proof":["not suc[P](a) ∈ smallest_inductive_chains[P] or not is_comparable_chain[P](c) or not suc[P](a) ⊆ c or elem_in_suc_compare[P](c, suc[P](a))","suc[P](a) ∈ Set[P].new(elem_in_suc_compare[P](c)) = elem_in_suc_compare[P](c, suc[P](a))","Set[P].new(elem_in_suc_compare[P](c)) = suc_compare[P](c)","not suc[P](a) ∈ Set[P].new(elem_in_suc_compare[P](c))","elem_in_suc_compare[P](c, suc[P](a))","not elem_in_suc_compare[P](c, suc[P](a))"]}
{"goal":"suc[P](a) ∈ suc_compare[P](c)","proof":["not suc[P](a) ∈ smallest_inductive_chains[P] or not suc[P](c) ⊆ suc[P](a) or not is_comparable_chain[P](c) or elem_in_suc_compare[P](c, suc[P](a))","suc[P](a) ∈ Set[P].new(elem_in_suc_compare[P](c)) = elem_in_suc_compare[P](c, suc[P](a))","Set[P].new(elem_in_suc_compare[P](c)) = suc_compare[P](c)","not suc[P](a) ∈ Set[P].new(elem_in_suc_compare[P](c))","elem_in_suc_compare[P](c, suc[P](a))","not elem_in_suc_compare[P](c, suc[P](a))"]}
